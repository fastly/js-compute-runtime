{
  "Piping must lock both the ReadableStream and WritableStream": {
    "status": "PASS"
  },
  "Piping finishing must unlock both the ReadableStream and WritableStream": {
    "status": "PASS"
  },
  "pipeTo must check the brand of its ReadableStream this value": {
    "status": "FAIL"
  },
  "pipeTo must check the brand of its WritableStream argument": {
    "status": "PASS"
  },
  "pipeTo must fail if the ReadableStream is locked, and not lock the WritableStream": {
    "status": "PASS"
  },
  "pipeTo must fail if the WritableStream is locked, and not lock the ReadableStream": {
    "status": "PASS"
  },
  "Piping from a ReadableStream from which lots of chunks are synchronously readable": {
    "status": "PASS"
  },
  "Piping from a ReadableStream for which a chunk becomes asynchronously readable after the pipeTo": {
    "status": "PASS"
  },
  "an undefined rejection from pull should cause pipeTo() to reject when preventAbort is true": {
    "status": "PASS"
  },
  "an undefined rejection from pull should cause pipeTo() to reject when preventAbort is false": {
    "status": "PASS"
  },
  "an undefined rejection from write should cause pipeTo() to reject when preventCancel is true": {
    "status": "PASS"
  },
  "an undefined rejection from write should cause pipeTo() to reject when preventCancel is false": {
    "status": "PASS"
  },
  "pipeTo() should reject if an option getter grabs a writer": {
    "status": "PASS"
  },
  "pipeTo() promise should resolve if null is passed": {
    "status": "FAIL"
  }
}