{
  "ReadableStream cancellation: integration test on an infinite stream derived from a random push source": {
    "status": "PASS"
  },
  "ReadableStream cancellation: cancel(reason) should pass through the given reason to the underlying source": {
    "status": "PASS"
  },
  "ReadableStream cancellation: cancel() on a locked stream should fail and not call the underlying source cancel": {
    "status": "PASS"
  },
  "ReadableStream cancellation: should fulfill promise when cancel callback went fine": {
    "status": "PASS"
  },
  "ReadableStream cancellation: returning a value from the underlying source's cancel should not affect the fulfillment value of the promise returned by the stream's cancel": {
    "status": "PASS"
  },
  "ReadableStream cancellation: should reject promise when cancel callback raises an exception": {
    "status": "PASS"
  },
  "ReadableStream cancellation: if the underlying source's cancel method returns a promise, the promise returned by the stream's cancel should fulfill when that one does (1)": {
    "status": "PASS"
  },
  "ReadableStream cancellation: if the underlying source's cancel method returns a promise, the promise returned by the stream's cancel should fulfill when that one does (2)": {
    "status": "PASS"
  },
  "ReadableStream cancellation: if the underlying source's cancel method returns a promise, the promise returned by the stream's cancel should reject when that one does": {
    "status": "PASS"
  },
  "ReadableStream cancellation: cancelling before start finishes should prevent pull() from being called": {
    "status": "PASS"
  },
  "ReadableStream cancellation: underlyingSource.cancel() should called, even with pending pull": {
    "status": "PASS"
  }
}