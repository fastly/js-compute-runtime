{
  "fulfillment value of writer.close() call must be undefined even if the underlying sink returns a non-undefined value": {
    "status": "PASS"
  },
  "when sink calls error asynchronously while sink close is in-flight, the stream should not become errored": {
    "status": "PASS"
  },
  "when sink calls error synchronously while closing, the stream should not become errored": {
    "status": "PASS"
  },
  "when the sink throws during close, and the close is requested while a write is still in-flight, the stream should become errored during the close": {
    "status": "PASS"
  },
  "releaseLock on a stream with a pending write in which the stream has been errored": {
    "status": "PASS"
  },
  "releaseLock on a stream with a pending close in which controller.error() was called": {
    "status": "PASS"
  },
  "when close is called on a WritableStream in writable state, ready should return a fulfilled promise": {
    "status": "PASS"
  },
  "when close is called on a WritableStream in waiting state, ready promise should be fulfilled": {
    "status": "PASS"
  },
  "when close is called on a WritableStream in waiting state, ready should be fulfilled immediately even if close takes a long time": {
    "status": "PASS"
  },
  "returning a thenable from close() should work": {
    "status": "PASS"
  },
  "releaseLock() should not change the result of sync close()": {
    "status": "PASS"
  },
  "releaseLock() should not change the result of async close()": {
    "status": "PASS"
  },
  "close() should set state to CLOSED even if writer has detached": {
    "status": "PASS"
  },
  "the promise returned by async abort during close should resolve": {
    "status": "PASS"
  },
  "promises must fulfill/reject in the expected order on closure": {
    "status": "PASS"
  },
  "promises must fulfill/reject in the expected order on aborted closure": {
    "status": "PASS"
  },
  "promises must fulfill/reject in the expected order on aborted and errored closure": {
    "status": "PASS"
  },
  "close() should not reject until no sink methods are in flight": {
    "status": "PASS"
  },
  "ready promise should be initialised as fulfilled for a writer on a closed stream": {
    "status": "PASS"
  },
  "close() on a writable stream should work": {
    "status": "PASS"
  },
  "close() on a locked stream should reject": {
    "status": "PASS"
  },
  "close() on an erroring stream should reject": {
    "status": "PASS"
  },
  "close() on an errored stream should reject": {
    "status": "PASS"
  },
  "close() on an closed stream should reject": {
    "status": "PASS"
  },
  "close() on a stream with a pending close should reject": {
    "status": "PASS"
  }
}