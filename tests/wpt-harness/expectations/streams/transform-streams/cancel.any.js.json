{
  "cancelling the readable side should call transformer.cancel()": {
    "status": "FAIL"
  },
  "cancelling the readable side should reject if transformer.cancel() throws": {
    "status": "FAIL"
  },
  "aborting the writable side should call transformer.abort()": {
    "status": "FAIL"
  },
  "aborting the writable side should reject if transformer.cancel() throws": {
    "status": "FAIL"
  },
  "closing the writable side should reject if a parallel transformer.cancel() throws": {
    "status": "FAIL"
  },
  "readable.cancel() and a parallel writable.close() should reject if a transformer.cancel() calls controller.error()": {
    "status": "FAIL"
  },
  "writable.abort() and readable.cancel() should reject if a transformer.cancel() calls controller.error()": {
    "status": "FAIL"
  },
  "readable.cancel() should not call cancel() when flush() is already called from writable.close()": {
    "status": "PASS"
  },
  "readable.cancel() should not call cancel() again when already called from writable.abort()": {
    "status": "FAIL"
  },
  "writable.close() should not call flush() when cancel() is already called from readable.cancel()": {
    "status": "FAIL"
  },
  "writable.abort() should not call cancel() again when already called from readable.cancel()": {
    "status": "FAIL"
  }
}