{
  "TransformStream can be constructed with a transform function": {
    "status": "PASS"
  },
  "TransformStream can be constructed with no transform function": {
    "status": "PASS"
  },
  "TransformStream writable starts in the writable state": {
    "status": "PASS"
  },
  "Identity TransformStream: can read from readable what is put into writable": {
    "status": "PASS"
  },
  "Uppercaser sync TransformStream: can read from readable transformed version of what is put into writable": {
    "status": "PASS"
  },
  "Uppercaser-doubler sync TransformStream: can read both chunks put into the readable": {
    "status": "PASS"
  },
  "Uppercaser async TransformStream: can read from readable transformed version of what is put into writable": {
    "status": "PASS"
  },
  "Uppercaser-doubler async TransformStream: can read both chunks put into the readable": {
    "status": "PASS"
  },
  "TransformStream: by default, closing the writable closes the readable (when there are no queued writes)": {
    "status": "PASS"
  },
  "TransformStream: by default, closing the writable waits for transforms to finish before closing both": {
    "status": "PASS"
  },
  "TransformStream: by default, closing the writable closes the readable after sync enqueues and async done": {
    "status": "PASS"
  },
  "TransformStream: by default, closing the writable closes the readable after async enqueues and async done": {
    "status": "PASS"
  },
  "Transform stream should call transformer methods as methods": {
    "status": "PASS"
  },
  "methods should not not have .apply() or .call() called": {
    "status": "PASS"
  },
  "TransformStream start, transform, and flush should be strictly ordered": {
    "status": "PASS"
  },
  "it should be possible to call transform() synchronously": {
    "status": "PASS"
  },
  "closing the writable should close the readable when there are no queued chunks, even with backpressure": {
    "status": "PASS"
  },
  "enqueue() should throw after controller.terminate()": {
    "status": "PASS"
  },
  "enqueue() should throw after readable.cancel()": {
    "status": "PASS"
  },
  "controller.terminate() should do nothing the second time it is called": {
    "status": "PASS"
  },
  "terminate() should abort writable immediately after readable.cancel()": {
    "status": "FAIL"
  },
  "terminate() should do nothing after readable.cancel() resolves": {
    "status": "PASS"
  },
  "start() should not be called twice": {
    "status": "PASS"
  },
  "specifying a defined readableType should throw": {
    "status": "FAIL"
  },
  "specifying a defined writableType should throw": {
    "status": "FAIL"
  },
  "Subclassing TransformStream should work": {
    "status": "PASS"
  }
}