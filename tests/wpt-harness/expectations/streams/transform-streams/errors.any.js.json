{
  "TransformStream errors thrown in transform put the writable and readable in an errored state": {
    "status": "PASS"
  },
  "TransformStream errors thrown in flush put the writable and readable in an errored state": {
    "status": "PASS"
  },
  "errored TransformStream should not enqueue new chunks": {
    "status": "PASS"
  },
  "TransformStream transformer.start() rejected promise should error the stream": {
    "status": "PASS"
  },
  "when controller.error is followed by a rejection, the error reason should come from controller.error": {
    "status": "PASS"
  },
  "TransformStream constructor should throw when start does": {
    "status": "PASS"
  },
  "when strategy.size throws inside start(), the constructor should throw the same error": {
    "status": "PASS"
  },
  "when strategy.size calls controller.error() then throws, the constructor should throw the first error": {
    "status": "PASS"
  },
  "cancelling the readable side should error the writable": {
    "status": "PASS"
  },
  "it should be possible to error the readable between close requested and complete": {
    "status": "PASS"
  },
  "an exception from transform() should error the stream if terminate has been requested but not completed": {
    "status": "PASS"
  },
  "abort should set the close reason for the writable when it happens before cancel during start, and cancel should reject": {
    "status": "PASS"
  },
  "abort should set the close reason for the writable when it happens before cancel during underlying sink write, but cancel should still succeed": {
    "status": "PASS"
  },
  "controller.error() should do nothing the second time it is called": {
    "status": "PASS"
  },
  "controller.error() should close writable immediately after readable.cancel()": {
    "status": "FAIL"
  },
  "controller.error() should do nothing after readable.cancel() resolves": {
    "status": "PASS"
  },
  "controller.error() should do nothing after writable.abort() has completed": {
    "status": "PASS"
  },
  "controller.error() should do nothing after a transformer method has thrown an exception": {
    "status": "PASS"
  },
  "erroring during write with backpressure should result in the write failing": {
    "status": "PASS"
  },
  "a write() that was waiting for backpressure should reject if the writable is aborted": {
    "status": "PASS"
  },
  "the readable should be errored with the reason passed to the writable abort() method": {
    "status": "PASS"
  }
}