{
  "getReader({mode: \"byob\"}) throws on non-bytes streams": {
    "status": "PASS"
  },
  "ReadableStream with byte source can be constructed with no errors": {
    "status": "PASS"
  },
  "getReader({mode}) must perform ToString()": {
    "status": "PASS"
  },
  "ReadableStream with byte source: Construct and expect start and pull being called": {
    "status": "PASS"
  },
  "ReadableStream with byte source: No automatic pull call if start doesn't finish": {
    "status": "PASS"
  },
  "ReadableStream with byte source: start() throws an exception": {
    "status": "PASS"
  },
  "ReadableStream with byte source: Construct with highWaterMark of 0": {
    "status": "PASS"
  },
  "ReadableStream with byte source: desiredSize when closed": {
    "status": "PASS"
  },
  "ReadableStream with byte source: desiredSize when errored": {
    "status": "PASS"
  },
  "ReadableStream with byte source: getReader(), then releaseLock()": {
    "status": "PASS"
  },
  "ReadableStream with byte source: getReader() with mode set to byob, then releaseLock()": {
    "status": "PASS"
  },
  "ReadableStream with byte source: Test that closing a stream does not release a reader automatically": {
    "status": "PASS"
  },
  "ReadableStream with byte source: Test that closing a stream does not release a BYOB reader automatically": {
    "status": "PASS"
  },
  "ReadableStream with byte source: Test that erroring a stream does not release a reader automatically": {
    "status": "PASS"
  },
  "ReadableStream with byte source: Test that erroring a stream does not release a BYOB reader automatically": {
    "status": "PASS"
  },
  "ReadableStream with byte source: releaseLock() on ReadableStreamDefaultReader must reject pending read()": {
    "status": "PASS"
  },
  "ReadableStream with byte source: releaseLock() on ReadableStreamBYOBReader must reject pending read()": {
    "status": "PASS"
  },
  "ReadableStream with byte source: Automatic pull() after start()": {
    "status": "PASS"
  },
  "ReadableStream with byte source: Automatic pull() after start() and read()": {
    "status": "PASS"
  },
  "ReadableStream with byte source: autoAllocateChunkSize": {
    "status": "PASS"
  },
  "ReadableStream with byte source: Mix of auto allocate and BYOB": {
    "status": "PASS"
  },
  "ReadableStream with byte source: Automatic pull() after start() and read(view)": {
    "status": "PASS"
  },
  "ReadableStream with byte source: enqueue(), getReader(), then read()": {
    "status": "PASS"
  },
  "ReadableStream with byte source: Push source that doesn't understand pull signal": {
    "status": "PASS"
  },
  "ReadableStream with byte source: pull() function is not callable": {
    "status": "PASS"
  },
  "ReadableStream with byte source: enqueue() with Uint16Array, getReader(), then read()": {
    "status": "PASS"
  },
  "ReadableStream with byte source: enqueue(), read(view) partially, then read()": {
    "status": "PASS"
  },
  "ReadableStream with byte source: getReader(), enqueue(), close(), then read()": {
    "status": "PASS"
  },
  "ReadableStream with byte source: enqueue(), close(), getReader(), then read()": {
    "status": "PASS"
  },
  "ReadableStream with byte source: Respond to pull() by enqueue()": {
    "status": "PASS"
  },
  "ReadableStream with byte source: Respond to pull() by enqueue() asynchronously": {
    "status": "PASS"
  },
  "ReadableStream with byte source: Respond to multiple pull() by separate enqueue()": {
    "status": "PASS"
  },
  "ReadableStream with byte source: read(view), then respond()": {
    "status": "PASS"
  },
  "ReadableStream with byte source: read(view), then respondWithNewView() with a transferred ArrayBuffer": {
    "status": "PASS"
  },
  "ReadableStream with byte source: read(view), then respond() with too big value": {
    "status": "PASS"
  },
  "ReadableStream with byte source: respond(3) to read(view) with 2 element Uint16Array enqueues the 1 byte remainder": {
    "status": "PASS"
  },
  "ReadableStream with byte source: enqueue(), getReader(), then read(view)": {
    "status": "PASS"
  },
  "ReadableStream with byte source: enqueue(), getReader(), then cancel() (mode = not BYOB)": {
    "status": "PASS"
  },
  "ReadableStream with byte source: enqueue(), getReader(), then cancel() (mode = BYOB)": {
    "status": "PASS"
  },
  "ReadableStream with byte source: getReader(), read(view), then cancel()": {
    "status": "PASS"
  },
  "ReadableStream with byte source: cancel() with partially filled pending pull() request": {
    "status": "PASS"
  },
  "ReadableStream with byte source: enqueue(), getReader(), then read(view) where view.buffer is not fully covered by view": {
    "status": "PASS"
  },
  "ReadableStream with byte source: Multiple enqueue(), getReader(), then read(view)": {
    "status": "PASS"
  },
  "ReadableStream with byte source: enqueue(), getReader(), then read(view) with a bigger view": {
    "status": "PASS"
  },
  "ReadableStream with byte source: enqueue(), getReader(), then read(view) with smaller views": {
    "status": "PASS"
  },
  "ReadableStream with byte source: enqueue() 1 byte, getReader(), then read(view) with Uint16Array": {
    "status": "PASS"
  },
  "ReadableStream with byte source: enqueue() 3 byte, getReader(), then read(view) with 2-element Uint16Array": {
    "status": "PASS"
  },
  "ReadableStream with byte source: read(view) with Uint16Array on close()-d stream with 1 byte enqueue()-d must fail": {
    "status": "PASS"
  },
  "ReadableStream with byte source: A stream must be errored if close()-d before fulfilling read(view) with Uint16Array": {
    "status": "PASS"
  },
  "ReadableStream with byte source: Throw if close()-ed more than once": {
    "status": "PASS"
  },
  "ReadableStream with byte source: Throw on enqueue() after close()": {
    "status": "PASS"
  },
  "ReadableStream with byte source: read(view), then respond() and close() in pull()": {
    "status": "PASS"
  },
  "ReadableStream with byte source: read(view) with Uint32Array, then fill it by multiple respond() calls": {
    "status": "PASS"
  },
  "ReadableStream with byte source: read(view) with Uint32Array, then fill it by multiple enqueue() calls": {
    "status": "PASS"
  },
  "ReadableStream with byte source: read() twice, then enqueue() twice": {
    "status": "PASS"
  },
  "ReadableStream with byte source: Multiple read(view), close() and respond()": {
    "status": "PASS"
  },
  "ReadableStream with byte source: Multiple read(view), big enqueue()": {
    "status": "PASS"
  },
  "ReadableStream with byte source: Multiple read(view) and multiple enqueue()": {
    "status": "PASS"
  },
  "ReadableStream with byte source: read(view) with passing undefined as view must fail": {
    "status": "PASS"
  },
  "ReadableStream with byte source: read(view) with passing an empty object as view must fail": {
    "status": "PASS"
  },
  "ReadableStream with byte source: Even read(view) with passing ArrayBufferView like object as view must fail": {
    "status": "PASS"
  },
  "ReadableStream with byte source: read() on an errored stream": {
    "status": "PASS"
  },
  "ReadableStream with byte source: read(), then error()": {
    "status": "PASS"
  },
  "ReadableStream with byte source: read(view) on an errored stream": {
    "status": "PASS"
  },
  "ReadableStream with byte source: read(view), then error()": {
    "status": "PASS"
  },
  "ReadableStream with byte source: Throwing in pull function must error the stream": {
    "status": "PASS"
  },
  "ReadableStream with byte source: Throwing in pull in response to read() must be ignored if the stream is errored in it": {
    "status": "PASS"
  },
  "ReadableStream with byte source: Throwing in pull in response to read(view) function must error the stream": {
    "status": "PASS"
  },
  "ReadableStream with byte source: Throwing in pull in response to read(view) must be ignored if the stream is errored in it": {
    "status": "PASS"
  },
  "calling respond() twice on the same byobRequest should throw": {
    "status": "PASS"
  },
  "calling respondWithNewView() twice on the same byobRequest should throw": {
    "status": "PASS"
  },
  "calling respond(0) twice on the same byobRequest should throw even when closed": {
    "status": "PASS"
  },
  "calling respond() should throw when canceled": {
    "status": "PASS"
  },
  "pull() resolving should not resolve read()": {
    "status": "PASS"
  },
  "ReadableStream with byte source: default reader + autoAllocateChunkSize + byobRequest interaction": {
    "status": "PASS"
  },
  "ReadableStream with byte source: autoAllocateChunkSize cannot be 0": {
    "status": "PASS"
  },
  "ReadableStreamBYOBReader can be constructed directly": {
    "status": "PASS"
  },
  "ReadableStreamBYOBReader constructor requires a ReadableStream argument": {
    "status": "PASS"
  },
  "ReadableStreamBYOBReader constructor requires an unlocked ReadableStream": {
    "status": "PASS"
  },
  "ReadableStreamBYOBReader constructor requires a ReadableStream with type \"bytes\"": {
    "status": "PASS"
  },
  "ReadableStream constructor should not accept a strategy with a size defined if type is \"bytes\"": {
    "status": "PASS"
  },
  "ReadableStream with byte source: respondWithNewView() with a smaller view": {
    "status": "PASS"
  },
  "ReadableStream with byte source: respondWithNewView() with a zero-length view (in the closed state)": {
    "status": "PASS"
  },
  "ReadableStream with byte source: respondWithNewView() with a transferred non-zero-length view (in the readable state)": {
    "status": "PASS"
  },
  "ReadableStream with byte source: respondWithNewView() with a transferred zero-length view (in the closed state)": {
    "status": "PASS"
  },
  "ReadableStream with byte source: enqueue() discards auto-allocated BYOB request": {
    "status": "PASS"
  },
  "ReadableStream with byte source: releaseLock() with pending read(view), read(view) on second reader, respond()": {
    "status": "PASS"
  },
  "ReadableStream with byte source: releaseLock() with pending read(view), read(view) on second reader with 1 element Uint16Array, respond(1)": {
    "status": "PASS"
  },
  "ReadableStream with byte source: releaseLock() with pending read(view), read(view) on second reader with 2 element Uint8Array, respond(3)": {
    "status": "PASS"
  },
  "ReadableStream with byte source: releaseLock() with pending read(view), read(view) on second reader, respondWithNewView()": {
    "status": "PASS"
  },
  "ReadableStream with byte source: releaseLock() with pending read(view), read(view) on second reader, enqueue()": {
    "status": "PASS"
  },
  "ReadableStream with byte source: releaseLock() with pending read(view), read(view) on second reader, close(), respond(0)": {
    "status": "PASS"
  },
  "ReadableStream with byte source: autoAllocateChunkSize, releaseLock() with pending read(), read() on second reader, respond()": {
    "status": "PASS"
  },
  "ReadableStream with byte source: autoAllocateChunkSize, releaseLock() with pending read(), read() on second reader, enqueue()": {
    "status": "PASS"
  },
  "ReadableStream with byte source: autoAllocateChunkSize, releaseLock() with pending read(), read(view) on second reader, respond()": {
    "status": "PASS"
  },
  "ReadableStream with byte source: autoAllocateChunkSize, releaseLock() with pending read(), read(view) on second reader, enqueue()": {
    "status": "PASS"
  },
  "ReadableStream with byte source: read(view) with 1 element Uint16Array, respond(1), releaseLock(), read(view) on second reader with 1 element Uint16Array, respond(1)": {
    "status": "PASS"
  },
  "ReadableStream with byte source: read(view) with 1 element Uint16Array, respond(1), releaseLock(), read() on second reader, enqueue()": {
    "status": "PASS"
  },
  "ReadableStream with byte source: autoAllocateChunkSize, read(), respondWithNewView()": {
    "status": "PASS"
  }
}