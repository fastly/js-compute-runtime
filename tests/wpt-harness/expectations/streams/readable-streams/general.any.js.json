{
  "ReadableStream can be constructed with no errors": {
    "status": "PASS"
  },
  "ReadableStream can't be constructed with garbage": {
    "status": "PASS"
  },
  "ReadableStream can't be constructed with an invalid type": {
    "status": "FAIL"
  },
  "ReadableStream constructor should throw for non-function start arguments": {
    "status": "PASS"
  },
  "ReadableStream constructor will not tolerate initial garbage as cancel argument": {
    "status": "PASS"
  },
  "ReadableStream constructor will not tolerate initial garbage as pull argument": {
    "status": "PASS"
  },
  "ReadableStream start should be called with the proper thisArg": {
    "status": "PASS"
  },
  "ReadableStream start controller parameter should be extensible": {
    "status": "PASS"
  },
  "default ReadableStream getReader() should only accept mode:undefined": {
    "status": "PASS"
  },
  "ReadableStream should be able to call start method within prototype chain of its source": {
    "status": "PASS"
  },
  "ReadableStream start should be able to return a promise": {
    "status": "PASS"
  },
  "ReadableStream start should be able to return a promise and reject it": {
    "status": "PASS"
  },
  "ReadableStream should be able to enqueue different objects.": {
    "status": "PASS"
  },
  "ReadableStream: if pull rejects, it should error the stream": {
    "status": "FAIL"
  },
  "ReadableStream: should only call pull once upon starting the stream": {
    "status": "PASS"
  },
  "ReadableStream: should call pull when trying to read from a started, empty stream": {
    "status": "PASS"
  },
  "ReadableStream: should only call pull once on a non-empty stream read from before start fulfills": {
    "status": "PASS"
  },
  "ReadableStream: should only call pull once on a non-empty stream read from after start fulfills": {
    "status": "PASS"
  },
  "ReadableStream: should call pull in reaction to read()ing the last chunk, if not draining": {
    "status": "PASS"
  },
  "ReadableStream: should not call pull() in reaction to read()ing the last chunk, if draining": {
    "status": "PASS"
  },
  "ReadableStream: should not call pull until the previous pull call's promise fulfills": {
    "status": "PASS"
  },
  "ReadableStream: should pull after start, and after every read": {
    "status": "PASS"
  },
  "ReadableStream: should not call pull after start if the stream is now closed": {
    "status": "PASS"
  },
  "ReadableStream: should call pull after enqueueing from inside pull (with no read requests), if strategy allows": {
    "status": "PASS"
  },
  "ReadableStream pull should be able to close a stream.": {
    "status": "PASS"
  },
  "ReadableStream pull should be able to error a stream.": {
    "status": "PASS"
  },
  "ReadableStream pull should be able to error a stream and throw.": {
    "status": "PASS"
  },
  "ReadableStream: enqueue should throw when the stream is readable but draining": {
    "status": "PASS"
  },
  "ReadableStream: enqueue should throw when the stream is closed": {
    "status": "PASS"
  },
  "ReadableStream: should call underlying source methods as methods": {
    "status": "PASS"
  },
  "ReadableStream: desiredSize when closed": {
    "status": "PASS"
  },
  "ReadableStream: desiredSize when errored": {
    "status": "PASS"
  },
  "Subclassing ReadableStream should work": {
    "status": "PASS"
  },
  "ReadableStream strategies: the default strategy should give desiredSize of 1 to start, decreasing by 1 per enqueue": {
    "status": "PASS"
  },
  "ReadableStream strategies: the default strategy should continue giving desiredSize of 1 if the chunks are read immediately": {
    "status": "PASS"
  },
  "ReadableStream integration test: adapting a random push source": {
    "status": "PASS"
  },
  "ReadableStream integration test: adapting a sync pull source": {
    "status": "PASS"
  },
  "ReadableStream integration test: adapting an async pull source": {
    "status": "PASS"
  }
}