// Generated by `wit-bindgen` 0.9.0. DO NOT EDIT!
#ifndef __BINDINGS_FASTLY_WORLD_H
#define __BINDINGS_FASTLY_WORLD_H
#ifdef __cplusplus
extern "C" {
#endif

#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <stdbool.h>

typedef struct {
  char*ptr;
  size_t len;
} fastly_world_string_t;

typedef uint8_t fastly_compute_at_edge_types_error_t;

// Unknown error value.
// It should be an internal error if this is returned.
#define FASTLY_COMPUTE_AT_EDGE_TYPES_ERROR_UNKNOWN_ERROR 0
// Generic error value.
// This means that some unexpected error occurred during a hostcall.
#define FASTLY_COMPUTE_AT_EDGE_TYPES_ERROR_GENERIC_ERROR 1
// Invalid argument.
#define FASTLY_COMPUTE_AT_EDGE_TYPES_ERROR_INVALID_ARGUMENT 2
// Invalid handle.
// Thrown when a handle is not valid. E.G. No dictionary exists with the given name.
#define FASTLY_COMPUTE_AT_EDGE_TYPES_ERROR_BAD_HANDLE 3
// Buffer length error.
// Thrown when a buffer is too long.
#define FASTLY_COMPUTE_AT_EDGE_TYPES_ERROR_BUFFER_LEN 4
// Unsupported operation error.
// This error is thrown when some operation cannot be performed, because it is not supported.
#define FASTLY_COMPUTE_AT_EDGE_TYPES_ERROR_UNSUPPORTED 5
// Alignment error.
// This is thrown when a pointer does not point to a properly aligned slice of memory.
#define FASTLY_COMPUTE_AT_EDGE_TYPES_ERROR_BAD_ALIGN 6
// Invalid HTTP error.
// This can be thrown when a method, URI, header, or status is not valid. This can also
// be thrown if a message head is too large.
#define FASTLY_COMPUTE_AT_EDGE_TYPES_ERROR_HTTP_INVALID 7
// HTTP user error.
// This is thrown in cases where user code caused an HTTP error. For example, attempt to send
// a 1xx response code, or a request with a non-absolute URI. This can also be caused by
// an unexpected header: both `content-length` and `transfer-encoding`, for example.
#define FASTLY_COMPUTE_AT_EDGE_TYPES_ERROR_HTTP_USER 8
// HTTP incomplete message error.
// This can be thrown when a stream ended unexpectedly.
#define FASTLY_COMPUTE_AT_EDGE_TYPES_ERROR_HTTP_INCOMPLETE 9
// A `None` error.
// This status code is used to indicate when an optional value did not exist, as opposed to
// an empty value.
// Note, this value should no longer be used, as we have explicit optional types now.
#define FASTLY_COMPUTE_AT_EDGE_TYPES_ERROR_OPTIONAL_NONE 10
// Message head too large.
#define FASTLY_COMPUTE_AT_EDGE_TYPES_ERROR_HTTP_HEAD_TOO_LARGE 11
// Invalid HTTP status.
#define FASTLY_COMPUTE_AT_EDGE_TYPES_ERROR_HTTP_INVALID_STATUS 12
// Limit exceeded
// 
// This is returned when an attempt to allocate a resource has exceeded the maximum number of
// resources permitted. For example, creating too many response handles.
#define FASTLY_COMPUTE_AT_EDGE_TYPES_ERROR_LIMIT_EXCEEDED 13

typedef uint32_t fastly_compute_at_edge_types_secret_handle_t;

typedef fastly_compute_at_edge_types_secret_handle_t fastly_compute_at_edge_http_types_secret_handle_t;

typedef uint32_t fastly_compute_at_edge_http_types_body_handle_t;

typedef uint32_t fastly_compute_at_edge_http_types_request_handle_t;

typedef uint32_t fastly_compute_at_edge_http_types_pending_request_handle_t;

typedef uint32_t fastly_compute_at_edge_http_types_response_handle_t;

typedef struct {
  fastly_compute_at_edge_http_types_request_handle_t f0;
  fastly_compute_at_edge_http_types_body_handle_t f1;
} fastly_compute_at_edge_http_types_request_t;

typedef struct {
  fastly_compute_at_edge_http_types_response_handle_t f0;
  fastly_compute_at_edge_http_types_body_handle_t f1;
} fastly_compute_at_edge_http_types_response_t;

typedef uint8_t fastly_compute_at_edge_http_types_send_error_detail_tag_t;

// The send-error-detail struct has not been populated.
#define FASTLY_COMPUTE_AT_EDGE_HTTP_TYPES_SEND_ERROR_DETAIL_TAG_UNINITIALIZED 0
// There was no send error.
#define FASTLY_COMPUTE_AT_EDGE_HTTP_TYPES_SEND_ERROR_DETAIL_TAG_OK 1
// The system encountered a timeout when trying to find an IP address for the backend
// hostname.
#define FASTLY_COMPUTE_AT_EDGE_HTTP_TYPES_SEND_ERROR_DETAIL_TAG_DNS_TIMEOUT 2
// The system encountered a DNS error when trying to find an IP address for the backend
// hostname. The fields dns-error-rcode and dns-error-info-code may be set in the
// send-error-detail.
#define FASTLY_COMPUTE_AT_EDGE_HTTP_TYPES_SEND_ERROR_DETAIL_TAG_DNS_ERROR 3
// The system cannot determine which backend to use, or the specified backend was invalid.
#define FASTLY_COMPUTE_AT_EDGE_HTTP_TYPES_SEND_ERROR_DETAIL_TAG_DESTINATION_NOT_FOUND 4
// The system considers the backend to be unavailable e.g., recent attempts to communicate
// with it may have failed, or a health check may indicate that it is down.
#define FASTLY_COMPUTE_AT_EDGE_HTTP_TYPES_SEND_ERROR_DETAIL_TAG_DESTINATION_UNAVAILABLE 5
// The system cannot find a route to the next-hop IP address.
#define FASTLY_COMPUTE_AT_EDGE_HTTP_TYPES_SEND_ERROR_DETAIL_TAG_DESTINATION_IP_UNROUTABLE 6
// The system's connection to the backend was refused.
#define FASTLY_COMPUTE_AT_EDGE_HTTP_TYPES_SEND_ERROR_DETAIL_TAG_CONNECTION_REFUSED 7
// The system's connection to the backend was closed before a complete response was
// received.
#define FASTLY_COMPUTE_AT_EDGE_HTTP_TYPES_SEND_ERROR_DETAIL_TAG_CONNECTION_TERMINATED 8
// The system's attempt to open a connection to the backend timed out.
#define FASTLY_COMPUTE_AT_EDGE_HTTP_TYPES_SEND_ERROR_DETAIL_TAG_CONNECTION_TIMEOUT 9
// The system is configured to limit the number of connections it has to the backend, and
// that limit has been exceeded.
#define FASTLY_COMPUTE_AT_EDGE_HTTP_TYPES_SEND_ERROR_DETAIL_TAG_CONNECTION_LIMIT_REACHED 10
// The system encountered an error when verifying the certificate presented by the backend.
#define FASTLY_COMPUTE_AT_EDGE_HTTP_TYPES_SEND_ERROR_DETAIL_TAG_TLS_CERTIFICATE_ERROR 11
// The system encountered an error with the backend TLS configuration.
#define FASTLY_COMPUTE_AT_EDGE_HTTP_TYPES_SEND_ERROR_DETAIL_TAG_TLS_CONFIGURATION_ERROR 12
// The system received an incomplete response to the request from the backend.
#define FASTLY_COMPUTE_AT_EDGE_HTTP_TYPES_SEND_ERROR_DETAIL_TAG_HTTP_INCOMPLETE_RESPONSE 13
// The system received a response to the request whose header section was considered too
// large.
#define FASTLY_COMPUTE_AT_EDGE_HTTP_TYPES_SEND_ERROR_DETAIL_TAG_HTTP_RESPONSE_HEADER_SECTION_TOO_LARGE 14
// The system received a response to the request whose body was considered too large.
#define FASTLY_COMPUTE_AT_EDGE_HTTP_TYPES_SEND_ERROR_DETAIL_TAG_HTTP_RESPONSE_BODY_TOO_LARGE 15
// The system reached a configured time limit waiting for the complete response.
#define FASTLY_COMPUTE_AT_EDGE_HTTP_TYPES_SEND_ERROR_DETAIL_TAG_HTTP_RESPONSE_TIMEOUT 16
// The system received a response to the request whose status code or reason phrase was
// invalid.
#define FASTLY_COMPUTE_AT_EDGE_HTTP_TYPES_SEND_ERROR_DETAIL_TAG_HTTP_RESPONSE_STATUS_INVALID 17
// The process of negotiating an upgrade of the HTTP version between the system and the
// backend failed.
#define FASTLY_COMPUTE_AT_EDGE_HTTP_TYPES_SEND_ERROR_DETAIL_TAG_HTTP_UPGRADE_FAILED 18
// The system encountered an HTTP protocol error when communicating with the backend. This
// error will only be used when a more specific one is not defined.
#define FASTLY_COMPUTE_AT_EDGE_HTTP_TYPES_SEND_ERROR_DETAIL_TAG_HTTP_PROTOCOL_ERROR 19
// An invalid cache key was provided for the request.
#define FASTLY_COMPUTE_AT_EDGE_HTTP_TYPES_SEND_ERROR_DETAIL_TAG_HTTP_REQUEST_CACHE_KEY_INVALID 20
// An invalid URI was provided for the request.
#define FASTLY_COMPUTE_AT_EDGE_HTTP_TYPES_SEND_ERROR_DETAIL_TAG_HTTP_REQUEST_URI_INVALID 21
// The system encountered an unexpected internal error.
#define FASTLY_COMPUTE_AT_EDGE_HTTP_TYPES_SEND_ERROR_DETAIL_TAG_INTERNAL_ERROR 22
// The system received a TLS alert from the backend. The field tls-alert-id may be set in
// the send-error-detail.
#define FASTLY_COMPUTE_AT_EDGE_HTTP_TYPES_SEND_ERROR_DETAIL_TAG_TLS_ALERT_RECEIVED 23
// The system encountered a TLS error when communicating with the backend, either during
// the handshake or afterwards.
#define FASTLY_COMPUTE_AT_EDGE_HTTP_TYPES_SEND_ERROR_DETAIL_TAG_TLS_PROTOCOL_ERROR 24

// Mask representing which fields are understood by the guest, and which have been set by the host.
// 
// When the guest calls hostcalls with a mask, it should set every bit in the mask that corresponds
// to a defined flag. This signals the host to write only to fields with a set bit, allowing
// forward compatibility for existing guest programs even after new fields are added to the struct.
typedef uint8_t fastly_compute_at_edge_http_types_send_error_detail_mask_t;

#define FASTLY_COMPUTE_AT_EDGE_HTTP_TYPES_SEND_ERROR_DETAIL_MASK_RESERVED (1 << 0)
#define FASTLY_COMPUTE_AT_EDGE_HTTP_TYPES_SEND_ERROR_DETAIL_MASK_DNS_ERROR_RCODE (1 << 1)
#define FASTLY_COMPUTE_AT_EDGE_HTTP_TYPES_SEND_ERROR_DETAIL_MASK_DNS_ERROR_INFO_CODE (1 << 2)
#define FASTLY_COMPUTE_AT_EDGE_HTTP_TYPES_SEND_ERROR_DETAIL_MASK_TLS_ALERT_ID (1 << 3)

typedef struct {
  fastly_compute_at_edge_http_types_send_error_detail_tag_t tag;
  fastly_compute_at_edge_http_types_send_error_detail_mask_t mask;
  uint16_t dns_error_rcode;
  uint16_t dns_error_info_code;
  uint8_t tls_alert_id;
} fastly_compute_at_edge_http_types_send_error_detail_t;

typedef uint8_t fastly_compute_at_edge_http_types_http_version_t;

#define FASTLY_COMPUTE_AT_EDGE_HTTP_TYPES_HTTP_VERSION_HTTP09 0
#define FASTLY_COMPUTE_AT_EDGE_HTTP_TYPES_HTTP_VERSION_HTTP10 1
#define FASTLY_COMPUTE_AT_EDGE_HTTP_TYPES_HTTP_VERSION_HTTP11 2
#define FASTLY_COMPUTE_AT_EDGE_HTTP_TYPES_HTTP_VERSION_H2 3
#define FASTLY_COMPUTE_AT_EDGE_HTTP_TYPES_HTTP_VERSION_H3 4

typedef uint8_t fastly_compute_at_edge_http_types_content_encodings_t;

#define FASTLY_COMPUTE_AT_EDGE_HTTP_TYPES_CONTENT_ENCODINGS_GZIP (1 << 0)

// Adjust how this requests's framing headers are determined.
typedef uint8_t fastly_compute_at_edge_http_types_framing_headers_mode_t;

#define FASTLY_COMPUTE_AT_EDGE_HTTP_TYPES_FRAMING_HEADERS_MODE_AUTOMATIC 0
#define FASTLY_COMPUTE_AT_EDGE_HTTP_TYPES_FRAMING_HEADERS_MODE_MANUALLY_FROM_HEADERS 1

typedef uint8_t fastly_compute_at_edge_http_types_tls_version_t;

#define FASTLY_COMPUTE_AT_EDGE_HTTP_TYPES_TLS_VERSION_TLS1 0
#define FASTLY_COMPUTE_AT_EDGE_HTTP_TYPES_TLS_VERSION_TLS11 1
#define FASTLY_COMPUTE_AT_EDGE_HTTP_TYPES_TLS_VERSION_TLS12 2
#define FASTLY_COMPUTE_AT_EDGE_HTTP_TYPES_TLS_VERSION_TLS13 3

typedef struct {
  fastly_world_string_t client_cert;
  fastly_compute_at_edge_http_types_secret_handle_t client_key;
} fastly_compute_at_edge_http_types_client_cert_config_t;

typedef struct {
  bool is_some;
  fastly_world_string_t val;
} fastly_world_option_string_t;

typedef struct {
  bool is_some;
  uint32_t val;
} fastly_world_option_u32_t;

typedef struct {
  bool is_some;
  bool val;
} fastly_world_option_bool_t;

typedef struct {
  bool is_some;
  fastly_compute_at_edge_http_types_tls_version_t val;
} fastly_world_option_fastly_compute_at_edge_http_types_tls_version_t;

typedef struct {
  bool is_some;
  fastly_compute_at_edge_http_types_client_cert_config_t val;
} fastly_world_option_fastly_compute_at_edge_http_types_client_cert_config_t;

// Create a backend for later use
typedef struct {
  fastly_world_option_string_t host_override;
  fastly_world_option_u32_t connect_timeout;
  fastly_world_option_u32_t first_byte_timeout;
  fastly_world_option_u32_t between_bytes_timeout;
  fastly_world_option_bool_t use_ssl;
  fastly_world_option_bool_t dont_pool;
  fastly_world_option_fastly_compute_at_edge_http_types_tls_version_t ssl_min_version;
  fastly_world_option_fastly_compute_at_edge_http_types_tls_version_t ssl_max_version;
  fastly_world_option_string_t cert_hostname;
  fastly_world_option_string_t ca_cert;
  fastly_world_option_string_t ciphers;
  fastly_world_option_string_t sni_hostname;
  fastly_world_option_fastly_compute_at_edge_http_types_client_cert_config_t client_cert;
} fastly_compute_at_edge_http_types_dynamic_backend_config_t;

typedef uint16_t fastly_compute_at_edge_http_types_http_status_t;

typedef fastly_compute_at_edge_types_error_t fastly_compute_at_edge_uap_error_t;

typedef struct {
  fastly_world_string_t family;
  fastly_world_string_t major;
  fastly_world_string_t minor;
  fastly_world_string_t patch;
} fastly_compute_at_edge_uap_user_agent_t;

typedef fastly_compute_at_edge_types_error_t fastly_compute_at_edge_http_body_error_t;

typedef fastly_compute_at_edge_http_types_body_handle_t fastly_compute_at_edge_http_body_body_handle_t;

typedef uint8_t fastly_compute_at_edge_http_body_write_end_t;

#define FASTLY_COMPUTE_AT_EDGE_HTTP_BODY_WRITE_END_BACK 0
#define FASTLY_COMPUTE_AT_EDGE_HTTP_BODY_WRITE_END_FRONT 1

typedef struct {
  uint8_t *ptr;
  size_t len;
} fastly_world_list_u8_t;

typedef fastly_compute_at_edge_types_error_t fastly_compute_at_edge_log_error_t;

typedef uint32_t fastly_compute_at_edge_log_handle_t;

typedef fastly_compute_at_edge_types_error_t fastly_compute_at_edge_http_req_error_t;

typedef fastly_compute_at_edge_http_types_body_handle_t fastly_compute_at_edge_http_req_body_handle_t;

typedef fastly_compute_at_edge_http_types_request_handle_t fastly_compute_at_edge_http_req_request_handle_t;

typedef fastly_compute_at_edge_http_types_http_version_t fastly_compute_at_edge_http_req_http_version_t;

typedef fastly_compute_at_edge_http_types_response_t fastly_compute_at_edge_http_req_response_t;

typedef fastly_compute_at_edge_http_types_pending_request_handle_t fastly_compute_at_edge_http_req_pending_request_handle_t;

typedef fastly_compute_at_edge_http_types_content_encodings_t fastly_compute_at_edge_http_req_content_encodings_t;

typedef fastly_compute_at_edge_http_types_framing_headers_mode_t fastly_compute_at_edge_http_req_framing_headers_mode_t;

typedef fastly_compute_at_edge_http_types_dynamic_backend_config_t fastly_compute_at_edge_http_req_dynamic_backend_config_t;

typedef fastly_compute_at_edge_http_types_send_error_detail_t fastly_compute_at_edge_http_req_send_error_detail_t;

typedef uint8_t fastly_compute_at_edge_http_req_cache_override_tag_t;

// Do not cache the response to this request, regardless of the origin response's headers.
#define FASTLY_COMPUTE_AT_EDGE_HTTP_REQ_CACHE_OVERRIDE_TAG_PASS (1 << 0)
#define FASTLY_COMPUTE_AT_EDGE_HTTP_REQ_CACHE_OVERRIDE_TAG_TTL (1 << 1)
#define FASTLY_COMPUTE_AT_EDGE_HTTP_REQ_CACHE_OVERRIDE_TAG_STALE_WHILE_REVALIDATE (1 << 2)
#define FASTLY_COMPUTE_AT_EDGE_HTTP_REQ_CACHE_OVERRIDE_TAG_PCI (1 << 3)

typedef struct {
  fastly_world_string_t *ptr;
  size_t len;
} fastly_world_list_string_t;

typedef struct {
  bool is_some;
  fastly_world_list_u8_t val;
} fastly_world_option_list_u8_t;

typedef struct {
  fastly_world_list_u8_t *ptr;
  size_t len;
} fastly_world_list_list_u8_t;

typedef struct {
  bool is_some;
  fastly_world_list_list_u8_t val;
} fastly_world_option_list_list_u8_t;

typedef struct {
  bool is_some;
  fastly_compute_at_edge_http_req_response_t val;
} fastly_world_option_fastly_compute_at_edge_http_req_response_t;

typedef struct {
  fastly_compute_at_edge_http_req_pending_request_handle_t *ptr;
  size_t len;
} fastly_world_list_fastly_compute_at_edge_http_req_pending_request_handle_t;

typedef struct {
  uint32_t f0;
  fastly_compute_at_edge_http_req_response_t f1;
} fastly_world_tuple2_u32_fastly_compute_at_edge_http_req_response_t;

typedef fastly_compute_at_edge_types_error_t fastly_compute_at_edge_http_resp_error_t;

typedef fastly_compute_at_edge_http_types_response_handle_t fastly_compute_at_edge_http_resp_response_handle_t;

typedef fastly_compute_at_edge_http_types_body_handle_t fastly_compute_at_edge_http_resp_body_handle_t;

typedef fastly_compute_at_edge_http_types_http_version_t fastly_compute_at_edge_http_resp_http_version_t;

typedef fastly_compute_at_edge_http_types_http_status_t fastly_compute_at_edge_http_resp_http_status_t;

typedef fastly_compute_at_edge_http_types_framing_headers_mode_t fastly_compute_at_edge_http_resp_framing_headers_mode_t;

typedef uint8_t fastly_compute_at_edge_http_resp_keepalive_mode_t;

#define FASTLY_COMPUTE_AT_EDGE_HTTP_RESP_KEEPALIVE_MODE_AUTOMATIC 0
#define FASTLY_COMPUTE_AT_EDGE_HTTP_RESP_KEEPALIVE_MODE_NO_KEEPALIVE 1

typedef fastly_compute_at_edge_types_error_t fastly_compute_at_edge_dictionary_error_t;

typedef uint32_t fastly_compute_at_edge_dictionary_handle_t;

typedef fastly_compute_at_edge_types_error_t fastly_compute_at_edge_geo_error_t;

typedef struct {
  bool is_some;
  float val;
} fastly_world_option_float32_t;

typedef struct {
  // * The name of the organization associated with as_number.
  //     *
  //     * For example, fastly is the value given for IP addresses under AS-54113.
  fastly_world_option_string_t as_name;
  // * [Autonomous system](https://en.wikipedia.org/wiki/Autonomous_system_(Internet)) (AS) number.
  fastly_world_option_u32_t as_number;
  // * The telephone area code associated with an IP address.
  //     *
  //     * These are only available for IP addresses in the United States, its territories, and Canada.
  fastly_world_option_u32_t area_code;
  // * City or town name.
  fastly_world_option_string_t city;
  // * Connection speed.
  fastly_world_option_string_t conn_speed;
  // * Connection type.
  fastly_world_option_string_t conn_type;
  // * Continent.
  fastly_world_option_string_t continent;
  // * A two-character [ISO 3166-1](https://en.wikipedia.org/wiki/ISO_3166-1) country code for the country associated with an IP address.
  //     *
  //     * The US country code is returned for IP addresses associated with overseas United States military bases.
  //     *
  //     * These values include subdivisions that are assigned their own country codes in ISO 3166-1. For example, subdivisions NO-21 and NO-22 are presented with the country code SJ for Svalbard and the Jan Mayen Islands.
  fastly_world_option_string_t country_code;
  // * A three-character [ISO 3166-1 alpha-3](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3) country code for the country associated with the IP address.
  //     *
  //     * The USA country code is returned for IP addresses associated with overseas United States military bases.
  fastly_world_option_string_t country_code3;
  // * Country name.
  //     *
  //     * This field is the [ISO 3166-1](https://en.wikipedia.org/wiki/ISO_3166-1) English short name for a country.
  fastly_world_option_string_t country_name;
  // * Time zone offset from Greenwich Mean Time (GMT) for `city`.
  fastly_world_option_string_t gmt_offset;
  // * Latitude, in units of degrees from the equator.
  //     *
  //     * Values range from -90.0 to +90.0 inclusive, and are based on the [WGS 84](https://en.wikipedia.org/wiki/World_Geodetic_System) coordinate reference system.
  fastly_world_option_float32_t latitude;
  // * Longitude, in units of degrees from the [IERS Reference Meridian](https://en.wikipedia.org/wiki/IERS_Reference_Meridian).
  //     *
  //     * Values range from -180.0 to +180.0 inclusive, and are based on the [WGS 84](https://en.wikipedia.org/wiki/World_Geodetic_System) coordinate reference system.
  fastly_world_option_float32_t longitude;
  // * Metro code, representing designated market areas (DMAs) in the United States.
  fastly_world_option_u32_t metro_code;
  // * The postal code associated with the IP address.
  //     *
  //     * These are available for some IP addresses in Australia, Canada, France, Germany, Italy, Spain, Switzerland, the United Kingdom, and the United States.
  //     *
  //     * For Canadian postal codes, this is the first 3 characters. For the United Kingdom, this is the first 2-4 characters (outward code). For countries with alphanumeric postal codes, this field is a lowercase transliteration.
  fastly_world_option_string_t postal_code;
  // * Client proxy description.
  fastly_world_option_string_t proxy_description;
  // * Client proxy type.
  fastly_world_option_string_t proxy_type;
  // * [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2) country subdivision code.
  //     *
  //     * For countries with multiple levels of subdivision (for example, nations within the United Kingdom), this variable gives the more specific subdivision.
  //     *
  //     * This field can be None for countries that do not have ISO country subdivision codes. For example, None is given for IP addresses assigned to the Ã…land Islands (country code AX, illustrated below).
  fastly_world_option_string_t region;
  // * Time zone offset from coordinated universal time (UTC) for `city`.
  fastly_world_option_u32_t utc_offset;
} fastly_compute_at_edge_geo_geo_data_t;

typedef fastly_compute_at_edge_types_error_t fastly_compute_at_edge_object_store_error_t;

typedef fastly_compute_at_edge_http_types_body_handle_t fastly_compute_at_edge_object_store_body_handle_t;

typedef uint32_t fastly_compute_at_edge_object_store_handle_t;

typedef uint32_t fastly_compute_at_edge_object_store_pending_handle_t;

typedef struct {
  bool is_some;
  fastly_compute_at_edge_object_store_body_handle_t val;
} fastly_world_option_fastly_compute_at_edge_object_store_body_handle_t;

typedef fastly_compute_at_edge_types_error_t fastly_compute_at_edge_secret_store_error_t;

typedef fastly_compute_at_edge_types_secret_handle_t fastly_compute_at_edge_secret_store_secret_handle_t;

typedef uint32_t fastly_compute_at_edge_secret_store_store_handle_t;

typedef struct {
  bool is_some;
  fastly_compute_at_edge_secret_store_secret_handle_t val;
} fastly_world_option_fastly_compute_at_edge_secret_store_secret_handle_t;

typedef fastly_compute_at_edge_types_error_t fastly_compute_at_edge_backend_error_t;

typedef fastly_compute_at_edge_http_types_tls_version_t fastly_compute_at_edge_backend_tls_version_t;

typedef uint8_t fastly_compute_at_edge_backend_backend_health_t;

#define FASTLY_COMPUTE_AT_EDGE_BACKEND_BACKEND_HEALTH_UNKNOWN 0
#define FASTLY_COMPUTE_AT_EDGE_BACKEND_BACKEND_HEALTH_HEALTHY 1
#define FASTLY_COMPUTE_AT_EDGE_BACKEND_BACKEND_HEALTH_UNHEALTHY 2

typedef fastly_compute_at_edge_types_error_t fastly_compute_at_edge_async_io_error_t;

// A handle to an object supporting generic async operations.
// Can be either a `BodyHandle` or a `PendingRequestHandle`.
// 
// Each async item has an associated I/O action:
// 
// * Pending requests: awaiting the response headers / `Response` object
// * Normal bodies: reading bytes from the body
// * Streaming bodies: writing bytes to the body
// 
// For writing bytes, note that there is a large host-side buffer that bytes can eagerly be written
// into, even before the origin itself consumes that data.
typedef uint32_t fastly_compute_at_edge_async_io_handle_t;

typedef struct {
  fastly_compute_at_edge_async_io_handle_t *ptr;
  size_t len;
} fastly_world_list_fastly_compute_at_edge_async_io_handle_t;

typedef fastly_compute_at_edge_types_error_t fastly_compute_at_edge_purge_error_t;

typedef uint8_t fastly_compute_at_edge_purge_options_mask_t;

#define FASTLY_COMPUTE_AT_EDGE_PURGE_OPTIONS_MASK_SOFT_PURGE (1 << 0)
#define FASTLY_COMPUTE_AT_EDGE_PURGE_OPTIONS_MASK_RET_BUF (1 << 1)

typedef fastly_compute_at_edge_types_error_t fastly_compute_at_edge_cache_error_t;

typedef fastly_compute_at_edge_http_types_body_handle_t fastly_compute_at_edge_cache_body_handle_t;

typedef fastly_compute_at_edge_http_types_request_handle_t fastly_compute_at_edge_cache_request_handle_t;

// The outcome of a cache lookup (either bare or as part of a cache transaction)
typedef uint32_t fastly_compute_at_edge_cache_handle_t;

typedef uint64_t fastly_compute_at_edge_cache_object_length_t;

typedef uint64_t fastly_compute_at_edge_cache_duration_ns_t;

typedef uint64_t fastly_compute_at_edge_cache_cache_hit_count_t;

typedef struct {
  bool is_some;
  fastly_compute_at_edge_cache_request_handle_t val;
} fastly_world_option_fastly_compute_at_edge_cache_request_handle_t;

// Extensible options for cache lookup operations currently used for both `lookup` and `transaction_lookup`.
typedef struct {
  // * A full request handle, but used only for its headers
  fastly_world_option_fastly_compute_at_edge_cache_request_handle_t request_headers;
} fastly_compute_at_edge_cache_lookup_options_t;

// Configuration for several hostcalls that write to the cache:
// - `insert`
// - `transaction-insert`
// - `transaction-insert-and-stream-back`
// - `transaction-update`
// 
// Some options are only allowed for certain of these hostcalls see `cache-write-options-mask`.
typedef struct {
  // this is a required field there's no flag for it
  fastly_compute_at_edge_cache_duration_ns_t max_age_ns;
  // a full request handle, but used only for its headers
  fastly_compute_at_edge_cache_request_handle_t request_headers;
  // a list of header names separated by spaces
  fastly_world_string_t vary_rule;
  // The initial age of the object in nanoseconds (default: 0).
  // 
  // This age is used to determine the freshness lifetime of the object as well as to
  // prioritize which variant to return if a subsequent lookup matches more than one vary rule
  fastly_compute_at_edge_cache_duration_ns_t initial_age_ns;
  fastly_compute_at_edge_cache_duration_ns_t stale_while_revalidate_ns;
  // a list of surrogate keys separated by spaces
  fastly_world_string_t surrogate_keys;
  fastly_compute_at_edge_cache_object_length_t length;
  fastly_world_list_u8_t user_metadata;
  bool sensitive_data;
} fastly_compute_at_edge_cache_write_options_t;

typedef uint8_t fastly_compute_at_edge_cache_get_body_options_mask_t;

#define FASTLY_COMPUTE_AT_EDGE_CACHE_GET_BODY_OPTIONS_MASK_RESERVED (1 << 0)
#define FASTLY_COMPUTE_AT_EDGE_CACHE_GET_BODY_OPTIONS_MASK_START (1 << 1)
#define FASTLY_COMPUTE_AT_EDGE_CACHE_GET_BODY_OPTIONS_MASK_END (1 << 2)

typedef struct {
  uint64_t start;
  uint64_t end;
} fastly_compute_at_edge_cache_get_body_options_t;

// The status of this lookup (and potential transaction)
typedef uint8_t fastly_compute_at_edge_cache_lookup_state_t;

// a cached object was found
#define FASTLY_COMPUTE_AT_EDGE_CACHE_LOOKUP_STATE_FOUND (1 << 0)
// the cached object is valid to use (implies found)
#define FASTLY_COMPUTE_AT_EDGE_CACHE_LOOKUP_STATE_USABLE (1 << 1)
// the cached object is stale (but may or may not be valid to use)
#define FASTLY_COMPUTE_AT_EDGE_CACHE_LOOKUP_STATE_STALE (1 << 2)
// this client is requested to insert or revalidate an object
#define FASTLY_COMPUTE_AT_EDGE_CACHE_LOOKUP_STATE_MUST_INSERT_OR_UPDATE (1 << 3)

typedef struct {
  fastly_compute_at_edge_cache_body_handle_t f0;
  fastly_compute_at_edge_cache_handle_t f1;
} fastly_world_tuple2_fastly_compute_at_edge_cache_body_handle_fastly_compute_at_edge_cache_handle_t;

typedef fastly_compute_at_edge_types_error_t fastly_compute_at_edge_edge_rate_limiter_error_t;

typedef fastly_compute_at_edge_types_error_t fastly_compute_at_edge_device_detection_error_t;

typedef fastly_compute_at_edge_http_types_request_t fastly_compute_at_edge_reactor_request_t;

// Imported Functions from `fastly:compute-at-edge/async-io`
// Blocks until one of the given objects is ready for I/O, or the optional timeout expires.
// 
// Valid object handles includes bodies and pending requests. See the `async_item_handle`
// definition for more details, including what I/O actions are associated with each handle
// type.
// 
// The timeout is specified in milliseconds, or 0 if no timeout is desired.
// 
// Returns the _index_ (not handle!) of the first object that is ready, or
// none if the timeout expires before any objects are ready for I/O.
bool fastly_compute_at_edge_async_io_select(fastly_world_list_fastly_compute_at_edge_async_io_handle_t *hs, uint32_t timeout_ms, fastly_world_option_u32_t *ret, fastly_compute_at_edge_async_io_error_t *err);
// Returns 1 if the given async item is "ready" for its associated I/O action, 0 otherwise.
// 
// If an object is ready, the I/O action is guaranteed to complete without blocking.
// 
// Valid object handles includes bodies and pending requests. See the `async_item_handle`
// definition for more details, including what I/O actions are associated with each handle
// type.
bool fastly_compute_at_edge_async_io_is_ready(fastly_compute_at_edge_async_io_handle_t handle, bool *ret, fastly_compute_at_edge_async_io_error_t *err);

// Imported Functions from `fastly:compute-at-edge/backend`
bool fastly_compute_at_edge_backend_exists(fastly_world_string_t *backend, bool *ret, fastly_compute_at_edge_backend_error_t *err);
bool fastly_compute_at_edge_backend_is_healthy(fastly_world_string_t *backend, fastly_compute_at_edge_backend_backend_health_t *ret, fastly_compute_at_edge_backend_error_t *err);
// Returns `true` if the backend is a "dynamic" backend.
bool fastly_compute_at_edge_backend_is_dynamic(fastly_world_string_t *backend, bool *ret, fastly_compute_at_edge_backend_error_t *err);
// Get the host of this backend.
bool fastly_compute_at_edge_backend_get_host(fastly_world_string_t *backend, fastly_world_string_t *ret, fastly_compute_at_edge_backend_error_t *err);
// Get the "override host" for this backend.
// 
// This is used to change the `Host` header sent to the backend. See the
// Fastly documentation oh this topic here: https://docs.fastly.com/en/guides/specifying-an-override-host
bool fastly_compute_at_edge_backend_get_override_host(fastly_world_string_t *backend, fastly_world_option_string_t *ret, fastly_compute_at_edge_backend_error_t *err);
// Get the remote TCP port of the backend connection for the request.
bool fastly_compute_at_edge_backend_get_port(fastly_world_string_t *backend, uint16_t *ret, fastly_compute_at_edge_backend_error_t *err);
// Get the connection timeout of the backend.
bool fastly_compute_at_edge_backend_get_connect_timeout_ms(fastly_world_string_t *backend, uint32_t *ret, fastly_compute_at_edge_backend_error_t *err);
// Get the first byte timeout of the backend.
bool fastly_compute_at_edge_backend_get_first_byte_timeout_ms(fastly_world_string_t *backend, uint32_t *ret, fastly_compute_at_edge_backend_error_t *err);
// Get the between byte timeout of the backend.
bool fastly_compute_at_edge_backend_get_between_bytes_timeout_ms(fastly_world_string_t *backend, uint32_t *ret, fastly_compute_at_edge_backend_error_t *err);
// Returns `true` if the backend is configured to use SSL.
bool fastly_compute_at_edge_backend_is_ssl(fastly_world_string_t *backend, bool *ret, fastly_compute_at_edge_backend_error_t *err);
// Get the minimum SSL version this backend will use.
bool fastly_compute_at_edge_backend_get_ssl_min_version(fastly_world_string_t *backend, fastly_compute_at_edge_backend_tls_version_t *ret, fastly_compute_at_edge_backend_error_t *err);
// Get the maximum SSL version this backend will use.
bool fastly_compute_at_edge_backend_get_ssl_max_version(fastly_world_string_t *backend, fastly_compute_at_edge_backend_tls_version_t *ret, fastly_compute_at_edge_backend_error_t *err);

// Imported Functions from `fastly:compute-at-edge/cache`
// Performs a non-request-collapsing cache lookup.
// 
// Returns a result without waiting for any request collapsing that may be ongoing.
bool fastly_compute_at_edge_cache_lookup(fastly_world_string_t *key, fastly_compute_at_edge_cache_lookup_options_t *options, fastly_compute_at_edge_cache_handle_t *ret, fastly_compute_at_edge_cache_error_t *err);
// Performs a non-request-collapsing cache insertion (or update).
// 
// The returned handle is to a streaming body that is used for writing the object into
// the cache.
bool fastly_compute_at_edge_cache_insert(fastly_world_string_t *key, fastly_compute_at_edge_cache_write_options_t *options, fastly_compute_at_edge_cache_body_handle_t *ret, fastly_compute_at_edge_cache_error_t *err);
// The entrypoint to the request-collapsing cache transaction API.
// 
// This operation always participates in request collapsing and may return stale objects. To bypass
// request collapsing, use `lookup` and `insert` instead.
bool fastly_compute_at_edge_cache_transaction_lookup(fastly_world_string_t *key, fastly_compute_at_edge_cache_lookup_options_t *options, fastly_compute_at_edge_cache_handle_t *ret, fastly_compute_at_edge_cache_error_t *err);
// Insert an object into the cache with the given metadata.
// 
// Can only be used in if the cache handle state includes the `must-insert-or-update` flag.
// 
// The returned handle is to a streaming body that is used for writing the object into
// the cache.
bool fastly_compute_at_edge_cache_transaction_insert(fastly_compute_at_edge_cache_handle_t handle, fastly_compute_at_edge_cache_write_options_t *options, fastly_compute_at_edge_cache_body_handle_t *ret, fastly_compute_at_edge_cache_error_t *err);
// Insert an object into the cache with the given metadata, and return a readable stream of the
// bytes as they are stored.
// 
// This helps avoid the "slow reader" problem on a teed stream, for example when a program wishes
// to store a backend request in the cache while simultaneously streaming to a client in an HTTP
// response.
// 
// The returned body handle is to a streaming body that is used for writing the object _into_
// the cache. The returned cache handle provides a separate transaction for reading out the
// newly cached object to send elsewhere.
bool fastly_compute_at_edge_cache_transaction_insert_and_stream_back(fastly_compute_at_edge_cache_handle_t handle, fastly_compute_at_edge_cache_write_options_t *options, fastly_world_tuple2_fastly_compute_at_edge_cache_body_handle_fastly_compute_at_edge_cache_handle_t *ret, fastly_compute_at_edge_cache_error_t *err);
// Update the metadata of an object in the cache without changing its data.
// 
// Can only be used in if the cache handle state includes both of the flags:
// - `found`
// - `must-insert-or-update`
bool fastly_compute_at_edge_cache_transaction_update(fastly_compute_at_edge_cache_handle_t handle, fastly_compute_at_edge_cache_write_options_t *options, fastly_compute_at_edge_cache_error_t *err);
// Cancel an obligation to provide an object to the cache.
// 
// Useful if there is an error before streaming is possible, e.g. if a backend is unreachable.
bool fastly_compute_at_edge_cache_transaction_cancel(fastly_compute_at_edge_cache_handle_t handle, fastly_compute_at_edge_cache_error_t *err);
// Close an ongoing interaction with the cache.
// 
// If the cache handle state includes the `$must_insert_or_update` (and hence no insert or
// update has been performed), closing the handle cancels any request collapsing, potentially
// choosing a new waiter to perform the insertion/update.
bool fastly_compute_at_edge_cache_close(fastly_compute_at_edge_cache_handle_t handle, fastly_compute_at_edge_cache_error_t *err);
bool fastly_compute_at_edge_cache_get_state(fastly_compute_at_edge_cache_handle_t handle, fastly_compute_at_edge_cache_lookup_state_t *ret, fastly_compute_at_edge_cache_error_t *err);
// Gets the user metadata of the found object, returning `none` if there
// was no found object.
bool fastly_compute_at_edge_cache_get_user_metadata(fastly_compute_at_edge_cache_handle_t handle, fastly_world_list_u8_t *ret, fastly_compute_at_edge_cache_error_t *err);
// Gets a range of the found object body, returning the `optional-none` error if there
// was no found object.
// 
// The returned `body_handle` must be closed before calling this function again on the same
// `cache_handle`.
// 
// Note: until the CacheD protocol is adjusted to fully support this functionality,
// the body of objects that are past the stale-while-revalidate period will not
// be available, even when other metadata is.
bool fastly_compute_at_edge_cache_get_body(fastly_compute_at_edge_cache_handle_t handle, fastly_compute_at_edge_cache_get_body_options_t *options, fastly_compute_at_edge_cache_get_body_options_mask_t options_mask, fastly_compute_at_edge_cache_body_handle_t *ret, fastly_compute_at_edge_cache_error_t *err);
// Gets the content length of the found object, returning the `$none` error if there
// was no found object, or no content length was provided.
bool fastly_compute_at_edge_cache_get_length(fastly_compute_at_edge_cache_handle_t handle, uint64_t *ret, fastly_compute_at_edge_cache_error_t *err);
// Gets the configured max age of the found object, returning the `$none` error if there
// was no found object.
bool fastly_compute_at_edge_cache_get_max_age_ns(fastly_compute_at_edge_cache_handle_t handle, uint64_t *ret, fastly_compute_at_edge_cache_error_t *err);
// Gets the configured stale-while-revalidate period of the found object, returning the
// `$none` error if there was no found object.
bool fastly_compute_at_edge_cache_get_stale_while_revalidate_ns(fastly_compute_at_edge_cache_handle_t handle, uint64_t *ret, fastly_compute_at_edge_cache_error_t *err);
// Gets the age of the found object, returning the `$none` error if there
// was no found object.
bool fastly_compute_at_edge_cache_get_age_ns(fastly_compute_at_edge_cache_handle_t handle, uint64_t *ret, fastly_compute_at_edge_cache_error_t *err);
// Gets the number of cache hits for the found object, returning the `$none` error if there
// was no found object.
bool fastly_compute_at_edge_cache_get_hits(fastly_compute_at_edge_cache_handle_t handle, uint64_t *ret, fastly_compute_at_edge_cache_error_t *err);

// Imported Functions from `fastly:compute-at-edge/device-detection`
bool fastly_compute_at_edge_device_detection_lookup(fastly_world_string_t *user_agent, fastly_world_string_t *ret, fastly_compute_at_edge_device_detection_error_t *err);

// Imported Functions from `fastly:compute-at-edge/dictionary`
bool fastly_compute_at_edge_dictionary_open(fastly_world_string_t *name, fastly_compute_at_edge_dictionary_handle_t *ret, fastly_compute_at_edge_dictionary_error_t *err);
bool fastly_compute_at_edge_dictionary_get(fastly_compute_at_edge_dictionary_handle_t h, fastly_world_string_t *key, fastly_world_option_string_t *ret, fastly_compute_at_edge_dictionary_error_t *err);

// Imported Functions from `fastly:compute-at-edge/edge-rate-limiter`
bool fastly_compute_at_edge_edge_rate_limiter_check_rate(fastly_world_string_t *rate_counter_name, fastly_world_string_t *entry, uint32_t delta, uint32_t window, uint32_t limit, fastly_world_string_t *penalty_box_name, uint32_t time_to_live, bool *ret, fastly_compute_at_edge_edge_rate_limiter_error_t *err);
bool fastly_compute_at_edge_edge_rate_limiter_ratecounter_increment(fastly_world_string_t *rate_counter_name, fastly_world_string_t *entry, uint32_t delta, fastly_compute_at_edge_edge_rate_limiter_error_t *err);
bool fastly_compute_at_edge_edge_rate_limiter_ratecounter_lookup_rate(fastly_world_string_t *rate_counter_name, fastly_world_string_t *entry, uint32_t window, uint32_t *ret, fastly_compute_at_edge_edge_rate_limiter_error_t *err);
bool fastly_compute_at_edge_edge_rate_limiter_ratecounter_lookup_count(fastly_world_string_t *rate_counter_name, fastly_world_string_t *entry, uint32_t duration, uint32_t *ret, fastly_compute_at_edge_edge_rate_limiter_error_t *err);
bool fastly_compute_at_edge_edge_rate_limiter_penaltybox_add(fastly_world_string_t *penalty_box_name, fastly_world_string_t *entry, uint32_t time_to_live, fastly_compute_at_edge_edge_rate_limiter_error_t *err);
bool fastly_compute_at_edge_edge_rate_limiter_penaltybox_has(fastly_world_string_t *penalty_box_name, fastly_world_string_t *entry, bool *ret, fastly_compute_at_edge_edge_rate_limiter_error_t *err);

// Imported Functions from `fastly:compute-at-edge/geo`
// JSON string for now
bool fastly_compute_at_edge_geo_lookup(fastly_world_list_u8_t *addr_octets, fastly_world_string_t *ret, fastly_compute_at_edge_geo_error_t *err);

// Imported Functions from `fastly:compute-at-edge/http-body`
bool fastly_compute_at_edge_http_body_append(fastly_compute_at_edge_http_body_body_handle_t dest, fastly_compute_at_edge_http_body_body_handle_t src, fastly_compute_at_edge_http_body_error_t *err);
bool fastly_compute_at_edge_http_body_new(fastly_compute_at_edge_http_body_body_handle_t *ret, fastly_compute_at_edge_http_body_error_t *err);
bool fastly_compute_at_edge_http_body_read(fastly_compute_at_edge_http_body_body_handle_t h, uint32_t chunk_size, fastly_world_list_u8_t *ret, fastly_compute_at_edge_http_body_error_t *err);
bool fastly_compute_at_edge_http_body_write(fastly_compute_at_edge_http_body_body_handle_t h, fastly_world_list_u8_t *buf, fastly_compute_at_edge_http_body_write_end_t end, uint32_t *ret, fastly_compute_at_edge_http_body_error_t *err);
bool fastly_compute_at_edge_http_body_close(fastly_compute_at_edge_http_body_body_handle_t h, fastly_compute_at_edge_http_body_error_t *err);

// Imported Functions from `fastly:compute-at-edge/http-req`
bool fastly_compute_at_edge_http_req_cache_override_set(fastly_compute_at_edge_http_req_request_handle_t h, fastly_compute_at_edge_http_req_cache_override_tag_t tag, uint32_t *maybe_ttl, uint32_t *maybe_stale_while_revalidate, fastly_world_string_t *maybe_sk, fastly_compute_at_edge_http_req_error_t *err);
bool fastly_compute_at_edge_http_req_downstream_client_ip_addr(fastly_world_list_u8_t *ret, fastly_compute_at_edge_http_req_error_t *err);
bool fastly_compute_at_edge_http_req_downstream_client_request_id(fastly_world_string_t *ret, fastly_compute_at_edge_http_req_error_t *err);
bool fastly_compute_at_edge_http_req_downstream_client_h2_fingerprint(fastly_world_list_u8_t *ret, fastly_compute_at_edge_http_req_error_t *err);
bool fastly_compute_at_edge_http_req_downstream_tls_cipher_openssl_name(fastly_world_string_t *ret, fastly_compute_at_edge_http_req_error_t *err);
bool fastly_compute_at_edge_http_req_downstream_tls_protocol(fastly_world_string_t *ret, fastly_compute_at_edge_http_req_error_t *err);
bool fastly_compute_at_edge_http_req_downstream_tls_client_hello(fastly_world_list_u8_t *ret, fastly_compute_at_edge_http_req_error_t *err);
bool fastly_compute_at_edge_http_req_downstream_tls_raw_client_certificate(fastly_world_list_u8_t *ret, fastly_compute_at_edge_http_req_error_t *err);
bool fastly_compute_at_edge_http_req_downstream_tls_client_cert_verify_result(fastly_compute_at_edge_http_req_error_t *err);
bool fastly_compute_at_edge_http_req_downstream_tls_ja3_md5(fastly_world_list_u8_t *ret, fastly_compute_at_edge_http_req_error_t *err);
bool fastly_compute_at_edge_http_req_new(fastly_compute_at_edge_http_req_request_handle_t *ret, fastly_compute_at_edge_http_req_error_t *err);
bool fastly_compute_at_edge_http_req_header_names_get(fastly_compute_at_edge_http_req_request_handle_t h, fastly_world_list_string_t *ret, fastly_compute_at_edge_http_req_error_t *err);
bool fastly_compute_at_edge_http_req_original_header_names_get(fastly_world_list_string_t *ret, fastly_compute_at_edge_http_req_error_t *err);
bool fastly_compute_at_edge_http_req_original_header_count(uint32_t *ret, fastly_compute_at_edge_http_req_error_t *err);
bool fastly_compute_at_edge_http_req_header_value_get(fastly_compute_at_edge_http_req_request_handle_t h, fastly_world_string_t *name, fastly_world_option_list_u8_t *ret, fastly_compute_at_edge_http_req_error_t *err);
bool fastly_compute_at_edge_http_req_header_values_get(fastly_compute_at_edge_http_req_request_handle_t h, fastly_world_string_t *name, fastly_world_option_list_list_u8_t *ret, fastly_compute_at_edge_http_req_error_t *err);
bool fastly_compute_at_edge_http_req_header_values_set(fastly_compute_at_edge_http_req_request_handle_t h, fastly_world_string_t *name, fastly_world_list_list_u8_t *values, fastly_compute_at_edge_http_req_error_t *err);
bool fastly_compute_at_edge_http_req_header_insert(fastly_compute_at_edge_http_req_request_handle_t h, fastly_world_string_t *name, fastly_world_list_u8_t *value, fastly_compute_at_edge_http_req_error_t *err);
bool fastly_compute_at_edge_http_req_header_append(fastly_compute_at_edge_http_req_request_handle_t h, fastly_world_string_t *name, fastly_world_list_u8_t *value, fastly_compute_at_edge_http_req_error_t *err);
bool fastly_compute_at_edge_http_req_header_remove(fastly_compute_at_edge_http_req_request_handle_t h, fastly_world_string_t *name, fastly_compute_at_edge_http_req_error_t *err);
bool fastly_compute_at_edge_http_req_method_get(fastly_compute_at_edge_http_req_request_handle_t h, fastly_world_string_t *ret, fastly_compute_at_edge_http_req_error_t *err);
bool fastly_compute_at_edge_http_req_method_set(fastly_compute_at_edge_http_req_request_handle_t h, fastly_world_string_t *method, fastly_compute_at_edge_http_req_error_t *err);
bool fastly_compute_at_edge_http_req_uri_get(fastly_compute_at_edge_http_req_request_handle_t h, fastly_world_string_t *ret, fastly_compute_at_edge_http_req_error_t *err);
bool fastly_compute_at_edge_http_req_uri_set(fastly_compute_at_edge_http_req_request_handle_t h, fastly_world_string_t *uri, fastly_compute_at_edge_http_req_error_t *err);
bool fastly_compute_at_edge_http_req_version_get(fastly_compute_at_edge_http_req_request_handle_t h, fastly_compute_at_edge_http_req_http_version_t *ret, fastly_compute_at_edge_http_req_error_t *err);
bool fastly_compute_at_edge_http_req_version_set(fastly_compute_at_edge_http_req_request_handle_t h, fastly_compute_at_edge_http_req_http_version_t version, fastly_compute_at_edge_http_req_error_t *err);
bool fastly_compute_at_edge_http_req_send(fastly_compute_at_edge_http_req_request_handle_t h, fastly_compute_at_edge_http_req_body_handle_t b, fastly_world_string_t *backend, fastly_compute_at_edge_http_req_response_t *ret, fastly_compute_at_edge_http_req_error_t *err);
bool fastly_compute_at_edge_http_req_send_v2(fastly_compute_at_edge_http_req_request_handle_t h, fastly_compute_at_edge_http_req_send_error_detail_t *s, fastly_compute_at_edge_http_req_body_handle_t b, fastly_world_string_t *backend, fastly_compute_at_edge_http_req_response_t *ret, fastly_compute_at_edge_http_req_error_t *err);
bool fastly_compute_at_edge_http_req_send_async(fastly_compute_at_edge_http_req_request_handle_t h, fastly_compute_at_edge_http_req_body_handle_t b, fastly_world_string_t *backend, fastly_compute_at_edge_http_req_pending_request_handle_t *ret, fastly_compute_at_edge_http_req_error_t *err);
bool fastly_compute_at_edge_http_req_send_async_streaming(fastly_compute_at_edge_http_req_request_handle_t h, fastly_compute_at_edge_http_req_body_handle_t b, fastly_world_string_t *backend, fastly_compute_at_edge_http_req_pending_request_handle_t *ret, fastly_compute_at_edge_http_req_error_t *err);
bool fastly_compute_at_edge_http_req_pending_req_poll(fastly_compute_at_edge_http_req_pending_request_handle_t h, fastly_world_option_fastly_compute_at_edge_http_req_response_t *ret, fastly_compute_at_edge_http_req_error_t *err);
bool fastly_compute_at_edge_http_req_pending_req_poll_v2(fastly_compute_at_edge_http_req_pending_request_handle_t h, fastly_compute_at_edge_http_req_send_error_detail_t *s, fastly_world_option_fastly_compute_at_edge_http_req_response_t *ret, fastly_compute_at_edge_http_req_error_t *err);
bool fastly_compute_at_edge_http_req_pending_req_wait(fastly_compute_at_edge_http_req_pending_request_handle_t h, fastly_compute_at_edge_http_req_response_t *ret, fastly_compute_at_edge_http_req_error_t *err);
bool fastly_compute_at_edge_http_req_pending_req_wait_v2(fastly_compute_at_edge_http_req_pending_request_handle_t h, fastly_compute_at_edge_http_req_send_error_detail_t *s, fastly_compute_at_edge_http_req_response_t *ret, fastly_compute_at_edge_http_req_error_t *err);
bool fastly_compute_at_edge_http_req_pending_req_select(fastly_world_list_fastly_compute_at_edge_http_req_pending_request_handle_t *h, fastly_world_tuple2_u32_fastly_compute_at_edge_http_req_response_t *ret, fastly_compute_at_edge_http_req_error_t *err);
bool fastly_compute_at_edge_http_req_pending_req_select_v2(fastly_world_list_fastly_compute_at_edge_http_req_pending_request_handle_t *h, fastly_world_tuple2_u32_fastly_compute_at_edge_http_req_response_t *ret, fastly_compute_at_edge_http_req_send_error_detail_t *err);
bool fastly_compute_at_edge_http_req_close(fastly_compute_at_edge_http_req_request_handle_t h, fastly_compute_at_edge_http_req_error_t *err);
bool fastly_compute_at_edge_http_req_auto_decompress_response_set(fastly_compute_at_edge_http_req_request_handle_t h, fastly_compute_at_edge_http_req_content_encodings_t encodings, fastly_compute_at_edge_http_req_error_t *err);
bool fastly_compute_at_edge_http_req_upgrade_websocket(fastly_world_string_t *backend, fastly_compute_at_edge_http_req_error_t *err);
bool fastly_compute_at_edge_http_req_redirect_to_websocket_proxy(fastly_world_string_t *backend, fastly_compute_at_edge_http_req_error_t *err);
bool fastly_compute_at_edge_http_req_redirect_to_grip_proxy(fastly_world_string_t *backend, fastly_compute_at_edge_http_req_error_t *err);
bool fastly_compute_at_edge_http_req_framing_headers_mode_set(fastly_compute_at_edge_http_req_request_handle_t h, fastly_compute_at_edge_http_req_framing_headers_mode_t mode, fastly_compute_at_edge_http_req_error_t *err);
bool fastly_compute_at_edge_http_req_register_dynamic_backend(fastly_world_string_t *prefix, fastly_world_string_t *target, fastly_compute_at_edge_http_req_dynamic_backend_config_t *config, fastly_compute_at_edge_http_req_error_t *err);

// Imported Functions from `fastly:compute-at-edge/http-resp`
bool fastly_compute_at_edge_http_resp_new(fastly_compute_at_edge_http_resp_response_handle_t *ret, fastly_compute_at_edge_http_resp_error_t *err);
bool fastly_compute_at_edge_http_resp_header_names_get(fastly_compute_at_edge_http_resp_response_handle_t h, fastly_world_list_string_t *ret, fastly_compute_at_edge_http_resp_error_t *err);
bool fastly_compute_at_edge_http_resp_header_value_get(fastly_compute_at_edge_http_resp_response_handle_t h, fastly_world_string_t *name, fastly_world_option_string_t *ret, fastly_compute_at_edge_http_resp_error_t *err);
bool fastly_compute_at_edge_http_resp_header_values_get(fastly_compute_at_edge_http_resp_response_handle_t h, fastly_world_string_t *name, fastly_world_option_list_list_u8_t *ret, fastly_compute_at_edge_http_resp_error_t *err);
bool fastly_compute_at_edge_http_resp_header_values_set(fastly_compute_at_edge_http_resp_response_handle_t h, fastly_world_string_t *name, fastly_world_list_list_u8_t *values, fastly_compute_at_edge_http_resp_error_t *err);
bool fastly_compute_at_edge_http_resp_header_insert(fastly_compute_at_edge_http_resp_response_handle_t h, fastly_world_string_t *name, fastly_world_list_u8_t *value, fastly_compute_at_edge_http_resp_error_t *err);
bool fastly_compute_at_edge_http_resp_header_append(fastly_compute_at_edge_http_resp_response_handle_t h, fastly_world_string_t *name, fastly_world_list_u8_t *value, fastly_compute_at_edge_http_resp_error_t *err);
bool fastly_compute_at_edge_http_resp_header_remove(fastly_compute_at_edge_http_resp_response_handle_t h, fastly_world_string_t *name, fastly_compute_at_edge_http_resp_error_t *err);
bool fastly_compute_at_edge_http_resp_version_get(fastly_compute_at_edge_http_resp_response_handle_t h, fastly_compute_at_edge_http_resp_http_version_t *ret, fastly_compute_at_edge_http_resp_error_t *err);
bool fastly_compute_at_edge_http_resp_version_set(fastly_compute_at_edge_http_resp_response_handle_t h, fastly_compute_at_edge_http_resp_http_version_t version, fastly_compute_at_edge_http_resp_error_t *err);
bool fastly_compute_at_edge_http_resp_send_downstream(fastly_compute_at_edge_http_resp_response_handle_t h, fastly_compute_at_edge_http_resp_body_handle_t b, bool streaming, fastly_compute_at_edge_http_resp_error_t *err);
bool fastly_compute_at_edge_http_resp_status_get(fastly_compute_at_edge_http_resp_response_handle_t h, fastly_compute_at_edge_http_resp_http_status_t *ret, fastly_compute_at_edge_http_resp_error_t *err);
bool fastly_compute_at_edge_http_resp_status_set(fastly_compute_at_edge_http_resp_response_handle_t h, fastly_compute_at_edge_http_resp_http_status_t status, fastly_compute_at_edge_http_resp_error_t *err);
bool fastly_compute_at_edge_http_resp_close(fastly_compute_at_edge_http_resp_response_handle_t h, fastly_compute_at_edge_http_resp_error_t *err);
// Adjust how this response's framing headers are determined.
bool fastly_compute_at_edge_http_resp_framing_headers_mode_set(fastly_compute_at_edge_http_resp_response_handle_t h, fastly_compute_at_edge_http_resp_framing_headers_mode_t mode, fastly_compute_at_edge_http_resp_error_t *err);
bool fastly_compute_at_edge_http_resp_http_keepalive_mode_set(fastly_compute_at_edge_http_resp_response_handle_t h, fastly_compute_at_edge_http_resp_keepalive_mode_t mode, fastly_compute_at_edge_http_resp_error_t *err);

// Imported Functions from `fastly:compute-at-edge/log`
bool fastly_compute_at_edge_log_endpoint_get(fastly_world_string_t *name, fastly_compute_at_edge_log_handle_t *ret, fastly_compute_at_edge_log_error_t *err);
bool fastly_compute_at_edge_log_write(fastly_compute_at_edge_log_handle_t h, fastly_world_string_t *msg, fastly_compute_at_edge_log_error_t *err);

// Imported Functions from `fastly:compute-at-edge/object-store`
bool fastly_compute_at_edge_object_store_open(fastly_world_string_t *name, fastly_compute_at_edge_object_store_handle_t *ret, fastly_compute_at_edge_object_store_error_t *err);
bool fastly_compute_at_edge_object_store_lookup(fastly_compute_at_edge_object_store_handle_t store, fastly_world_string_t *key, fastly_world_option_fastly_compute_at_edge_object_store_body_handle_t *ret, fastly_compute_at_edge_object_store_error_t *err);
bool fastly_compute_at_edge_object_store_lookup_async(fastly_compute_at_edge_object_store_handle_t store, fastly_world_string_t *key, fastly_compute_at_edge_object_store_pending_handle_t *ret, fastly_compute_at_edge_object_store_error_t *err);
bool fastly_compute_at_edge_object_store_pending_lookup_wait(fastly_compute_at_edge_object_store_pending_handle_t handle, fastly_world_option_fastly_compute_at_edge_object_store_body_handle_t *ret, fastly_compute_at_edge_object_store_error_t *err);
bool fastly_compute_at_edge_object_store_delete_async(fastly_compute_at_edge_object_store_handle_t store, fastly_world_string_t *key, fastly_compute_at_edge_object_store_pending_handle_t *ret, fastly_compute_at_edge_object_store_error_t *err);
bool fastly_compute_at_edge_object_store_pending_delete_wait(fastly_compute_at_edge_object_store_pending_handle_t handle, fastly_compute_at_edge_object_store_error_t *err);
bool fastly_compute_at_edge_object_store_insert(fastly_compute_at_edge_object_store_handle_t store, fastly_world_string_t *key, fastly_compute_at_edge_object_store_body_handle_t body_handle, fastly_compute_at_edge_object_store_error_t *err);

// Imported Functions from `fastly:compute-at-edge/purge`
bool fastly_compute_at_edge_purge_surrogate_key(fastly_world_string_t *surrogate_keys, fastly_compute_at_edge_purge_options_mask_t purge_options, fastly_world_option_string_t *ret, fastly_compute_at_edge_purge_error_t *err);

// Imported Functions from `fastly:compute-at-edge/secret-store`
bool fastly_compute_at_edge_secret_store_open(fastly_world_string_t *name, fastly_compute_at_edge_secret_store_store_handle_t *ret, fastly_compute_at_edge_secret_store_error_t *err);
bool fastly_compute_at_edge_secret_store_get(fastly_compute_at_edge_secret_store_store_handle_t store, fastly_world_string_t *key, fastly_world_option_fastly_compute_at_edge_secret_store_secret_handle_t *ret, fastly_compute_at_edge_secret_store_error_t *err);
bool fastly_compute_at_edge_secret_store_plaintext(fastly_compute_at_edge_secret_store_secret_handle_t secret, fastly_world_option_string_t *ret, fastly_compute_at_edge_secret_store_error_t *err);
bool fastly_compute_at_edge_secret_store_from_bytes(fastly_world_string_t *bytes, fastly_compute_at_edge_secret_store_secret_handle_t *ret, fastly_compute_at_edge_secret_store_error_t *err);

// Imported Functions from `fastly:compute-at-edge/uap`
bool fastly_compute_at_edge_uap_parse(fastly_world_string_t *user_agent, fastly_compute_at_edge_uap_user_agent_t *ret, fastly_compute_at_edge_uap_error_t *err);

// Exported Functions from `fastly:compute-at-edge/reactor`
bool exports_fastly_compute_at_edge_reactor_serve(fastly_compute_at_edge_reactor_request_t *req);

#ifdef __cplusplus
}
#endif
#endif
