// Generated by `wit-bindgen` 0.16.0. DO NOT EDIT!
#ifndef __BINDINGS_BINDINGS_H
#define __BINDINGS_BINDINGS_H
#ifdef __cplusplus
extern "C" {
#endif

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
  uint8_t *ptr;
  size_t len;
} bindings_string_t;

typedef struct {
  bindings_string_t f0;
  bindings_string_t f1;
} wasi_cli_0_2_0_environment_tuple2_string_string_t;

typedef struct {
  wasi_cli_0_2_0_environment_tuple2_string_string_t *ptr;
  size_t len;
} wasi_cli_0_2_0_environment_list_tuple2_string_string_t;

typedef struct {
  bindings_string_t *ptr;
  size_t len;
} wasi_cli_0_2_0_environment_list_string_t;

typedef struct {
  bool is_some;
  bindings_string_t val;
} wasi_cli_0_2_0_environment_option_string_t;

typedef struct {
  bool is_err;
} wasi_cli_0_2_0_exit_result_void_void_t;

typedef struct wasi_io_0_2_0_error_own_error_t {
  int32_t __handle;
} wasi_io_0_2_0_error_own_error_t;

typedef struct wasi_io_0_2_0_error_borrow_error_t {
  int32_t __handle;
} wasi_io_0_2_0_error_borrow_error_t;

typedef struct wasi_io_0_2_0_poll_own_pollable_t {
  int32_t __handle;
} wasi_io_0_2_0_poll_own_pollable_t;

typedef struct wasi_io_0_2_0_poll_borrow_pollable_t {
  int32_t __handle;
} wasi_io_0_2_0_poll_borrow_pollable_t;

typedef struct {
  wasi_io_0_2_0_poll_borrow_pollable_t *ptr;
  size_t len;
} wasi_io_0_2_0_poll_list_borrow_pollable_t;

typedef struct {
  uint32_t *ptr;
  size_t len;
} wasi_io_0_2_0_poll_list_u32_t;

typedef wasi_io_0_2_0_error_own_error_t wasi_io_0_2_0_streams_own_error_t;

// An error for input-stream and output-stream operations.
typedef struct {
  uint8_t tag;
  union {
    wasi_io_0_2_0_streams_own_error_t last_operation_failed;
  } val;
} wasi_io_0_2_0_streams_stream_error_t;

// The last operation (a write or flush) failed before completion.
//
// More information is available in the `error` payload.
#define WASI_IO_0_2_0_STREAMS_STREAM_ERROR_LAST_OPERATION_FAILED 0
// The stream is closed: no more input will be accepted by the
// stream. A closed output-stream will return this error on all
// future operations.
#define WASI_IO_0_2_0_STREAMS_STREAM_ERROR_CLOSED 1

typedef struct wasi_io_0_2_0_streams_own_input_stream_t {
  int32_t __handle;
} wasi_io_0_2_0_streams_own_input_stream_t;

typedef struct wasi_io_0_2_0_streams_borrow_input_stream_t {
  int32_t __handle;
} wasi_io_0_2_0_streams_borrow_input_stream_t;

typedef struct wasi_io_0_2_0_streams_own_output_stream_t {
  int32_t __handle;
} wasi_io_0_2_0_streams_own_output_stream_t;

typedef struct wasi_io_0_2_0_streams_borrow_output_stream_t {
  int32_t __handle;
} wasi_io_0_2_0_streams_borrow_output_stream_t;

typedef struct {
  uint8_t *ptr;
  size_t len;
} wasi_io_0_2_0_streams_list_u8_t;

typedef struct {
  bool is_err;
  union {
    wasi_io_0_2_0_streams_list_u8_t ok;
    wasi_io_0_2_0_streams_stream_error_t err;
  } val;
} wasi_io_0_2_0_streams_result_list_u8_stream_error_t;

typedef struct {
  bool is_err;
  union {
    uint64_t ok;
    wasi_io_0_2_0_streams_stream_error_t err;
  } val;
} wasi_io_0_2_0_streams_result_u64_stream_error_t;

typedef wasi_io_0_2_0_poll_own_pollable_t wasi_io_0_2_0_streams_own_pollable_t;

typedef struct {
  bool is_err;
  union {
    wasi_io_0_2_0_streams_stream_error_t err;
  } val;
} wasi_io_0_2_0_streams_result_void_stream_error_t;

typedef wasi_io_0_2_0_streams_own_input_stream_t wasi_cli_0_2_0_stdin_own_input_stream_t;

typedef wasi_io_0_2_0_streams_own_output_stream_t wasi_cli_0_2_0_stdout_own_output_stream_t;

typedef wasi_io_0_2_0_streams_own_output_stream_t wasi_cli_0_2_0_stderr_own_output_stream_t;

typedef struct wasi_cli_0_2_0_terminal_input_own_terminal_input_t {
  int32_t __handle;
} wasi_cli_0_2_0_terminal_input_own_terminal_input_t;

typedef struct wasi_cli_0_2_0_terminal_input_borrow_terminal_input_t {
  int32_t __handle;
} wasi_cli_0_2_0_terminal_input_borrow_terminal_input_t;

typedef struct wasi_cli_0_2_0_terminal_output_own_terminal_output_t {
  int32_t __handle;
} wasi_cli_0_2_0_terminal_output_own_terminal_output_t;

typedef struct wasi_cli_0_2_0_terminal_output_borrow_terminal_output_t {
  int32_t __handle;
} wasi_cli_0_2_0_terminal_output_borrow_terminal_output_t;

typedef wasi_cli_0_2_0_terminal_input_own_terminal_input_t
    wasi_cli_0_2_0_terminal_stdin_own_terminal_input_t;

typedef struct {
  bool is_some;
  wasi_cli_0_2_0_terminal_stdin_own_terminal_input_t val;
} wasi_cli_0_2_0_terminal_stdin_option_own_terminal_input_t;

typedef wasi_cli_0_2_0_terminal_output_own_terminal_output_t
    wasi_cli_0_2_0_terminal_stdout_own_terminal_output_t;

typedef struct {
  bool is_some;
  wasi_cli_0_2_0_terminal_stdout_own_terminal_output_t val;
} wasi_cli_0_2_0_terminal_stdout_option_own_terminal_output_t;

typedef wasi_cli_0_2_0_terminal_output_own_terminal_output_t
    wasi_cli_0_2_0_terminal_stderr_own_terminal_output_t;

typedef struct {
  bool is_some;
  wasi_cli_0_2_0_terminal_stderr_own_terminal_output_t val;
} wasi_cli_0_2_0_terminal_stderr_option_own_terminal_output_t;

// An instant in time, in nanoseconds. An instant is relative to an
// unspecified initial value, and can only be compared to instances from
// the same monotonic-clock.
typedef uint64_t wasi_clocks_0_2_0_monotonic_clock_instant_t;

// A duration of time, in nanoseconds.
typedef uint64_t wasi_clocks_0_2_0_monotonic_clock_duration_t;

typedef wasi_io_0_2_0_poll_own_pollable_t wasi_clocks_0_2_0_monotonic_clock_own_pollable_t;

// A time and date in seconds plus nanoseconds.
typedef struct {
  uint64_t seconds;
  uint32_t nanoseconds;
} wasi_clocks_0_2_0_wall_clock_datetime_t;

typedef wasi_clocks_0_2_0_wall_clock_datetime_t wasi_filesystem_0_2_0_types_datetime_t;

// File size or length of a region within a file.
typedef uint64_t wasi_filesystem_0_2_0_types_filesize_t;

// The type of a filesystem object referenced by a descriptor.
//
// Note: This was called `filetype` in earlier versions of WASI.
typedef uint8_t wasi_filesystem_0_2_0_types_descriptor_type_t;

// The type of the descriptor or file is unknown or is different from
// any of the other types specified.
#define WASI_FILESYSTEM_0_2_0_TYPES_DESCRIPTOR_TYPE_UNKNOWN 0
// The descriptor refers to a block device inode.
#define WASI_FILESYSTEM_0_2_0_TYPES_DESCRIPTOR_TYPE_BLOCK_DEVICE 1
// The descriptor refers to a character device inode.
#define WASI_FILESYSTEM_0_2_0_TYPES_DESCRIPTOR_TYPE_CHARACTER_DEVICE 2
// The descriptor refers to a directory inode.
#define WASI_FILESYSTEM_0_2_0_TYPES_DESCRIPTOR_TYPE_DIRECTORY 3
// The descriptor refers to a named pipe.
#define WASI_FILESYSTEM_0_2_0_TYPES_DESCRIPTOR_TYPE_FIFO 4
// The file refers to a symbolic link inode.
#define WASI_FILESYSTEM_0_2_0_TYPES_DESCRIPTOR_TYPE_SYMBOLIC_LINK 5
// The descriptor refers to a regular file inode.
#define WASI_FILESYSTEM_0_2_0_TYPES_DESCRIPTOR_TYPE_REGULAR_FILE 6
// The descriptor refers to a socket.
#define WASI_FILESYSTEM_0_2_0_TYPES_DESCRIPTOR_TYPE_SOCKET 7

// Descriptor flags.
//
// Note: This was called `fdflags` in earlier versions of WASI.
typedef uint8_t wasi_filesystem_0_2_0_types_descriptor_flags_t;

// Read mode: Data can be read.
#define WASI_FILESYSTEM_0_2_0_TYPES_DESCRIPTOR_FLAGS_READ (1 << 0)
// Write mode: Data can be written to.
#define WASI_FILESYSTEM_0_2_0_TYPES_DESCRIPTOR_FLAGS_WRITE (1 << 1)
// Request that writes be performed according to synchronized I/O file
// integrity completion. The data stored in the file and the file's
// metadata are synchronized. This is similar to `O_SYNC` in POSIX.
//
// The precise semantics of this operation have not yet been defined for
// WASI. At this time, it should be interpreted as a request, and not a
// requirement.
#define WASI_FILESYSTEM_0_2_0_TYPES_DESCRIPTOR_FLAGS_FILE_INTEGRITY_SYNC (1 << 2)
// Request that writes be performed according to synchronized I/O data
// integrity completion. Only the data stored in the file is
// synchronized. This is similar to `O_DSYNC` in POSIX.
//
// The precise semantics of this operation have not yet been defined for
// WASI. At this time, it should be interpreted as a request, and not a
// requirement.
#define WASI_FILESYSTEM_0_2_0_TYPES_DESCRIPTOR_FLAGS_DATA_INTEGRITY_SYNC (1 << 3)
// Requests that reads be performed at the same level of integrety
// requested for writes. This is similar to `O_RSYNC` in POSIX.
//
// The precise semantics of this operation have not yet been defined for
// WASI. At this time, it should be interpreted as a request, and not a
// requirement.
#define WASI_FILESYSTEM_0_2_0_TYPES_DESCRIPTOR_FLAGS_REQUESTED_WRITE_SYNC (1 << 4)
// Mutating directories mode: Directory contents may be mutated.
//
// When this flag is unset on a descriptor, operations using the
// descriptor which would create, rename, delete, modify the data or
// metadata of filesystem objects, or obtain another handle which
// would permit any of those, shall fail with `error-code::read-only` if
// they would otherwise succeed.
//
// This may only be set on directories.
#define WASI_FILESYSTEM_0_2_0_TYPES_DESCRIPTOR_FLAGS_MUTATE_DIRECTORY (1 << 5)

// Flags determining the method of how paths are resolved.
typedef uint8_t wasi_filesystem_0_2_0_types_path_flags_t;

// As long as the resolved path corresponds to a symbolic link, it is
// expanded.
#define WASI_FILESYSTEM_0_2_0_TYPES_PATH_FLAGS_SYMLINK_FOLLOW (1 << 0)

// Open flags used by `open-at`.
typedef uint8_t wasi_filesystem_0_2_0_types_open_flags_t;

// Create file if it does not exist, similar to `O_CREAT` in POSIX.
#define WASI_FILESYSTEM_0_2_0_TYPES_OPEN_FLAGS_CREATE (1 << 0)
// Fail if not a directory, similar to `O_DIRECTORY` in POSIX.
#define WASI_FILESYSTEM_0_2_0_TYPES_OPEN_FLAGS_DIRECTORY (1 << 1)
// Fail if file already exists, similar to `O_EXCL` in POSIX.
#define WASI_FILESYSTEM_0_2_0_TYPES_OPEN_FLAGS_EXCLUSIVE (1 << 2)
// Truncate file to size 0, similar to `O_TRUNC` in POSIX.
#define WASI_FILESYSTEM_0_2_0_TYPES_OPEN_FLAGS_TRUNCATE (1 << 3)

// Number of hard links to an inode.
typedef uint64_t wasi_filesystem_0_2_0_types_link_count_t;

typedef struct {
  bool is_some;
  wasi_filesystem_0_2_0_types_datetime_t val;
} wasi_filesystem_0_2_0_types_option_datetime_t;

// File attributes.
//
// Note: This was called `filestat` in earlier versions of WASI.
typedef struct {
  // File type.
  wasi_filesystem_0_2_0_types_descriptor_type_t type;
  // Number of hard links to the file.
  wasi_filesystem_0_2_0_types_link_count_t link_count;
  // For regular files, the file size in bytes. For symbolic links, the
  // length in bytes of the pathname contained in the symbolic link.
  wasi_filesystem_0_2_0_types_filesize_t size;
  // Last data access timestamp.
  //
  // If the `option` is none, the platform doesn't maintain an access
  // timestamp for this file.
  wasi_filesystem_0_2_0_types_option_datetime_t data_access_timestamp;
  // Last data modification timestamp.
  //
  // If the `option` is none, the platform doesn't maintain a
  // modification timestamp for this file.
  wasi_filesystem_0_2_0_types_option_datetime_t data_modification_timestamp;
  // Last file status-change timestamp.
  //
  // If the `option` is none, the platform doesn't maintain a
  // status-change timestamp for this file.
  wasi_filesystem_0_2_0_types_option_datetime_t status_change_timestamp;
} wasi_filesystem_0_2_0_types_descriptor_stat_t;

// When setting a timestamp, this gives the value to set it to.
typedef struct {
  uint8_t tag;
  union {
    wasi_filesystem_0_2_0_types_datetime_t timestamp;
  } val;
} wasi_filesystem_0_2_0_types_new_timestamp_t;

// Leave the timestamp set to its previous value.
#define WASI_FILESYSTEM_0_2_0_TYPES_NEW_TIMESTAMP_NO_CHANGE 0
// Set the timestamp to the current time of the system clock associated
// with the filesystem.
#define WASI_FILESYSTEM_0_2_0_TYPES_NEW_TIMESTAMP_NOW 1
// Set the timestamp to the given value.
#define WASI_FILESYSTEM_0_2_0_TYPES_NEW_TIMESTAMP_TIMESTAMP 2

// A directory entry.
typedef struct {
  // The type of the file referred to by this directory entry.
  wasi_filesystem_0_2_0_types_descriptor_type_t type;
  // The name of the object.
  bindings_string_t name;
} wasi_filesystem_0_2_0_types_directory_entry_t;

// Error codes returned by functions, similar to `errno` in POSIX.
// Not all of these error codes are returned by the functions provided by this
// API; some are used in higher-level library layers, and others are provided
// merely for alignment with POSIX.
typedef uint8_t wasi_filesystem_0_2_0_types_error_code_t;

// Permission denied, similar to `EACCES` in POSIX.
#define WASI_FILESYSTEM_0_2_0_TYPES_ERROR_CODE_ACCESS 0
// Resource unavailable, or operation would block, similar to `EAGAIN` and `EWOULDBLOCK` in POSIX.
#define WASI_FILESYSTEM_0_2_0_TYPES_ERROR_CODE_WOULD_BLOCK 1
// Connection already in progress, similar to `EALREADY` in POSIX.
#define WASI_FILESYSTEM_0_2_0_TYPES_ERROR_CODE_ALREADY 2
// Bad descriptor, similar to `EBADF` in POSIX.
#define WASI_FILESYSTEM_0_2_0_TYPES_ERROR_CODE_BAD_DESCRIPTOR 3
// Device or resource busy, similar to `EBUSY` in POSIX.
#define WASI_FILESYSTEM_0_2_0_TYPES_ERROR_CODE_BUSY 4
// Resource deadlock would occur, similar to `EDEADLK` in POSIX.
#define WASI_FILESYSTEM_0_2_0_TYPES_ERROR_CODE_DEADLOCK 5
// Storage quota exceeded, similar to `EDQUOT` in POSIX.
#define WASI_FILESYSTEM_0_2_0_TYPES_ERROR_CODE_QUOTA 6
// File exists, similar to `EEXIST` in POSIX.
#define WASI_FILESYSTEM_0_2_0_TYPES_ERROR_CODE_EXIST 7
// File too large, similar to `EFBIG` in POSIX.
#define WASI_FILESYSTEM_0_2_0_TYPES_ERROR_CODE_FILE_TOO_LARGE 8
// Illegal byte sequence, similar to `EILSEQ` in POSIX.
#define WASI_FILESYSTEM_0_2_0_TYPES_ERROR_CODE_ILLEGAL_BYTE_SEQUENCE 9
// Operation in progress, similar to `EINPROGRESS` in POSIX.
#define WASI_FILESYSTEM_0_2_0_TYPES_ERROR_CODE_IN_PROGRESS 10
// Interrupted function, similar to `EINTR` in POSIX.
#define WASI_FILESYSTEM_0_2_0_TYPES_ERROR_CODE_INTERRUPTED 11
// Invalid argument, similar to `EINVAL` in POSIX.
#define WASI_FILESYSTEM_0_2_0_TYPES_ERROR_CODE_INVALID 12
// I/O error, similar to `EIO` in POSIX.
#define WASI_FILESYSTEM_0_2_0_TYPES_ERROR_CODE_IO 13
// Is a directory, similar to `EISDIR` in POSIX.
#define WASI_FILESYSTEM_0_2_0_TYPES_ERROR_CODE_IS_DIRECTORY 14
// Too many levels of symbolic links, similar to `ELOOP` in POSIX.
#define WASI_FILESYSTEM_0_2_0_TYPES_ERROR_CODE_LOOP 15
// Too many links, similar to `EMLINK` in POSIX.
#define WASI_FILESYSTEM_0_2_0_TYPES_ERROR_CODE_TOO_MANY_LINKS 16
// Message too large, similar to `EMSGSIZE` in POSIX.
#define WASI_FILESYSTEM_0_2_0_TYPES_ERROR_CODE_MESSAGE_SIZE 17
// Filename too long, similar to `ENAMETOOLONG` in POSIX.
#define WASI_FILESYSTEM_0_2_0_TYPES_ERROR_CODE_NAME_TOO_LONG 18
// No such device, similar to `ENODEV` in POSIX.
#define WASI_FILESYSTEM_0_2_0_TYPES_ERROR_CODE_NO_DEVICE 19
// No such file or directory, similar to `ENOENT` in POSIX.
#define WASI_FILESYSTEM_0_2_0_TYPES_ERROR_CODE_NO_ENTRY 20
// No locks available, similar to `ENOLCK` in POSIX.
#define WASI_FILESYSTEM_0_2_0_TYPES_ERROR_CODE_NO_LOCK 21
// Not enough space, similar to `ENOMEM` in POSIX.
#define WASI_FILESYSTEM_0_2_0_TYPES_ERROR_CODE_INSUFFICIENT_MEMORY 22
// No space left on device, similar to `ENOSPC` in POSIX.
#define WASI_FILESYSTEM_0_2_0_TYPES_ERROR_CODE_INSUFFICIENT_SPACE 23
// Not a directory or a symbolic link to a directory, similar to `ENOTDIR` in POSIX.
#define WASI_FILESYSTEM_0_2_0_TYPES_ERROR_CODE_NOT_DIRECTORY 24
// Directory not empty, similar to `ENOTEMPTY` in POSIX.
#define WASI_FILESYSTEM_0_2_0_TYPES_ERROR_CODE_NOT_EMPTY 25
// State not recoverable, similar to `ENOTRECOVERABLE` in POSIX.
#define WASI_FILESYSTEM_0_2_0_TYPES_ERROR_CODE_NOT_RECOVERABLE 26
// Not supported, similar to `ENOTSUP` and `ENOSYS` in POSIX.
#define WASI_FILESYSTEM_0_2_0_TYPES_ERROR_CODE_UNSUPPORTED 27
// Inappropriate I/O control operation, similar to `ENOTTY` in POSIX.
#define WASI_FILESYSTEM_0_2_0_TYPES_ERROR_CODE_NO_TTY 28
// No such device or address, similar to `ENXIO` in POSIX.
#define WASI_FILESYSTEM_0_2_0_TYPES_ERROR_CODE_NO_SUCH_DEVICE 29
// Value too large to be stored in data type, similar to `EOVERFLOW` in POSIX.
#define WASI_FILESYSTEM_0_2_0_TYPES_ERROR_CODE_OVERFLOW 30
// Operation not permitted, similar to `EPERM` in POSIX.
#define WASI_FILESYSTEM_0_2_0_TYPES_ERROR_CODE_NOT_PERMITTED 31
// Broken pipe, similar to `EPIPE` in POSIX.
#define WASI_FILESYSTEM_0_2_0_TYPES_ERROR_CODE_PIPE 32
// Read-only file system, similar to `EROFS` in POSIX.
#define WASI_FILESYSTEM_0_2_0_TYPES_ERROR_CODE_READ_ONLY 33
// Invalid seek, similar to `ESPIPE` in POSIX.
#define WASI_FILESYSTEM_0_2_0_TYPES_ERROR_CODE_INVALID_SEEK 34
// Text file busy, similar to `ETXTBSY` in POSIX.
#define WASI_FILESYSTEM_0_2_0_TYPES_ERROR_CODE_TEXT_FILE_BUSY 35
// Cross-device link, similar to `EXDEV` in POSIX.
#define WASI_FILESYSTEM_0_2_0_TYPES_ERROR_CODE_CROSS_DEVICE 36

// File or memory access pattern advisory information.
typedef uint8_t wasi_filesystem_0_2_0_types_advice_t;

// The application has no advice to give on its behavior with respect
// to the specified data.
#define WASI_FILESYSTEM_0_2_0_TYPES_ADVICE_NORMAL 0
// The application expects to access the specified data sequentially
// from lower offsets to higher offsets.
#define WASI_FILESYSTEM_0_2_0_TYPES_ADVICE_SEQUENTIAL 1
// The application expects to access the specified data in a random
// order.
#define WASI_FILESYSTEM_0_2_0_TYPES_ADVICE_RANDOM 2
// The application expects to access the specified data in the near
// future.
#define WASI_FILESYSTEM_0_2_0_TYPES_ADVICE_WILL_NEED 3
// The application expects that it will not access the specified data
// in the near future.
#define WASI_FILESYSTEM_0_2_0_TYPES_ADVICE_DONT_NEED 4
// The application expects to access the specified data once and then
// not reuse it thereafter.
#define WASI_FILESYSTEM_0_2_0_TYPES_ADVICE_NO_REUSE 5

// A 128-bit hash value, split into parts because wasm doesn't have a
// 128-bit integer type.
typedef struct {
  // 64 bits of a 128-bit hash value.
  uint64_t lower;
  // Another 64 bits of a 128-bit hash value.
  uint64_t upper;
} wasi_filesystem_0_2_0_types_metadata_hash_value_t;

typedef struct wasi_filesystem_0_2_0_types_own_descriptor_t {
  int32_t __handle;
} wasi_filesystem_0_2_0_types_own_descriptor_t;

typedef struct wasi_filesystem_0_2_0_types_borrow_descriptor_t {
  int32_t __handle;
} wasi_filesystem_0_2_0_types_borrow_descriptor_t;

typedef struct wasi_filesystem_0_2_0_types_own_directory_entry_stream_t {
  int32_t __handle;
} wasi_filesystem_0_2_0_types_own_directory_entry_stream_t;

typedef struct wasi_filesystem_0_2_0_types_borrow_directory_entry_stream_t {
  int32_t __handle;
} wasi_filesystem_0_2_0_types_borrow_directory_entry_stream_t;

typedef wasi_io_0_2_0_streams_own_input_stream_t wasi_filesystem_0_2_0_types_own_input_stream_t;

typedef struct {
  bool is_err;
  union {
    wasi_filesystem_0_2_0_types_own_input_stream_t ok;
    wasi_filesystem_0_2_0_types_error_code_t err;
  } val;
} wasi_filesystem_0_2_0_types_result_own_input_stream_error_code_t;

typedef wasi_io_0_2_0_streams_own_output_stream_t wasi_filesystem_0_2_0_types_own_output_stream_t;

typedef struct {
  bool is_err;
  union {
    wasi_filesystem_0_2_0_types_own_output_stream_t ok;
    wasi_filesystem_0_2_0_types_error_code_t err;
  } val;
} wasi_filesystem_0_2_0_types_result_own_output_stream_error_code_t;

typedef struct {
  bool is_err;
  union {
    wasi_filesystem_0_2_0_types_error_code_t err;
  } val;
} wasi_filesystem_0_2_0_types_result_void_error_code_t;

typedef struct {
  bool is_err;
  union {
    wasi_filesystem_0_2_0_types_descriptor_flags_t ok;
    wasi_filesystem_0_2_0_types_error_code_t err;
  } val;
} wasi_filesystem_0_2_0_types_result_descriptor_flags_error_code_t;

typedef struct {
  bool is_err;
  union {
    wasi_filesystem_0_2_0_types_descriptor_type_t ok;
    wasi_filesystem_0_2_0_types_error_code_t err;
  } val;
} wasi_filesystem_0_2_0_types_result_descriptor_type_error_code_t;

typedef struct {
  uint8_t *ptr;
  size_t len;
} wasi_filesystem_0_2_0_types_list_u8_t;

typedef struct {
  wasi_filesystem_0_2_0_types_list_u8_t f0;
  bool f1;
} wasi_filesystem_0_2_0_types_tuple2_list_u8_bool_t;

typedef struct {
  bool is_err;
  union {
    wasi_filesystem_0_2_0_types_tuple2_list_u8_bool_t ok;
    wasi_filesystem_0_2_0_types_error_code_t err;
  } val;
} wasi_filesystem_0_2_0_types_result_tuple2_list_u8_bool_error_code_t;

typedef struct {
  bool is_err;
  union {
    wasi_filesystem_0_2_0_types_filesize_t ok;
    wasi_filesystem_0_2_0_types_error_code_t err;
  } val;
} wasi_filesystem_0_2_0_types_result_filesize_error_code_t;

typedef struct {
  bool is_err;
  union {
    wasi_filesystem_0_2_0_types_own_directory_entry_stream_t ok;
    wasi_filesystem_0_2_0_types_error_code_t err;
  } val;
} wasi_filesystem_0_2_0_types_result_own_directory_entry_stream_error_code_t;

typedef struct {
  bool is_err;
  union {
    wasi_filesystem_0_2_0_types_descriptor_stat_t ok;
    wasi_filesystem_0_2_0_types_error_code_t err;
  } val;
} wasi_filesystem_0_2_0_types_result_descriptor_stat_error_code_t;

typedef struct {
  bool is_err;
  union {
    wasi_filesystem_0_2_0_types_own_descriptor_t ok;
    wasi_filesystem_0_2_0_types_error_code_t err;
  } val;
} wasi_filesystem_0_2_0_types_result_own_descriptor_error_code_t;

typedef struct {
  bool is_err;
  union {
    bindings_string_t ok;
    wasi_filesystem_0_2_0_types_error_code_t err;
  } val;
} wasi_filesystem_0_2_0_types_result_string_error_code_t;

typedef struct {
  bool is_err;
  union {
    wasi_filesystem_0_2_0_types_metadata_hash_value_t ok;
    wasi_filesystem_0_2_0_types_error_code_t err;
  } val;
} wasi_filesystem_0_2_0_types_result_metadata_hash_value_error_code_t;

typedef struct {
  bool is_some;
  wasi_filesystem_0_2_0_types_directory_entry_t val;
} wasi_filesystem_0_2_0_types_option_directory_entry_t;

typedef struct {
  bool is_err;
  union {
    wasi_filesystem_0_2_0_types_option_directory_entry_t ok;
    wasi_filesystem_0_2_0_types_error_code_t err;
  } val;
} wasi_filesystem_0_2_0_types_result_option_directory_entry_error_code_t;

typedef wasi_io_0_2_0_error_borrow_error_t wasi_filesystem_0_2_0_types_borrow_error_t;

typedef struct {
  bool is_some;
  wasi_filesystem_0_2_0_types_error_code_t val;
} wasi_filesystem_0_2_0_types_option_error_code_t;

typedef wasi_filesystem_0_2_0_types_own_descriptor_t
    wasi_filesystem_0_2_0_preopens_own_descriptor_t;

typedef struct {
  wasi_filesystem_0_2_0_preopens_own_descriptor_t f0;
  bindings_string_t f1;
} wasi_filesystem_0_2_0_preopens_tuple2_own_descriptor_string_t;

typedef struct {
  wasi_filesystem_0_2_0_preopens_tuple2_own_descriptor_string_t *ptr;
  size_t len;
} wasi_filesystem_0_2_0_preopens_list_tuple2_own_descriptor_string_t;

typedef struct wasi_sockets_0_2_0_network_own_network_t {
  int32_t __handle;
} wasi_sockets_0_2_0_network_own_network_t;

typedef struct wasi_sockets_0_2_0_network_borrow_network_t {
  int32_t __handle;
} wasi_sockets_0_2_0_network_borrow_network_t;

// Error codes.
//
// In theory, every API can return any error code.
// In practice, API's typically only return the errors documented per API
// combined with a couple of errors that are always possible:
// - `unknown`
// - `access-denied`
// - `not-supported`
// - `out-of-memory`
// - `concurrency-conflict`
//
// See each individual API for what the POSIX equivalents are. They sometimes differ per API.
typedef uint8_t wasi_sockets_0_2_0_network_error_code_t;

// ### GENERAL ERRORS ###
// Unknown error
#define WASI_SOCKETS_0_2_0_NETWORK_ERROR_CODE_UNKNOWN 0
// Access denied.
//
// POSIX equivalent: EACCES, EPERM
#define WASI_SOCKETS_0_2_0_NETWORK_ERROR_CODE_ACCESS_DENIED 1
// The operation is not supported.
//
// POSIX equivalent: EOPNOTSUPP
#define WASI_SOCKETS_0_2_0_NETWORK_ERROR_CODE_NOT_SUPPORTED 2
// One of the arguments is invalid.
//
// POSIX equivalent: EINVAL
#define WASI_SOCKETS_0_2_0_NETWORK_ERROR_CODE_INVALID_ARGUMENT 3
// Not enough memory to complete the operation.
//
// POSIX equivalent: ENOMEM, ENOBUFS, EAI_MEMORY
#define WASI_SOCKETS_0_2_0_NETWORK_ERROR_CODE_OUT_OF_MEMORY 4
// The operation timed out before it could finish completely.
#define WASI_SOCKETS_0_2_0_NETWORK_ERROR_CODE_TIMEOUT 5
// This operation is incompatible with another asynchronous operation that is already in progress.
//
// POSIX equivalent: EALREADY
#define WASI_SOCKETS_0_2_0_NETWORK_ERROR_CODE_CONCURRENCY_CONFLICT 6
// Trying to finish an asynchronous operation that:
// - has not been started yet, or:
// - was already finished by a previous `finish-*` call.
//
// Note: this is scheduled to be removed when `future`s are natively supported.
#define WASI_SOCKETS_0_2_0_NETWORK_ERROR_CODE_NOT_IN_PROGRESS 7
// The operation has been aborted because it could not be completed immediately.
//
// Note: this is scheduled to be removed when `future`s are natively supported.
#define WASI_SOCKETS_0_2_0_NETWORK_ERROR_CODE_WOULD_BLOCK 8
// ### TCP & UDP SOCKET ERRORS ###
// The operation is not valid in the socket's current state.
#define WASI_SOCKETS_0_2_0_NETWORK_ERROR_CODE_INVALID_STATE 9
// A new socket resource could not be created because of a system limit.
#define WASI_SOCKETS_0_2_0_NETWORK_ERROR_CODE_NEW_SOCKET_LIMIT 10
// A bind operation failed because the provided address is not an address that the `network` can
// bind to.
#define WASI_SOCKETS_0_2_0_NETWORK_ERROR_CODE_ADDRESS_NOT_BINDABLE 11
// A bind operation failed because the provided address is already in use or because there are no
// ephemeral ports available.
#define WASI_SOCKETS_0_2_0_NETWORK_ERROR_CODE_ADDRESS_IN_USE 12
// The remote address is not reachable
#define WASI_SOCKETS_0_2_0_NETWORK_ERROR_CODE_REMOTE_UNREACHABLE 13
// ### TCP SOCKET ERRORS ###
// The connection was forcefully rejected
#define WASI_SOCKETS_0_2_0_NETWORK_ERROR_CODE_CONNECTION_REFUSED 14
// The connection was reset.
#define WASI_SOCKETS_0_2_0_NETWORK_ERROR_CODE_CONNECTION_RESET 15
// A connection was aborted.
#define WASI_SOCKETS_0_2_0_NETWORK_ERROR_CODE_CONNECTION_ABORTED 16
// ### UDP SOCKET ERRORS ###
#define WASI_SOCKETS_0_2_0_NETWORK_ERROR_CODE_DATAGRAM_TOO_LARGE 17
// ### NAME LOOKUP ERRORS ###
// Name does not exist or has no suitable associated IP addresses.
#define WASI_SOCKETS_0_2_0_NETWORK_ERROR_CODE_NAME_UNRESOLVABLE 18
// A temporary failure in name resolution occurred.
#define WASI_SOCKETS_0_2_0_NETWORK_ERROR_CODE_TEMPORARY_RESOLVER_FAILURE 19
// A permanent failure in name resolution occurred.
#define WASI_SOCKETS_0_2_0_NETWORK_ERROR_CODE_PERMANENT_RESOLVER_FAILURE 20

typedef uint8_t wasi_sockets_0_2_0_network_ip_address_family_t;

// Similar to `AF_INET` in POSIX.
#define WASI_SOCKETS_0_2_0_NETWORK_IP_ADDRESS_FAMILY_IPV4 0
// Similar to `AF_INET6` in POSIX.
#define WASI_SOCKETS_0_2_0_NETWORK_IP_ADDRESS_FAMILY_IPV6 1

typedef struct {
  uint8_t f0;
  uint8_t f1;
  uint8_t f2;
  uint8_t f3;
} wasi_sockets_0_2_0_network_ipv4_address_t;

typedef struct {
  uint16_t f0;
  uint16_t f1;
  uint16_t f2;
  uint16_t f3;
  uint16_t f4;
  uint16_t f5;
  uint16_t f6;
  uint16_t f7;
} wasi_sockets_0_2_0_network_ipv6_address_t;

typedef struct {
  uint8_t tag;
  union {
    wasi_sockets_0_2_0_network_ipv4_address_t ipv4;
    wasi_sockets_0_2_0_network_ipv6_address_t ipv6;
  } val;
} wasi_sockets_0_2_0_network_ip_address_t;

#define WASI_SOCKETS_0_2_0_NETWORK_IP_ADDRESS_IPV4 0
#define WASI_SOCKETS_0_2_0_NETWORK_IP_ADDRESS_IPV6 1

typedef struct {
  uint16_t port;
  // sin_port
  wasi_sockets_0_2_0_network_ipv4_address_t address;
} wasi_sockets_0_2_0_network_ipv4_socket_address_t;

typedef struct {
  uint16_t port;
  // sin6_port
  uint32_t flow_info;
  // sin6_flowinfo
  wasi_sockets_0_2_0_network_ipv6_address_t address;
  // sin6_addr
  uint32_t scope_id;
} wasi_sockets_0_2_0_network_ipv6_socket_address_t;

typedef struct {
  uint8_t tag;
  union {
    wasi_sockets_0_2_0_network_ipv4_socket_address_t ipv4;
    wasi_sockets_0_2_0_network_ipv6_socket_address_t ipv6;
  } val;
} wasi_sockets_0_2_0_network_ip_socket_address_t;

#define WASI_SOCKETS_0_2_0_NETWORK_IP_SOCKET_ADDRESS_IPV4 0
#define WASI_SOCKETS_0_2_0_NETWORK_IP_SOCKET_ADDRESS_IPV6 1

typedef wasi_sockets_0_2_0_network_own_network_t wasi_sockets_0_2_0_instance_network_own_network_t;

typedef wasi_sockets_0_2_0_network_error_code_t wasi_sockets_0_2_0_udp_error_code_t;

typedef wasi_sockets_0_2_0_network_ip_socket_address_t wasi_sockets_0_2_0_udp_ip_socket_address_t;

typedef wasi_sockets_0_2_0_network_ip_address_family_t wasi_sockets_0_2_0_udp_ip_address_family_t;

typedef struct {
  uint8_t *ptr;
  size_t len;
} wasi_sockets_0_2_0_udp_list_u8_t;

// A received datagram.
typedef struct {
  // The payload.
  //
  // Theoretical max size: ~64 KiB. In practice, typically less than 1500 bytes.
  wasi_sockets_0_2_0_udp_list_u8_t data;
  // The source address.
  //
  // This field is guaranteed to match the remote address the stream was initialized with, if any.
  //
  // Equivalent to the `src_addr` out parameter of `recvfrom`.
  wasi_sockets_0_2_0_udp_ip_socket_address_t remote_address;
} wasi_sockets_0_2_0_udp_incoming_datagram_t;

typedef struct {
  bool is_some;
  wasi_sockets_0_2_0_udp_ip_socket_address_t val;
} wasi_sockets_0_2_0_udp_option_ip_socket_address_t;

// A datagram to be sent out.
typedef struct {
  // The payload.
  wasi_sockets_0_2_0_udp_list_u8_t data;
  // The destination address.
  //
  // The requirements on this field depend on how the stream was initialized:
  // - with a remote address: this field must be None or match the stream's remote address exactly.
  // - without a remote address: this field is required.
  //
  // If this value is None, the send operation is equivalent to `send` in POSIX. Otherwise it is
  // equivalent to `sendto`.
  wasi_sockets_0_2_0_udp_option_ip_socket_address_t remote_address;
} wasi_sockets_0_2_0_udp_outgoing_datagram_t;

typedef struct wasi_sockets_0_2_0_udp_own_udp_socket_t {
  int32_t __handle;
} wasi_sockets_0_2_0_udp_own_udp_socket_t;

typedef struct wasi_sockets_0_2_0_udp_borrow_udp_socket_t {
  int32_t __handle;
} wasi_sockets_0_2_0_udp_borrow_udp_socket_t;

typedef struct wasi_sockets_0_2_0_udp_own_incoming_datagram_stream_t {
  int32_t __handle;
} wasi_sockets_0_2_0_udp_own_incoming_datagram_stream_t;

typedef struct wasi_sockets_0_2_0_udp_borrow_incoming_datagram_stream_t {
  int32_t __handle;
} wasi_sockets_0_2_0_udp_borrow_incoming_datagram_stream_t;

typedef struct wasi_sockets_0_2_0_udp_own_outgoing_datagram_stream_t {
  int32_t __handle;
} wasi_sockets_0_2_0_udp_own_outgoing_datagram_stream_t;

typedef struct wasi_sockets_0_2_0_udp_borrow_outgoing_datagram_stream_t {
  int32_t __handle;
} wasi_sockets_0_2_0_udp_borrow_outgoing_datagram_stream_t;

typedef wasi_sockets_0_2_0_network_borrow_network_t wasi_sockets_0_2_0_udp_borrow_network_t;

typedef struct {
  bool is_err;
  union {
    wasi_sockets_0_2_0_udp_error_code_t err;
  } val;
} wasi_sockets_0_2_0_udp_result_void_error_code_t;

typedef struct {
  wasi_sockets_0_2_0_udp_own_incoming_datagram_stream_t f0;
  wasi_sockets_0_2_0_udp_own_outgoing_datagram_stream_t f1;
} wasi_sockets_0_2_0_udp_tuple2_own_incoming_datagram_stream_own_outgoing_datagram_stream_t;

typedef struct {
  bool is_err;
  union {
    wasi_sockets_0_2_0_udp_tuple2_own_incoming_datagram_stream_own_outgoing_datagram_stream_t ok;
    wasi_sockets_0_2_0_udp_error_code_t err;
  } val;
} wasi_sockets_0_2_0_udp_result_tuple2_own_incoming_datagram_stream_own_outgoing_datagram_stream_error_code_t;

typedef struct {
  bool is_err;
  union {
    wasi_sockets_0_2_0_udp_ip_socket_address_t ok;
    wasi_sockets_0_2_0_udp_error_code_t err;
  } val;
} wasi_sockets_0_2_0_udp_result_ip_socket_address_error_code_t;

typedef struct {
  bool is_err;
  union {
    bool ok;
    wasi_sockets_0_2_0_udp_error_code_t err;
  } val;
} wasi_sockets_0_2_0_udp_result_bool_error_code_t;

typedef struct {
  bool is_err;
  union {
    uint8_t ok;
    wasi_sockets_0_2_0_udp_error_code_t err;
  } val;
} wasi_sockets_0_2_0_udp_result_u8_error_code_t;

typedef struct {
  bool is_err;
  union {
    uint64_t ok;
    wasi_sockets_0_2_0_udp_error_code_t err;
  } val;
} wasi_sockets_0_2_0_udp_result_u64_error_code_t;

typedef wasi_io_0_2_0_poll_own_pollable_t wasi_sockets_0_2_0_udp_own_pollable_t;

typedef struct {
  wasi_sockets_0_2_0_udp_incoming_datagram_t *ptr;
  size_t len;
} wasi_sockets_0_2_0_udp_list_incoming_datagram_t;

typedef struct {
  bool is_err;
  union {
    wasi_sockets_0_2_0_udp_list_incoming_datagram_t ok;
    wasi_sockets_0_2_0_udp_error_code_t err;
  } val;
} wasi_sockets_0_2_0_udp_result_list_incoming_datagram_error_code_t;

typedef struct {
  wasi_sockets_0_2_0_udp_outgoing_datagram_t *ptr;
  size_t len;
} wasi_sockets_0_2_0_udp_list_outgoing_datagram_t;

typedef wasi_sockets_0_2_0_network_error_code_t wasi_sockets_0_2_0_udp_create_socket_error_code_t;

typedef wasi_sockets_0_2_0_network_ip_address_family_t
    wasi_sockets_0_2_0_udp_create_socket_ip_address_family_t;

typedef wasi_sockets_0_2_0_udp_own_udp_socket_t
    wasi_sockets_0_2_0_udp_create_socket_own_udp_socket_t;

typedef struct {
  bool is_err;
  union {
    wasi_sockets_0_2_0_udp_create_socket_own_udp_socket_t ok;
    wasi_sockets_0_2_0_udp_create_socket_error_code_t err;
  } val;
} wasi_sockets_0_2_0_udp_create_socket_result_own_udp_socket_error_code_t;

typedef wasi_clocks_0_2_0_monotonic_clock_duration_t wasi_sockets_0_2_0_tcp_duration_t;

typedef wasi_sockets_0_2_0_network_error_code_t wasi_sockets_0_2_0_tcp_error_code_t;

typedef wasi_sockets_0_2_0_network_ip_socket_address_t wasi_sockets_0_2_0_tcp_ip_socket_address_t;

typedef wasi_sockets_0_2_0_network_ip_address_family_t wasi_sockets_0_2_0_tcp_ip_address_family_t;

typedef uint8_t wasi_sockets_0_2_0_tcp_shutdown_type_t;

// Similar to `SHUT_RD` in POSIX.
#define WASI_SOCKETS_0_2_0_TCP_SHUTDOWN_TYPE_RECEIVE 0
// Similar to `SHUT_WR` in POSIX.
#define WASI_SOCKETS_0_2_0_TCP_SHUTDOWN_TYPE_SEND 1
// Similar to `SHUT_RDWR` in POSIX.
#define WASI_SOCKETS_0_2_0_TCP_SHUTDOWN_TYPE_BOTH 2

typedef struct wasi_sockets_0_2_0_tcp_own_tcp_socket_t {
  int32_t __handle;
} wasi_sockets_0_2_0_tcp_own_tcp_socket_t;

typedef struct wasi_sockets_0_2_0_tcp_borrow_tcp_socket_t {
  int32_t __handle;
} wasi_sockets_0_2_0_tcp_borrow_tcp_socket_t;

typedef wasi_sockets_0_2_0_network_borrow_network_t wasi_sockets_0_2_0_tcp_borrow_network_t;

typedef struct {
  bool is_err;
  union {
    wasi_sockets_0_2_0_tcp_error_code_t err;
  } val;
} wasi_sockets_0_2_0_tcp_result_void_error_code_t;

typedef wasi_io_0_2_0_streams_own_input_stream_t wasi_sockets_0_2_0_tcp_own_input_stream_t;

typedef wasi_io_0_2_0_streams_own_output_stream_t wasi_sockets_0_2_0_tcp_own_output_stream_t;

typedef struct {
  wasi_sockets_0_2_0_tcp_own_input_stream_t f0;
  wasi_sockets_0_2_0_tcp_own_output_stream_t f1;
} wasi_sockets_0_2_0_tcp_tuple2_own_input_stream_own_output_stream_t;

typedef struct {
  bool is_err;
  union {
    wasi_sockets_0_2_0_tcp_tuple2_own_input_stream_own_output_stream_t ok;
    wasi_sockets_0_2_0_tcp_error_code_t err;
  } val;
} wasi_sockets_0_2_0_tcp_result_tuple2_own_input_stream_own_output_stream_error_code_t;

typedef struct {
  wasi_sockets_0_2_0_tcp_own_tcp_socket_t f0;
  wasi_sockets_0_2_0_tcp_own_input_stream_t f1;
  wasi_sockets_0_2_0_tcp_own_output_stream_t f2;
} wasi_sockets_0_2_0_tcp_tuple3_own_tcp_socket_own_input_stream_own_output_stream_t;

typedef struct {
  bool is_err;
  union {
    wasi_sockets_0_2_0_tcp_tuple3_own_tcp_socket_own_input_stream_own_output_stream_t ok;
    wasi_sockets_0_2_0_tcp_error_code_t err;
  } val;
} wasi_sockets_0_2_0_tcp_result_tuple3_own_tcp_socket_own_input_stream_own_output_stream_error_code_t;

typedef struct {
  bool is_err;
  union {
    wasi_sockets_0_2_0_tcp_ip_socket_address_t ok;
    wasi_sockets_0_2_0_tcp_error_code_t err;
  } val;
} wasi_sockets_0_2_0_tcp_result_ip_socket_address_error_code_t;

typedef struct {
  bool is_err;
  union {
    bool ok;
    wasi_sockets_0_2_0_tcp_error_code_t err;
  } val;
} wasi_sockets_0_2_0_tcp_result_bool_error_code_t;

typedef struct {
  bool is_err;
  union {
    wasi_sockets_0_2_0_tcp_duration_t ok;
    wasi_sockets_0_2_0_tcp_error_code_t err;
  } val;
} wasi_sockets_0_2_0_tcp_result_duration_error_code_t;

typedef struct {
  bool is_err;
  union {
    uint32_t ok;
    wasi_sockets_0_2_0_tcp_error_code_t err;
  } val;
} wasi_sockets_0_2_0_tcp_result_u32_error_code_t;

typedef struct {
  bool is_err;
  union {
    uint8_t ok;
    wasi_sockets_0_2_0_tcp_error_code_t err;
  } val;
} wasi_sockets_0_2_0_tcp_result_u8_error_code_t;

typedef struct {
  bool is_err;
  union {
    uint64_t ok;
    wasi_sockets_0_2_0_tcp_error_code_t err;
  } val;
} wasi_sockets_0_2_0_tcp_result_u64_error_code_t;

typedef wasi_io_0_2_0_poll_own_pollable_t wasi_sockets_0_2_0_tcp_own_pollable_t;

typedef wasi_sockets_0_2_0_network_error_code_t wasi_sockets_0_2_0_tcp_create_socket_error_code_t;

typedef wasi_sockets_0_2_0_network_ip_address_family_t
    wasi_sockets_0_2_0_tcp_create_socket_ip_address_family_t;

typedef wasi_sockets_0_2_0_tcp_own_tcp_socket_t
    wasi_sockets_0_2_0_tcp_create_socket_own_tcp_socket_t;

typedef struct {
  bool is_err;
  union {
    wasi_sockets_0_2_0_tcp_create_socket_own_tcp_socket_t ok;
    wasi_sockets_0_2_0_tcp_create_socket_error_code_t err;
  } val;
} wasi_sockets_0_2_0_tcp_create_socket_result_own_tcp_socket_error_code_t;

typedef wasi_sockets_0_2_0_network_error_code_t wasi_sockets_0_2_0_ip_name_lookup_error_code_t;

typedef wasi_sockets_0_2_0_network_ip_address_t wasi_sockets_0_2_0_ip_name_lookup_ip_address_t;

typedef struct wasi_sockets_0_2_0_ip_name_lookup_own_resolve_address_stream_t {
  int32_t __handle;
} wasi_sockets_0_2_0_ip_name_lookup_own_resolve_address_stream_t;

typedef struct wasi_sockets_0_2_0_ip_name_lookup_borrow_resolve_address_stream_t {
  int32_t __handle;
} wasi_sockets_0_2_0_ip_name_lookup_borrow_resolve_address_stream_t;

typedef wasi_sockets_0_2_0_network_borrow_network_t
    wasi_sockets_0_2_0_ip_name_lookup_borrow_network_t;

typedef struct {
  bool is_err;
  union {
    wasi_sockets_0_2_0_ip_name_lookup_own_resolve_address_stream_t ok;
    wasi_sockets_0_2_0_ip_name_lookup_error_code_t err;
  } val;
} wasi_sockets_0_2_0_ip_name_lookup_result_own_resolve_address_stream_error_code_t;

typedef struct {
  bool is_some;
  wasi_sockets_0_2_0_ip_name_lookup_ip_address_t val;
} wasi_sockets_0_2_0_ip_name_lookup_option_ip_address_t;

typedef struct {
  bool is_err;
  union {
    wasi_sockets_0_2_0_ip_name_lookup_option_ip_address_t ok;
    wasi_sockets_0_2_0_ip_name_lookup_error_code_t err;
  } val;
} wasi_sockets_0_2_0_ip_name_lookup_result_option_ip_address_error_code_t;

typedef wasi_io_0_2_0_poll_own_pollable_t wasi_sockets_0_2_0_ip_name_lookup_own_pollable_t;

typedef struct {
  uint8_t *ptr;
  size_t len;
} wasi_random_0_2_0_random_list_u8_t;

typedef struct {
  uint64_t f0;
  uint64_t f1;
} wasi_random_0_2_0_insecure_seed_tuple2_u64_u64_t;

typedef wasi_clocks_0_2_0_monotonic_clock_duration_t wasi_http_0_2_0_types_duration_t;

// This type corresponds to HTTP standard Methods.
typedef struct {
  uint8_t tag;
  union {
    bindings_string_t other;
  } val;
} wasi_http_0_2_0_types_method_t;

#define WASI_HTTP_0_2_0_TYPES_METHOD_GET 0
#define WASI_HTTP_0_2_0_TYPES_METHOD_HEAD 1
#define WASI_HTTP_0_2_0_TYPES_METHOD_POST 2
#define WASI_HTTP_0_2_0_TYPES_METHOD_PUT 3
#define WASI_HTTP_0_2_0_TYPES_METHOD_DELETE 4
#define WASI_HTTP_0_2_0_TYPES_METHOD_CONNECT 5
#define WASI_HTTP_0_2_0_TYPES_METHOD_OPTIONS 6
#define WASI_HTTP_0_2_0_TYPES_METHOD_TRACE 7
#define WASI_HTTP_0_2_0_TYPES_METHOD_PATCH 8
#define WASI_HTTP_0_2_0_TYPES_METHOD_OTHER 9

// This type corresponds to HTTP standard Related Schemes.
typedef struct {
  uint8_t tag;
  union {
    bindings_string_t other;
  } val;
} wasi_http_0_2_0_types_scheme_t;

#define WASI_HTTP_0_2_0_TYPES_SCHEME_HTTP 0
#define WASI_HTTP_0_2_0_TYPES_SCHEME_HTTPS 1
#define WASI_HTTP_0_2_0_TYPES_SCHEME_OTHER 2

typedef struct {
  bool is_some;
  bindings_string_t val;
} wasi_http_0_2_0_types_option_string_t;

typedef struct {
  bool is_some;
  uint16_t val;
} wasi_http_0_2_0_types_option_u16_t;

// Defines the case payload type for `DNS-error` above:
typedef struct {
  wasi_http_0_2_0_types_option_string_t rcode;
  wasi_http_0_2_0_types_option_u16_t info_code;
} wasi_http_0_2_0_types_dns_error_payload_t;

typedef struct {
  bool is_some;
  uint8_t val;
} wasi_http_0_2_0_types_option_u8_t;

// Defines the case payload type for `TLS-alert-received` above:
typedef struct {
  wasi_http_0_2_0_types_option_u8_t alert_id;
  wasi_http_0_2_0_types_option_string_t alert_message;
} wasi_http_0_2_0_types_tls_alert_received_payload_t;

typedef struct {
  bool is_some;
  uint32_t val;
} wasi_http_0_2_0_types_option_u32_t;

// Defines the case payload type for `HTTP-response-{header,trailer}-size` above:
typedef struct {
  wasi_http_0_2_0_types_option_string_t field_name;
  wasi_http_0_2_0_types_option_u32_t field_size;
} wasi_http_0_2_0_types_field_size_payload_t;

typedef struct {
  bool is_some;
  uint64_t val;
} wasi_http_0_2_0_types_option_u64_t;

typedef struct {
  bool is_some;
  wasi_http_0_2_0_types_field_size_payload_t val;
} wasi_http_0_2_0_types_option_field_size_payload_t;

// These cases are inspired by the IANA HTTP Proxy Error Types:
// https://www.iana.org/assignments/http-proxy-status/http-proxy-status.xhtml#table-http-proxy-error-types
typedef struct {
  uint8_t tag;
  union {
    wasi_http_0_2_0_types_dns_error_payload_t dns_error;
    wasi_http_0_2_0_types_tls_alert_received_payload_t tls_alert_received;
    wasi_http_0_2_0_types_option_u64_t http_request_body_size;
    wasi_http_0_2_0_types_option_u32_t http_request_header_section_size;
    wasi_http_0_2_0_types_option_field_size_payload_t http_request_header_size;
    wasi_http_0_2_0_types_option_u32_t http_request_trailer_section_size;
    wasi_http_0_2_0_types_field_size_payload_t http_request_trailer_size;
    wasi_http_0_2_0_types_option_u32_t http_response_header_section_size;
    wasi_http_0_2_0_types_field_size_payload_t http_response_header_size;
    wasi_http_0_2_0_types_option_u64_t http_response_body_size;
    wasi_http_0_2_0_types_option_u32_t http_response_trailer_section_size;
    wasi_http_0_2_0_types_field_size_payload_t http_response_trailer_size;
    wasi_http_0_2_0_types_option_string_t http_response_transfer_coding;
    wasi_http_0_2_0_types_option_string_t http_response_content_coding;
    wasi_http_0_2_0_types_option_string_t internal_error;
  } val;
} wasi_http_0_2_0_types_error_code_t;

#define WASI_HTTP_0_2_0_TYPES_ERROR_CODE_DNS_TIMEOUT 0
#define WASI_HTTP_0_2_0_TYPES_ERROR_CODE_DNS_ERROR 1
#define WASI_HTTP_0_2_0_TYPES_ERROR_CODE_DESTINATION_NOT_FOUND 2
#define WASI_HTTP_0_2_0_TYPES_ERROR_CODE_DESTINATION_UNAVAILABLE 3
#define WASI_HTTP_0_2_0_TYPES_ERROR_CODE_DESTINATION_IP_PROHIBITED 4
#define WASI_HTTP_0_2_0_TYPES_ERROR_CODE_DESTINATION_IP_UNROUTABLE 5
#define WASI_HTTP_0_2_0_TYPES_ERROR_CODE_CONNECTION_REFUSED 6
#define WASI_HTTP_0_2_0_TYPES_ERROR_CODE_CONNECTION_TERMINATED 7
#define WASI_HTTP_0_2_0_TYPES_ERROR_CODE_CONNECTION_TIMEOUT 8
#define WASI_HTTP_0_2_0_TYPES_ERROR_CODE_CONNECTION_READ_TIMEOUT 9
#define WASI_HTTP_0_2_0_TYPES_ERROR_CODE_CONNECTION_WRITE_TIMEOUT 10
#define WASI_HTTP_0_2_0_TYPES_ERROR_CODE_CONNECTION_LIMIT_REACHED 11
#define WASI_HTTP_0_2_0_TYPES_ERROR_CODE_TLS_PROTOCOL_ERROR 12
#define WASI_HTTP_0_2_0_TYPES_ERROR_CODE_TLS_CERTIFICATE_ERROR 13
#define WASI_HTTP_0_2_0_TYPES_ERROR_CODE_TLS_ALERT_RECEIVED 14
#define WASI_HTTP_0_2_0_TYPES_ERROR_CODE_HTTP_REQUEST_DENIED 15
#define WASI_HTTP_0_2_0_TYPES_ERROR_CODE_HTTP_REQUEST_LENGTH_REQUIRED 16
#define WASI_HTTP_0_2_0_TYPES_ERROR_CODE_HTTP_REQUEST_BODY_SIZE 17
#define WASI_HTTP_0_2_0_TYPES_ERROR_CODE_HTTP_REQUEST_METHOD_INVALID 18
#define WASI_HTTP_0_2_0_TYPES_ERROR_CODE_HTTP_REQUEST_URI_INVALID 19
#define WASI_HTTP_0_2_0_TYPES_ERROR_CODE_HTTP_REQUEST_URI_TOO_LONG 20
#define WASI_HTTP_0_2_0_TYPES_ERROR_CODE_HTTP_REQUEST_HEADER_SECTION_SIZE 21
#define WASI_HTTP_0_2_0_TYPES_ERROR_CODE_HTTP_REQUEST_HEADER_SIZE 22
#define WASI_HTTP_0_2_0_TYPES_ERROR_CODE_HTTP_REQUEST_TRAILER_SECTION_SIZE 23
#define WASI_HTTP_0_2_0_TYPES_ERROR_CODE_HTTP_REQUEST_TRAILER_SIZE 24
#define WASI_HTTP_0_2_0_TYPES_ERROR_CODE_HTTP_RESPONSE_INCOMPLETE 25
#define WASI_HTTP_0_2_0_TYPES_ERROR_CODE_HTTP_RESPONSE_HEADER_SECTION_SIZE 26
#define WASI_HTTP_0_2_0_TYPES_ERROR_CODE_HTTP_RESPONSE_HEADER_SIZE 27
#define WASI_HTTP_0_2_0_TYPES_ERROR_CODE_HTTP_RESPONSE_BODY_SIZE 28
#define WASI_HTTP_0_2_0_TYPES_ERROR_CODE_HTTP_RESPONSE_TRAILER_SECTION_SIZE 29
#define WASI_HTTP_0_2_0_TYPES_ERROR_CODE_HTTP_RESPONSE_TRAILER_SIZE 30
#define WASI_HTTP_0_2_0_TYPES_ERROR_CODE_HTTP_RESPONSE_TRANSFER_CODING 31
#define WASI_HTTP_0_2_0_TYPES_ERROR_CODE_HTTP_RESPONSE_CONTENT_CODING 32
#define WASI_HTTP_0_2_0_TYPES_ERROR_CODE_HTTP_RESPONSE_TIMEOUT 33
#define WASI_HTTP_0_2_0_TYPES_ERROR_CODE_HTTP_UPGRADE_FAILED 34
#define WASI_HTTP_0_2_0_TYPES_ERROR_CODE_HTTP_PROTOCOL_ERROR 35
#define WASI_HTTP_0_2_0_TYPES_ERROR_CODE_LOOP_DETECTED 36
#define WASI_HTTP_0_2_0_TYPES_ERROR_CODE_CONFIGURATION_ERROR 37
// This is a catch-all error for anything that doesn't fit cleanly into a
// more specific case. It also includes an optional string for an
// unstructured description of the error. Users should not depend on the
// string for diagnosing errors, as it's not required to be consistent
// between implementations.
#define WASI_HTTP_0_2_0_TYPES_ERROR_CODE_INTERNAL_ERROR 38

// This type enumerates the different kinds of errors that may occur when
// setting or appending to a `fields` resource.
typedef struct {
  uint8_t tag;
} wasi_http_0_2_0_types_header_error_t;

// This error indicates that a `field-key` or `field-value` was
// syntactically invalid when used with an operation that sets headers in a
// `fields`.
#define WASI_HTTP_0_2_0_TYPES_HEADER_ERROR_INVALID_SYNTAX 0
// This error indicates that a forbidden `field-key` was used when trying
// to set a header in a `fields`.
#define WASI_HTTP_0_2_0_TYPES_HEADER_ERROR_FORBIDDEN 1
// This error indicates that the operation on the `fields` was not
// permitted because the fields are immutable.
#define WASI_HTTP_0_2_0_TYPES_HEADER_ERROR_IMMUTABLE 2

// Field keys are always strings.
typedef bindings_string_t wasi_http_0_2_0_types_field_key_t;

// Field values should always be ASCII strings. However, in
// reality, HTTP implementations often have to interpret malformed values,
// so they are provided as a list of bytes.
typedef struct {
  uint8_t *ptr;
  size_t len;
} wasi_http_0_2_0_types_field_value_t;

typedef struct wasi_http_0_2_0_types_own_fields_t {
  int32_t __handle;
} wasi_http_0_2_0_types_own_fields_t;

typedef struct wasi_http_0_2_0_types_borrow_fields_t {
  int32_t __handle;
} wasi_http_0_2_0_types_borrow_fields_t;

typedef struct wasi_http_0_2_0_types_own_incoming_request_t {
  int32_t __handle;
} wasi_http_0_2_0_types_own_incoming_request_t;

typedef struct wasi_http_0_2_0_types_borrow_incoming_request_t {
  int32_t __handle;
} wasi_http_0_2_0_types_borrow_incoming_request_t;

typedef struct wasi_http_0_2_0_types_own_outgoing_request_t {
  int32_t __handle;
} wasi_http_0_2_0_types_own_outgoing_request_t;

typedef struct wasi_http_0_2_0_types_borrow_outgoing_request_t {
  int32_t __handle;
} wasi_http_0_2_0_types_borrow_outgoing_request_t;

typedef struct wasi_http_0_2_0_types_own_request_options_t {
  int32_t __handle;
} wasi_http_0_2_0_types_own_request_options_t;

typedef struct wasi_http_0_2_0_types_borrow_request_options_t {
  int32_t __handle;
} wasi_http_0_2_0_types_borrow_request_options_t;

typedef struct wasi_http_0_2_0_types_own_response_outparam_t {
  int32_t __handle;
} wasi_http_0_2_0_types_own_response_outparam_t;

typedef struct wasi_http_0_2_0_types_borrow_response_outparam_t {
  int32_t __handle;
} wasi_http_0_2_0_types_borrow_response_outparam_t;

// This type corresponds to the HTTP standard Status Code.
typedef uint16_t wasi_http_0_2_0_types_status_code_t;

typedef struct wasi_http_0_2_0_types_own_incoming_response_t {
  int32_t __handle;
} wasi_http_0_2_0_types_own_incoming_response_t;

typedef struct wasi_http_0_2_0_types_borrow_incoming_response_t {
  int32_t __handle;
} wasi_http_0_2_0_types_borrow_incoming_response_t;

typedef struct wasi_http_0_2_0_types_own_incoming_body_t {
  int32_t __handle;
} wasi_http_0_2_0_types_own_incoming_body_t;

typedef struct wasi_http_0_2_0_types_borrow_incoming_body_t {
  int32_t __handle;
} wasi_http_0_2_0_types_borrow_incoming_body_t;

typedef struct wasi_http_0_2_0_types_own_future_trailers_t {
  int32_t __handle;
} wasi_http_0_2_0_types_own_future_trailers_t;

typedef struct wasi_http_0_2_0_types_borrow_future_trailers_t {
  int32_t __handle;
} wasi_http_0_2_0_types_borrow_future_trailers_t;

typedef struct wasi_http_0_2_0_types_own_outgoing_response_t {
  int32_t __handle;
} wasi_http_0_2_0_types_own_outgoing_response_t;

typedef struct wasi_http_0_2_0_types_borrow_outgoing_response_t {
  int32_t __handle;
} wasi_http_0_2_0_types_borrow_outgoing_response_t;

typedef struct wasi_http_0_2_0_types_own_outgoing_body_t {
  int32_t __handle;
} wasi_http_0_2_0_types_own_outgoing_body_t;

typedef struct wasi_http_0_2_0_types_borrow_outgoing_body_t {
  int32_t __handle;
} wasi_http_0_2_0_types_borrow_outgoing_body_t;

typedef struct wasi_http_0_2_0_types_own_future_incoming_response_t {
  int32_t __handle;
} wasi_http_0_2_0_types_own_future_incoming_response_t;

typedef struct wasi_http_0_2_0_types_borrow_future_incoming_response_t {
  int32_t __handle;
} wasi_http_0_2_0_types_borrow_future_incoming_response_t;

typedef wasi_io_0_2_0_error_borrow_error_t wasi_http_0_2_0_types_borrow_io_error_t;

typedef struct {
  bool is_some;
  wasi_http_0_2_0_types_error_code_t val;
} wasi_http_0_2_0_types_option_error_code_t;

typedef struct {
  wasi_http_0_2_0_types_field_key_t f0;
  wasi_http_0_2_0_types_field_value_t f1;
} wasi_http_0_2_0_types_tuple2_field_key_field_value_t;

typedef struct {
  wasi_http_0_2_0_types_tuple2_field_key_field_value_t *ptr;
  size_t len;
} wasi_http_0_2_0_types_list_tuple2_field_key_field_value_t;

typedef struct {
  bool is_err;
  union {
    wasi_http_0_2_0_types_own_fields_t ok;
    wasi_http_0_2_0_types_header_error_t err;
  } val;
} wasi_http_0_2_0_types_result_own_fields_header_error_t;

typedef struct {
  wasi_http_0_2_0_types_field_value_t *ptr;
  size_t len;
} wasi_http_0_2_0_types_list_field_value_t;

typedef struct {
  bool is_err;
  union {
    wasi_http_0_2_0_types_header_error_t err;
  } val;
} wasi_http_0_2_0_types_result_void_header_error_t;

typedef struct {
  bool is_some;
  wasi_http_0_2_0_types_scheme_t val;
} wasi_http_0_2_0_types_option_scheme_t;

typedef wasi_http_0_2_0_types_own_fields_t wasi_http_0_2_0_types_own_headers_t;

typedef struct {
  bool is_err;
  union {
    wasi_http_0_2_0_types_own_incoming_body_t ok;
  } val;
} wasi_http_0_2_0_types_result_own_incoming_body_void_t;

typedef struct {
  bool is_err;
  union {
    wasi_http_0_2_0_types_own_outgoing_body_t ok;
  } val;
} wasi_http_0_2_0_types_result_own_outgoing_body_void_t;

typedef struct {
  bool is_err;
} wasi_http_0_2_0_types_result_void_void_t;

typedef struct {
  bool is_some;
  wasi_http_0_2_0_types_duration_t val;
} wasi_http_0_2_0_types_option_duration_t;

typedef struct {
  bool is_err;
  union {
    wasi_http_0_2_0_types_own_outgoing_response_t ok;
    wasi_http_0_2_0_types_error_code_t err;
  } val;
} wasi_http_0_2_0_types_result_own_outgoing_response_error_code_t;

typedef wasi_io_0_2_0_streams_own_input_stream_t wasi_http_0_2_0_types_own_input_stream_t;

typedef struct {
  bool is_err;
  union {
    wasi_http_0_2_0_types_own_input_stream_t ok;
  } val;
} wasi_http_0_2_0_types_result_own_input_stream_void_t;

typedef wasi_io_0_2_0_poll_own_pollable_t wasi_http_0_2_0_types_own_pollable_t;

typedef wasi_http_0_2_0_types_own_fields_t wasi_http_0_2_0_types_own_trailers_t;

typedef struct {
  bool is_some;
  wasi_http_0_2_0_types_own_trailers_t val;
} wasi_http_0_2_0_types_option_own_trailers_t;

typedef struct {
  bool is_err;
  union {
    wasi_http_0_2_0_types_option_own_trailers_t ok;
    wasi_http_0_2_0_types_error_code_t err;
  } val;
} wasi_http_0_2_0_types_result_option_own_trailers_error_code_t;

typedef struct {
  bool is_err;
  union {
    wasi_http_0_2_0_types_result_option_own_trailers_error_code_t ok;
  } val;
} wasi_http_0_2_0_types_result_result_option_own_trailers_error_code_void_t;

typedef struct {
  bool is_some;
  wasi_http_0_2_0_types_result_result_option_own_trailers_error_code_void_t val;
} wasi_http_0_2_0_types_option_result_result_option_own_trailers_error_code_void_t;

typedef wasi_io_0_2_0_streams_own_output_stream_t wasi_http_0_2_0_types_own_output_stream_t;

typedef struct {
  bool is_err;
  union {
    wasi_http_0_2_0_types_own_output_stream_t ok;
  } val;
} wasi_http_0_2_0_types_result_own_output_stream_void_t;

typedef struct {
  bool is_err;
  union {
    wasi_http_0_2_0_types_error_code_t err;
  } val;
} wasi_http_0_2_0_types_result_void_error_code_t;

typedef struct {
  bool is_err;
  union {
    wasi_http_0_2_0_types_own_incoming_response_t ok;
    wasi_http_0_2_0_types_error_code_t err;
  } val;
} wasi_http_0_2_0_types_result_own_incoming_response_error_code_t;

typedef struct {
  bool is_err;
  union {
    wasi_http_0_2_0_types_result_own_incoming_response_error_code_t ok;
  } val;
} wasi_http_0_2_0_types_result_result_own_incoming_response_error_code_void_t;

typedef struct {
  bool is_some;
  wasi_http_0_2_0_types_result_result_own_incoming_response_error_code_void_t val;
} wasi_http_0_2_0_types_option_result_result_own_incoming_response_error_code_void_t;

typedef wasi_http_0_2_0_types_error_code_t wasi_http_0_2_0_outgoing_handler_error_code_t;

typedef wasi_http_0_2_0_types_own_outgoing_request_t
    wasi_http_0_2_0_outgoing_handler_own_outgoing_request_t;

typedef wasi_http_0_2_0_types_own_request_options_t
    wasi_http_0_2_0_outgoing_handler_own_request_options_t;

typedef struct {
  bool is_some;
  wasi_http_0_2_0_outgoing_handler_own_request_options_t val;
} wasi_http_0_2_0_outgoing_handler_option_own_request_options_t;

typedef wasi_http_0_2_0_types_own_future_incoming_response_t
    wasi_http_0_2_0_outgoing_handler_own_future_incoming_response_t;

typedef struct {
  bool is_err;
  union {
    wasi_http_0_2_0_outgoing_handler_own_future_incoming_response_t ok;
    wasi_http_0_2_0_outgoing_handler_error_code_t err;
  } val;
} wasi_http_0_2_0_outgoing_handler_result_own_future_incoming_response_error_code_t;

typedef struct {
  bool is_err;
} exports_wasi_cli_0_2_0_run_result_void_void_t;

typedef wasi_http_0_2_0_types_own_incoming_request_t
    exports_wasi_http_0_2_0_incoming_handler_own_incoming_request_t;

typedef wasi_http_0_2_0_types_own_response_outparam_t
    exports_wasi_http_0_2_0_incoming_handler_own_response_outparam_t;

// Imported Functions from `wasi:cli/environment@0.2.0`
// Get the POSIX-style environment variables.
//
// Each environment variable is provided as a pair of string variable names
// and string value.
//
// Morally, these are a value import, but until value imports are available
// in the component model, this import function should return the same
// values each time it is called.
extern void wasi_cli_0_2_0_environment_get_environment(
    wasi_cli_0_2_0_environment_list_tuple2_string_string_t *ret);
// Get the POSIX-style arguments to the program.
extern void wasi_cli_0_2_0_environment_get_arguments(wasi_cli_0_2_0_environment_list_string_t *ret);
// Return a path that programs should use as their initial current working
// directory, interpreting `.` as shorthand for this.
extern bool wasi_cli_0_2_0_environment_initial_cwd(bindings_string_t *ret);

// Imported Functions from `wasi:cli/exit@0.2.0`
// Exit the current instance and any linked instances.
extern void wasi_cli_0_2_0_exit_exit(wasi_cli_0_2_0_exit_result_void_void_t *status);

// Imported Functions from `wasi:io/error@0.2.0`
// Returns a string that is suitable to assist humans in debugging
// this error.
//
// WARNING: The returned string should not be consumed mechanically!
// It may change across platforms, hosts, or other implementation
// details. Parsing this string is a major platform-compatibility
// hazard.
extern void
wasi_io_0_2_0_error_method_error_to_debug_string(wasi_io_0_2_0_error_borrow_error_t self,
                                                 bindings_string_t *ret);

// Imported Functions from `wasi:io/poll@0.2.0`
// Return the readiness of a pollable. This function never blocks.
//
// Returns `true` when the pollable is ready, and `false` otherwise.
extern bool wasi_io_0_2_0_poll_method_pollable_ready(wasi_io_0_2_0_poll_borrow_pollable_t self);
// `block` returns immediately if the pollable is ready, and otherwise
// blocks until ready.
//
// This function is equivalent to calling `poll.poll` on a list
// containing only this pollable.
extern void wasi_io_0_2_0_poll_method_pollable_block(wasi_io_0_2_0_poll_borrow_pollable_t self);
// Poll for completion on a set of pollables.
//
// This function takes a list of pollables, which identify I/O sources of
// interest, and waits until one or more of the events is ready for I/O.
//
// The result `list<u32>` contains one or more indices of handles in the
// argument list that is ready for I/O.
//
// If the list contains more elements than can be indexed with a `u32`
// value, this function traps.
//
// A timeout can be implemented by adding a pollable from the
// wasi-clocks API to the list.
//
// This function does not return a `result`; polling in itself does not
// do any I/O so it doesn't fail. If any of the I/O sources identified by
// the pollables has an error, it is indicated by marking the source as
// being reaedy for I/O.
extern void wasi_io_0_2_0_poll_poll(wasi_io_0_2_0_poll_list_borrow_pollable_t *in,
                                    wasi_io_0_2_0_poll_list_u32_t *ret);

// Imported Functions from `wasi:io/streams@0.2.0`
// Perform a non-blocking read from the stream.
//
// This function returns a list of bytes containing the read data,
// when successful. The returned list will contain up to `len` bytes;
// it may return fewer than requested, but not more. The list is
// empty when no bytes are available for reading at this time. The
// pollable given by `subscribe` will be ready when more bytes are
// available.
//
// This function fails with a `stream-error` when the operation
// encounters an error, giving `last-operation-failed`, or when the
// stream is closed, giving `closed`.
//
// When the caller gives a `len` of 0, it represents a request to
// read 0 bytes. If the stream is still open, this call should
// succeed and return an empty list, or otherwise fail with `closed`.
//
// The `len` parameter is a `u64`, which could represent a list of u8 which
// is not possible to allocate in wasm32, or not desirable to allocate as
// as a return value by the callee. The callee may return a list of bytes
// less than `len` in size while more bytes are available for reading.
extern bool
wasi_io_0_2_0_streams_method_input_stream_read(wasi_io_0_2_0_streams_borrow_input_stream_t self,
                                               uint64_t len, wasi_io_0_2_0_streams_list_u8_t *ret,
                                               wasi_io_0_2_0_streams_stream_error_t *err);
// Read bytes from a stream, after blocking until at least one byte can
// be read. Except for blocking, behavior is identical to `read`.
extern bool wasi_io_0_2_0_streams_method_input_stream_blocking_read(
    wasi_io_0_2_0_streams_borrow_input_stream_t self, uint64_t len,
    wasi_io_0_2_0_streams_list_u8_t *ret, wasi_io_0_2_0_streams_stream_error_t *err);
// Skip bytes from a stream. Returns number of bytes skipped.
//
// Behaves identical to `read`, except instead of returning a list
// of bytes, returns the number of bytes consumed from the stream.
extern bool
wasi_io_0_2_0_streams_method_input_stream_skip(wasi_io_0_2_0_streams_borrow_input_stream_t self,
                                               uint64_t len, uint64_t *ret,
                                               wasi_io_0_2_0_streams_stream_error_t *err);
// Skip bytes from a stream, after blocking until at least one byte
// can be skipped. Except for blocking behavior, identical to `skip`.
extern bool wasi_io_0_2_0_streams_method_input_stream_blocking_skip(
    wasi_io_0_2_0_streams_borrow_input_stream_t self, uint64_t len, uint64_t *ret,
    wasi_io_0_2_0_streams_stream_error_t *err);
// Create a `pollable` which will resolve once either the specified stream
// has bytes available to read or the other end of the stream has been
// closed.
// The created `pollable` is a child resource of the `input-stream`.
// Implementations may trap if the `input-stream` is dropped before
// all derived `pollable`s created with this function are dropped.
extern wasi_io_0_2_0_streams_own_pollable_t wasi_io_0_2_0_streams_method_input_stream_subscribe(
    wasi_io_0_2_0_streams_borrow_input_stream_t self);
// Check readiness for writing. This function never blocks.
//
// Returns the number of bytes permitted for the next call to `write`,
// or an error. Calling `write` with more bytes than this function has
// permitted will trap.
//
// When this function returns 0 bytes, the `subscribe` pollable will
// become ready when this function will report at least 1 byte, or an
// error.
extern bool wasi_io_0_2_0_streams_method_output_stream_check_write(
    wasi_io_0_2_0_streams_borrow_output_stream_t self, uint64_t *ret,
    wasi_io_0_2_0_streams_stream_error_t *err);
// Perform a write. This function never blocks.
//
// Precondition: check-write gave permit of Ok(n) and contents has a
// length of less than or equal to n. Otherwise, this function will trap.
//
// returns Err(closed) without writing if the stream has closed since
// the last call to check-write provided a permit.
extern bool
wasi_io_0_2_0_streams_method_output_stream_write(wasi_io_0_2_0_streams_borrow_output_stream_t self,
                                                 wasi_io_0_2_0_streams_list_u8_t *contents,
                                                 wasi_io_0_2_0_streams_stream_error_t *err);
// Perform a write of up to 4096 bytes, and then flush the stream. Block
// until all of these operations are complete, or an error occurs.
//
// This is a convenience wrapper around the use of `check-write`,
// `subscribe`, `write`, and `flush`, and is implemented with the
// following pseudo-code:
//
// ```text
// let pollable = this.subscribe();
// while !contents.is_empty() {
// // Wait for the stream to become writable
// poll-one(pollable);
// let Ok(n) = this.check-write(); // eliding error handling
// let len = min(n, contents.len());
// let (chunk, rest) = contents.split_at(len);
// this.write(chunk  );            // eliding error handling
// contents = rest;
// }
// this.flush();
// // Wait for completion of `flush`
// poll-one(pollable);
// // Check for any errors that arose during `flush`
// let _ = this.check-write();         // eliding error handling
// ```
extern bool wasi_io_0_2_0_streams_method_output_stream_blocking_write_and_flush(
    wasi_io_0_2_0_streams_borrow_output_stream_t self, wasi_io_0_2_0_streams_list_u8_t *contents,
    wasi_io_0_2_0_streams_stream_error_t *err);
// Request to flush buffered output. This function never blocks.
//
// This tells the output-stream that the caller intends any buffered
// output to be flushed. the output which is expected to be flushed
// is all that has been passed to `write` prior to this call.
//
// Upon calling this function, the `output-stream` will not accept any
// writes (`check-write` will return `ok(0)`) until the flush has
// completed. The `subscribe` pollable will become ready when the
// flush has completed and the stream can accept more writes.
extern bool
wasi_io_0_2_0_streams_method_output_stream_flush(wasi_io_0_2_0_streams_borrow_output_stream_t self,
                                                 wasi_io_0_2_0_streams_stream_error_t *err);
// Request to flush buffered output, and block until flush completes
// and stream is ready for writing again.
extern bool wasi_io_0_2_0_streams_method_output_stream_blocking_flush(
    wasi_io_0_2_0_streams_borrow_output_stream_t self, wasi_io_0_2_0_streams_stream_error_t *err);
// Create a `pollable` which will resolve once the output-stream
// is ready for more writing, or an error has occured. When this
// pollable is ready, `check-write` will return `ok(n)` with n>0, or an
// error.
//
// If the stream is closed, this pollable is always ready immediately.
//
// The created `pollable` is a child resource of the `output-stream`.
// Implementations may trap if the `output-stream` is dropped before
// all derived `pollable`s created with this function are dropped.
extern wasi_io_0_2_0_streams_own_pollable_t wasi_io_0_2_0_streams_method_output_stream_subscribe(
    wasi_io_0_2_0_streams_borrow_output_stream_t self);
// Write zeroes to a stream.
//
// this should be used precisely like `write` with the exact same
// preconditions (must use check-write first), but instead of
// passing a list of bytes, you simply pass the number of zero-bytes
// that should be written.
extern bool wasi_io_0_2_0_streams_method_output_stream_write_zeroes(
    wasi_io_0_2_0_streams_borrow_output_stream_t self, uint64_t len,
    wasi_io_0_2_0_streams_stream_error_t *err);
// Perform a write of up to 4096 zeroes, and then flush the stream.
// Block until all of these operations are complete, or an error
// occurs.
//
// This is a convenience wrapper around the use of `check-write`,
// `subscribe`, `write-zeroes`, and `flush`, and is implemented with
// the following pseudo-code:
//
// ```text
// let pollable = this.subscribe();
// while num_zeroes != 0 {
// // Wait for the stream to become writable
// poll-one(pollable);
// let Ok(n) = this.check-write(); // eliding error handling
// let len = min(n, num_zeroes);
// this.write-zeroes(len);         // eliding error handling
// num_zeroes -= len;
// }
// this.flush();
// // Wait for completion of `flush`
// poll-one(pollable);
// // Check for any errors that arose during `flush`
// let _ = this.check-write();         // eliding error handling
// ```
extern bool wasi_io_0_2_0_streams_method_output_stream_blocking_write_zeroes_and_flush(
    wasi_io_0_2_0_streams_borrow_output_stream_t self, uint64_t len,
    wasi_io_0_2_0_streams_stream_error_t *err);
// Read from one stream and write to another.
//
// The behavior of splice is equivelant to:
// 1. calling `check-write` on the `output-stream`
// 2. calling `read` on the `input-stream` with the smaller of the
// `check-write` permitted length and the `len` provided to `splice`
// 3. calling `write` on the `output-stream` with that read data.
//
// Any error reported by the call to `check-write`, `read`, or
// `write` ends the splice and reports that error.
//
// This function returns the number of bytes transferred; it may be less
// than `len`.
extern bool
wasi_io_0_2_0_streams_method_output_stream_splice(wasi_io_0_2_0_streams_borrow_output_stream_t self,
                                                  wasi_io_0_2_0_streams_borrow_input_stream_t src,
                                                  uint64_t len, uint64_t *ret,
                                                  wasi_io_0_2_0_streams_stream_error_t *err);
// Read from one stream and write to another, with blocking.
//
// This is similar to `splice`, except that it blocks until the
// `output-stream` is ready for writing, and the `input-stream`
// is ready for reading, before performing the `splice`.
extern bool wasi_io_0_2_0_streams_method_output_stream_blocking_splice(
    wasi_io_0_2_0_streams_borrow_output_stream_t self,
    wasi_io_0_2_0_streams_borrow_input_stream_t src, uint64_t len, uint64_t *ret,
    wasi_io_0_2_0_streams_stream_error_t *err);

// Imported Functions from `wasi:cli/stdin@0.2.0`
extern wasi_cli_0_2_0_stdin_own_input_stream_t wasi_cli_0_2_0_stdin_get_stdin(void);

// Imported Functions from `wasi:cli/stdout@0.2.0`
extern wasi_cli_0_2_0_stdout_own_output_stream_t wasi_cli_0_2_0_stdout_get_stdout(void);

// Imported Functions from `wasi:cli/stderr@0.2.0`
extern wasi_cli_0_2_0_stderr_own_output_stream_t wasi_cli_0_2_0_stderr_get_stderr(void);

// Imported Functions from `wasi:cli/terminal-stdin@0.2.0`
// If stdin is connected to a terminal, return a `terminal-input` handle
// allowing further interaction with it.
extern bool wasi_cli_0_2_0_terminal_stdin_get_terminal_stdin(
    wasi_cli_0_2_0_terminal_stdin_own_terminal_input_t *ret);

// Imported Functions from `wasi:cli/terminal-stdout@0.2.0`
// If stdout is connected to a terminal, return a `terminal-output` handle
// allowing further interaction with it.
extern bool wasi_cli_0_2_0_terminal_stdout_get_terminal_stdout(
    wasi_cli_0_2_0_terminal_stdout_own_terminal_output_t *ret);

// Imported Functions from `wasi:cli/terminal-stderr@0.2.0`
// If stderr is connected to a terminal, return a `terminal-output` handle
// allowing further interaction with it.
extern bool wasi_cli_0_2_0_terminal_stderr_get_terminal_stderr(
    wasi_cli_0_2_0_terminal_stderr_own_terminal_output_t *ret);

// Imported Functions from `wasi:clocks/monotonic-clock@0.2.0`
// Read the current value of the clock.
//
// The clock is monotonic, therefore calling this function repeatedly will
// produce a sequence of non-decreasing values.
extern wasi_clocks_0_2_0_monotonic_clock_instant_t wasi_clocks_0_2_0_monotonic_clock_now(void);
// Query the resolution of the clock. Returns the duration of time
// corresponding to a clock tick.
extern wasi_clocks_0_2_0_monotonic_clock_duration_t
wasi_clocks_0_2_0_monotonic_clock_resolution(void);
// Create a `pollable` which will resolve once the specified instant
// occured.
extern wasi_clocks_0_2_0_monotonic_clock_own_pollable_t
wasi_clocks_0_2_0_monotonic_clock_subscribe_instant(
    wasi_clocks_0_2_0_monotonic_clock_instant_t when);
// Create a `pollable` which will resolve once the given duration has
// elapsed, starting at the time at which this function was called.
// occured.
extern wasi_clocks_0_2_0_monotonic_clock_own_pollable_t
wasi_clocks_0_2_0_monotonic_clock_subscribe_duration(
    wasi_clocks_0_2_0_monotonic_clock_duration_t when);

// Imported Functions from `wasi:clocks/wall-clock@0.2.0`
// Read the current value of the clock.
//
// This clock is not monotonic, therefore calling this function repeatedly
// will not necessarily produce a sequence of non-decreasing values.
//
// The returned timestamps represent the number of seconds since
// 1970-01-01T00:00:00Z, also known as [POSIX's Seconds Since the Epoch],
// also known as [Unix Time].
//
// The nanoseconds field of the output is always less than 1000000000.
//
// [POSIX's Seconds Since the Epoch]:
// https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_xbd_chap04.html#tag_21_04_16 [Unix
// Time]: https://en.wikipedia.org/wiki/Unix_time
extern void wasi_clocks_0_2_0_wall_clock_now(wasi_clocks_0_2_0_wall_clock_datetime_t *ret);
// Query the resolution of the clock.
//
// The nanoseconds field of the output is always less than 1000000000.
extern void wasi_clocks_0_2_0_wall_clock_resolution(wasi_clocks_0_2_0_wall_clock_datetime_t *ret);

// Imported Functions from `wasi:filesystem/types@0.2.0`
// Return a stream for reading from a file, if available.
//
// May fail with an error-code describing why the file cannot be read.
//
// Multiple read, write, and append streams may be active on the same open
// file and they do not interfere with each other.
//
// Note: This allows using `read-stream`, which is similar to `read` in POSIX.
extern bool wasi_filesystem_0_2_0_types_method_descriptor_read_via_stream(
    wasi_filesystem_0_2_0_types_borrow_descriptor_t self,
    wasi_filesystem_0_2_0_types_filesize_t offset,
    wasi_filesystem_0_2_0_types_own_input_stream_t *ret,
    wasi_filesystem_0_2_0_types_error_code_t *err);
// Return a stream for writing to a file, if available.
//
// May fail with an error-code describing why the file cannot be written.
//
// Note: This allows using `write-stream`, which is similar to `write` in
// POSIX.
extern bool wasi_filesystem_0_2_0_types_method_descriptor_write_via_stream(
    wasi_filesystem_0_2_0_types_borrow_descriptor_t self,
    wasi_filesystem_0_2_0_types_filesize_t offset,
    wasi_filesystem_0_2_0_types_own_output_stream_t *ret,
    wasi_filesystem_0_2_0_types_error_code_t *err);
// Return a stream for appending to a file, if available.
//
// May fail with an error-code describing why the file cannot be appended.
//
// Note: This allows using `write-stream`, which is similar to `write` with
// `O_APPEND` in in POSIX.
extern bool wasi_filesystem_0_2_0_types_method_descriptor_append_via_stream(
    wasi_filesystem_0_2_0_types_borrow_descriptor_t self,
    wasi_filesystem_0_2_0_types_own_output_stream_t *ret,
    wasi_filesystem_0_2_0_types_error_code_t *err);
// Provide file advisory information on a descriptor.
//
// This is similar to `posix_fadvise` in POSIX.
extern bool wasi_filesystem_0_2_0_types_method_descriptor_advise(
    wasi_filesystem_0_2_0_types_borrow_descriptor_t self,
    wasi_filesystem_0_2_0_types_filesize_t offset, wasi_filesystem_0_2_0_types_filesize_t length,
    wasi_filesystem_0_2_0_types_advice_t advice, wasi_filesystem_0_2_0_types_error_code_t *err);
// Synchronize the data of a file to disk.
//
// This function succeeds with no effect if the file descriptor is not
// opened for writing.
//
// Note: This is similar to `fdatasync` in POSIX.
extern bool wasi_filesystem_0_2_0_types_method_descriptor_sync_data(
    wasi_filesystem_0_2_0_types_borrow_descriptor_t self,
    wasi_filesystem_0_2_0_types_error_code_t *err);
// Get flags associated with a descriptor.
//
// Note: This returns similar flags to `fcntl(fd, F_GETFL)` in POSIX.
//
// Note: This returns the value that was the `fs_flags` value returned
// from `fdstat_get` in earlier versions of WASI.
extern bool wasi_filesystem_0_2_0_types_method_descriptor_get_flags(
    wasi_filesystem_0_2_0_types_borrow_descriptor_t self,
    wasi_filesystem_0_2_0_types_descriptor_flags_t *ret,
    wasi_filesystem_0_2_0_types_error_code_t *err);
// Get the dynamic type of a descriptor.
//
// Note: This returns the same value as the `type` field of the `fd-stat`
// returned by `stat`, `stat-at` and similar.
//
// Note: This returns similar flags to the `st_mode & S_IFMT` value provided
// by `fstat` in POSIX.
//
// Note: This returns the value that was the `fs_filetype` value returned
// from `fdstat_get` in earlier versions of WASI.
extern bool wasi_filesystem_0_2_0_types_method_descriptor_get_type(
    wasi_filesystem_0_2_0_types_borrow_descriptor_t self,
    wasi_filesystem_0_2_0_types_descriptor_type_t *ret,
    wasi_filesystem_0_2_0_types_error_code_t *err);
// Adjust the size of an open file. If this increases the file's size, the
// extra bytes are filled with zeros.
//
// Note: This was called `fd_filestat_set_size` in earlier versions of WASI.
extern bool wasi_filesystem_0_2_0_types_method_descriptor_set_size(
    wasi_filesystem_0_2_0_types_borrow_descriptor_t self,
    wasi_filesystem_0_2_0_types_filesize_t size, wasi_filesystem_0_2_0_types_error_code_t *err);
// Adjust the timestamps of an open file or directory.
//
// Note: This is similar to `futimens` in POSIX.
//
// Note: This was called `fd_filestat_set_times` in earlier versions of WASI.
extern bool wasi_filesystem_0_2_0_types_method_descriptor_set_times(
    wasi_filesystem_0_2_0_types_borrow_descriptor_t self,
    wasi_filesystem_0_2_0_types_new_timestamp_t *data_access_timestamp,
    wasi_filesystem_0_2_0_types_new_timestamp_t *data_modification_timestamp,
    wasi_filesystem_0_2_0_types_error_code_t *err);
// Read from a descriptor, without using and updating the descriptor's offset.
//
// This function returns a list of bytes containing the data that was
// read, along with a bool which, when true, indicates that the end of the
// file was reached. The returned list will contain up to `length` bytes; it
// may return fewer than requested, if the end of the file is reached or
// if the I/O operation is interrupted.
//
// In the future, this may change to return a `stream<u8, error-code>`.
//
// Note: This is similar to `pread` in POSIX.
extern bool wasi_filesystem_0_2_0_types_method_descriptor_read(
    wasi_filesystem_0_2_0_types_borrow_descriptor_t self,
    wasi_filesystem_0_2_0_types_filesize_t length, wasi_filesystem_0_2_0_types_filesize_t offset,
    wasi_filesystem_0_2_0_types_tuple2_list_u8_bool_t *ret,
    wasi_filesystem_0_2_0_types_error_code_t *err);
// Write to a descriptor, without using and updating the descriptor's offset.
//
// It is valid to write past the end of a file; the file is extended to the
// extent of the write, with bytes between the previous end and the start of
// the write set to zero.
//
// In the future, this may change to take a `stream<u8, error-code>`.
//
// Note: This is similar to `pwrite` in POSIX.
extern bool wasi_filesystem_0_2_0_types_method_descriptor_write(
    wasi_filesystem_0_2_0_types_borrow_descriptor_t self,
    wasi_filesystem_0_2_0_types_list_u8_t *buffer, wasi_filesystem_0_2_0_types_filesize_t offset,
    wasi_filesystem_0_2_0_types_filesize_t *ret, wasi_filesystem_0_2_0_types_error_code_t *err);
// Read directory entries from a directory.
//
// On filesystems where directories contain entries referring to themselves
// and their parents, often named `.` and `..` respectively, these entries
// are omitted.
//
// This always returns a new stream which starts at the beginning of the
// directory. Multiple streams may be active on the same directory, and they
// do not interfere with each other.
extern bool wasi_filesystem_0_2_0_types_method_descriptor_read_directory(
    wasi_filesystem_0_2_0_types_borrow_descriptor_t self,
    wasi_filesystem_0_2_0_types_own_directory_entry_stream_t *ret,
    wasi_filesystem_0_2_0_types_error_code_t *err);
// Synchronize the data and metadata of a file to disk.
//
// This function succeeds with no effect if the file descriptor is not
// opened for writing.
//
// Note: This is similar to `fsync` in POSIX.
extern bool wasi_filesystem_0_2_0_types_method_descriptor_sync(
    wasi_filesystem_0_2_0_types_borrow_descriptor_t self,
    wasi_filesystem_0_2_0_types_error_code_t *err);
// Create a directory.
//
// Note: This is similar to `mkdirat` in POSIX.
extern bool wasi_filesystem_0_2_0_types_method_descriptor_create_directory_at(
    wasi_filesystem_0_2_0_types_borrow_descriptor_t self, bindings_string_t *path,
    wasi_filesystem_0_2_0_types_error_code_t *err);
// Return the attributes of an open file or directory.
//
// Note: This is similar to `fstat` in POSIX, except that it does not return
// device and inode information. For testing whether two descriptors refer to
// the same underlying filesystem object, use `is-same-object`. To obtain
// additional data that can be used do determine whether a file has been
// modified, use `metadata-hash`.
//
// Note: This was called `fd_filestat_get` in earlier versions of WASI.
extern bool wasi_filesystem_0_2_0_types_method_descriptor_stat(
    wasi_filesystem_0_2_0_types_borrow_descriptor_t self,
    wasi_filesystem_0_2_0_types_descriptor_stat_t *ret,
    wasi_filesystem_0_2_0_types_error_code_t *err);
// Return the attributes of a file or directory.
//
// Note: This is similar to `fstatat` in POSIX, except that it does not
// return device and inode information. See the `stat` description for a
// discussion of alternatives.
//
// Note: This was called `path_filestat_get` in earlier versions of WASI.
extern bool wasi_filesystem_0_2_0_types_method_descriptor_stat_at(
    wasi_filesystem_0_2_0_types_borrow_descriptor_t self,
    wasi_filesystem_0_2_0_types_path_flags_t path_flags, bindings_string_t *path,
    wasi_filesystem_0_2_0_types_descriptor_stat_t *ret,
    wasi_filesystem_0_2_0_types_error_code_t *err);
// Adjust the timestamps of a file or directory.
//
// Note: This is similar to `utimensat` in POSIX.
//
// Note: This was called `path_filestat_set_times` in earlier versions of
// WASI.
extern bool wasi_filesystem_0_2_0_types_method_descriptor_set_times_at(
    wasi_filesystem_0_2_0_types_borrow_descriptor_t self,
    wasi_filesystem_0_2_0_types_path_flags_t path_flags, bindings_string_t *path,
    wasi_filesystem_0_2_0_types_new_timestamp_t *data_access_timestamp,
    wasi_filesystem_0_2_0_types_new_timestamp_t *data_modification_timestamp,
    wasi_filesystem_0_2_0_types_error_code_t *err);
// Create a hard link.
//
// Note: This is similar to `linkat` in POSIX.
extern bool wasi_filesystem_0_2_0_types_method_descriptor_link_at(
    wasi_filesystem_0_2_0_types_borrow_descriptor_t self,
    wasi_filesystem_0_2_0_types_path_flags_t old_path_flags, bindings_string_t *old_path,
    wasi_filesystem_0_2_0_types_borrow_descriptor_t new_descriptor, bindings_string_t *new_path,
    wasi_filesystem_0_2_0_types_error_code_t *err);
// Open a file or directory.
//
// The returned descriptor is not guaranteed to be the lowest-numbered
// descriptor not currently open/ it is randomized to prevent applications
// from depending on making assumptions about indexes, since this is
// error-prone in multi-threaded contexts. The returned descriptor is
// guaranteed to be less than 2**31.
//
// If `flags` contains `descriptor-flags::mutate-directory`, and the base
// descriptor doesn't have `descriptor-flags::mutate-directory` set,
// `open-at` fails with `error-code::read-only`.
//
// If `flags` contains `write` or `mutate-directory`, or `open-flags`
// contains `truncate` or `create`, and the base descriptor doesn't have
// `descriptor-flags::mutate-directory` set, `open-at` fails with
// `error-code::read-only`.
//
// Note: This is similar to `openat` in POSIX.
extern bool wasi_filesystem_0_2_0_types_method_descriptor_open_at(
    wasi_filesystem_0_2_0_types_borrow_descriptor_t self,
    wasi_filesystem_0_2_0_types_path_flags_t path_flags, bindings_string_t *path,
    wasi_filesystem_0_2_0_types_open_flags_t open_flags,
    wasi_filesystem_0_2_0_types_descriptor_flags_t flags,
    wasi_filesystem_0_2_0_types_own_descriptor_t *ret,
    wasi_filesystem_0_2_0_types_error_code_t *err);
// Read the contents of a symbolic link.
//
// If the contents contain an absolute or rooted path in the underlying
// filesystem, this function fails with `error-code::not-permitted`.
//
// Note: This is similar to `readlinkat` in POSIX.
extern bool wasi_filesystem_0_2_0_types_method_descriptor_readlink_at(
    wasi_filesystem_0_2_0_types_borrow_descriptor_t self, bindings_string_t *path,
    bindings_string_t *ret, wasi_filesystem_0_2_0_types_error_code_t *err);
// Remove a directory.
//
// Return `error-code::not-empty` if the directory is not empty.
//
// Note: This is similar to `unlinkat(fd, path, AT_REMOVEDIR)` in POSIX.
extern bool wasi_filesystem_0_2_0_types_method_descriptor_remove_directory_at(
    wasi_filesystem_0_2_0_types_borrow_descriptor_t self, bindings_string_t *path,
    wasi_filesystem_0_2_0_types_error_code_t *err);
// Rename a filesystem object.
//
// Note: This is similar to `renameat` in POSIX.
extern bool wasi_filesystem_0_2_0_types_method_descriptor_rename_at(
    wasi_filesystem_0_2_0_types_borrow_descriptor_t self, bindings_string_t *old_path,
    wasi_filesystem_0_2_0_types_borrow_descriptor_t new_descriptor, bindings_string_t *new_path,
    wasi_filesystem_0_2_0_types_error_code_t *err);
// Create a symbolic link (also known as a "symlink").
//
// If `old-path` starts with `/`, the function fails with
// `error-code::not-permitted`.
//
// Note: This is similar to `symlinkat` in POSIX.
extern bool wasi_filesystem_0_2_0_types_method_descriptor_symlink_at(
    wasi_filesystem_0_2_0_types_borrow_descriptor_t self, bindings_string_t *old_path,
    bindings_string_t *new_path, wasi_filesystem_0_2_0_types_error_code_t *err);
// Unlink a filesystem object that is not a directory.
//
// Return `error-code::is-directory` if the path refers to a directory.
// Note: This is similar to `unlinkat(fd, path, 0)` in POSIX.
extern bool wasi_filesystem_0_2_0_types_method_descriptor_unlink_file_at(
    wasi_filesystem_0_2_0_types_borrow_descriptor_t self, bindings_string_t *path,
    wasi_filesystem_0_2_0_types_error_code_t *err);
// Test whether two descriptors refer to the same filesystem object.
//
// In POSIX, this corresponds to testing whether the two descriptors have the
// same device (`st_dev`) and inode (`st_ino` or `d_ino`) numbers.
// wasi-filesystem does not expose device and inode numbers, so this function
// may be used instead.
extern bool wasi_filesystem_0_2_0_types_method_descriptor_is_same_object(
    wasi_filesystem_0_2_0_types_borrow_descriptor_t self,
    wasi_filesystem_0_2_0_types_borrow_descriptor_t other);
// Return a hash of the metadata associated with a filesystem object referred
// to by a descriptor.
//
// This returns a hash of the last-modification timestamp and file size, and
// may also include the inode number, device number, birth timestamp, and
// other metadata fields that may change when the file is modified or
// replaced. It may also include a secret value chosen by the
// implementation and not otherwise exposed.
//
// Implementations are encourated to provide the following properties:
//
// - If the file is not modified or replaced, the computed hash value should
// usually not change.
// - If the object is modified or replaced, the computed hash value should
// usually change.
// - The inputs to the hash should not be easily computable from the
// computed hash.
//
// However, none of these is required.
extern bool wasi_filesystem_0_2_0_types_method_descriptor_metadata_hash(
    wasi_filesystem_0_2_0_types_borrow_descriptor_t self,
    wasi_filesystem_0_2_0_types_metadata_hash_value_t *ret,
    wasi_filesystem_0_2_0_types_error_code_t *err);
// Return a hash of the metadata associated with a filesystem object referred
// to by a directory descriptor and a relative path.
//
// This performs the same hash computation as `metadata-hash`.
extern bool wasi_filesystem_0_2_0_types_method_descriptor_metadata_hash_at(
    wasi_filesystem_0_2_0_types_borrow_descriptor_t self,
    wasi_filesystem_0_2_0_types_path_flags_t path_flags, bindings_string_t *path,
    wasi_filesystem_0_2_0_types_metadata_hash_value_t *ret,
    wasi_filesystem_0_2_0_types_error_code_t *err);
// Read a single directory entry from a `directory-entry-stream`.
extern bool wasi_filesystem_0_2_0_types_method_directory_entry_stream_read_directory_entry(
    wasi_filesystem_0_2_0_types_borrow_directory_entry_stream_t self,
    wasi_filesystem_0_2_0_types_option_directory_entry_t *ret,
    wasi_filesystem_0_2_0_types_error_code_t *err);
// Attempts to extract a filesystem-related `error-code` from the stream
// `error` provided.
//
// Stream operations which return `stream-error::last-operation-failed`
// have a payload with more information about the operation that failed.
// This payload can be passed through to this function to see if there's
// filesystem-related information about the error to return.
//
// Note that this function is fallible because not all stream-related
// errors are filesystem-related errors.
extern bool
wasi_filesystem_0_2_0_types_filesystem_error_code(wasi_filesystem_0_2_0_types_borrow_error_t err_,
                                                  wasi_filesystem_0_2_0_types_error_code_t *ret);

// Imported Functions from `wasi:filesystem/preopens@0.2.0`
// Return the set of preopened directories, and their path.
extern void wasi_filesystem_0_2_0_preopens_get_directories(
    wasi_filesystem_0_2_0_preopens_list_tuple2_own_descriptor_string_t *ret);

// Imported Functions from `wasi:sockets/instance-network@0.2.0`
// Get a handle to the default network.
extern wasi_sockets_0_2_0_instance_network_own_network_t
wasi_sockets_0_2_0_instance_network_instance_network(void);

// Imported Functions from `wasi:sockets/udp@0.2.0`
// Bind the socket to a specific network on the provided IP address and port.
//
// If the IP address is zero (`0.0.0.0` in IPv4, `::` in IPv6), it is left to the implementation to
// decide which network interface(s) to bind to. If the port is zero, the socket will be bound to a
// random free port.
//
// Unlike in POSIX, this function is async. This enables interactive WASI hosts to inject permission
// prompts.
//
// # Typical `start` errors
// - `invalid-argument`:          The `local-address` has the wrong address family. (EAFNOSUPPORT,
// EFAULT on Windows)
// - `invalid-state`:             The socket is already bound. (EINVAL)
//
// # Typical `finish` errors
// - `address-in-use`:            No ephemeral ports available. (EADDRINUSE, ENOBUFS on Windows)
// - `address-in-use`:            Address is already in use. (EADDRINUSE)
// - `address-not-bindable`:      `local-address` is not an address that the `network` can bind to.
// (EADDRNOTAVAIL)
// - `not-in-progress`:           A `bind` operation is not in progress.
// - `would-block`:               Can't finish the operation, it is still in progress. (EWOULDBLOCK,
// EAGAIN)
//
// # References
// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/bind.html>
// - <https://man7.org/linux/man-pages/man2/bind.2.html>
// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-bind>
// - <https://man.freebsd.org/cgi/man.cgi?query=bind&sektion=2&format=html>
extern bool wasi_sockets_0_2_0_udp_method_udp_socket_start_bind(
    wasi_sockets_0_2_0_udp_borrow_udp_socket_t self,
    wasi_sockets_0_2_0_udp_borrow_network_t network,
    wasi_sockets_0_2_0_udp_ip_socket_address_t *local_address,
    wasi_sockets_0_2_0_udp_error_code_t *err);
extern bool wasi_sockets_0_2_0_udp_method_udp_socket_finish_bind(
    wasi_sockets_0_2_0_udp_borrow_udp_socket_t self, wasi_sockets_0_2_0_udp_error_code_t *err);
// Set up inbound & outbound communication channels, optionally to a specific peer.
//
// This function only changes the local socket configuration and does not generate any network
// traffic. On success, the `remote-address` of the socket is updated. The `local-address` may be
// updated as well, based on the best network path to `remote-address`.
//
// When a `remote-address` is provided, the returned streams are limited to communicating with that
// specific peer:
// - `send` can only be used to send to this destination.
// - `receive` will only return datagrams sent from the provided `remote-address`.
//
// This method may be called multiple times on the same socket to change its association, but
// only the most recently returned pair of streams will be operational. Implementations may trap if
// the streams returned by a previous invocation haven't been dropped yet before calling `stream`
// again.
//
// The POSIX equivalent in pseudo-code is:
// ```text
// if (was previously connected) {
// connect(s, AF_UNSPEC)
// }
// if (remote_address is Some) {
// connect(s, remote_address)
// }
// ```
//
// Unlike in POSIX, the socket must already be explicitly bound.
//
// # Typical errors
// - `invalid-argument`:          The `remote-address` has the wrong address family. (EAFNOSUPPORT)
// - `invalid-argument`:          `remote-address` is a non-IPv4-mapped IPv6 address, but the socket
// was bound to a specific IPv4-mapped IPv6 address. (or vice versa)
// - `invalid-argument`:          The IP address in `remote-address` is set to INADDR_ANY (`0.0.0.0`
// / `::`). (EDESTADDRREQ, EADDRNOTAVAIL)
// - `invalid-argument`:          The port in `remote-address` is set to 0. (EDESTADDRREQ,
// EADDRNOTAVAIL)
// - `invalid-state`:             The socket is not bound.
// - `address-in-use`:            Tried to perform an implicit bind, but there were no ephemeral
// ports available. (EADDRINUSE, EADDRNOTAVAIL on Linux, EAGAIN on BSD)
// - `remote-unreachable`:        The remote address is not reachable. (ECONNRESET, ENETRESET,
// EHOSTUNREACH, EHOSTDOWN, ENETUNREACH, ENETDOWN, ENONET)
// - `connection-refused`:        The connection was refused. (ECONNREFUSED)
//
// # References
// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/connect.html>
// - <https://man7.org/linux/man-pages/man2/connect.2.html>
// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-connect>
// - <https://man.freebsd.org/cgi/man.cgi?connect>
extern bool wasi_sockets_0_2_0_udp_method_udp_socket_stream(
    wasi_sockets_0_2_0_udp_borrow_udp_socket_t self,
    wasi_sockets_0_2_0_udp_ip_socket_address_t *maybe_remote_address,
    wasi_sockets_0_2_0_udp_tuple2_own_incoming_datagram_stream_own_outgoing_datagram_stream_t *ret,
    wasi_sockets_0_2_0_udp_error_code_t *err);
// Get the current bound address.
//
// POSIX mentions:
// > If the socket has not been bound to a local name, the value
// > stored in the object pointed to by `address` is unspecified.
//
// WASI is stricter and requires `local-address` to return `invalid-state` when the socket hasn't
// been bound yet.
//
// # Typical errors
// - `invalid-state`: The socket is not bound to any local address.
//
// # References
// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/getsockname.html>
// - <https://man7.org/linux/man-pages/man2/getsockname.2.html>
// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-getsockname>
// - <https://man.freebsd.org/cgi/man.cgi?getsockname>
extern bool wasi_sockets_0_2_0_udp_method_udp_socket_local_address(
    wasi_sockets_0_2_0_udp_borrow_udp_socket_t self,
    wasi_sockets_0_2_0_udp_ip_socket_address_t *ret, wasi_sockets_0_2_0_udp_error_code_t *err);
// Get the address the socket is currently streaming to.
//
// # Typical errors
// - `invalid-state`: The socket is not streaming to a specific remote address. (ENOTCONN)
//
// # References
// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/getpeername.html>
// - <https://man7.org/linux/man-pages/man2/getpeername.2.html>
// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-getpeername>
// - <https://man.freebsd.org/cgi/man.cgi?query=getpeername&sektion=2&n=1>
extern bool wasi_sockets_0_2_0_udp_method_udp_socket_remote_address(
    wasi_sockets_0_2_0_udp_borrow_udp_socket_t self,
    wasi_sockets_0_2_0_udp_ip_socket_address_t *ret, wasi_sockets_0_2_0_udp_error_code_t *err);
// Whether this is a IPv4 or IPv6 socket.
//
// Equivalent to the SO_DOMAIN socket option.
extern wasi_sockets_0_2_0_udp_ip_address_family_t
wasi_sockets_0_2_0_udp_method_udp_socket_address_family(
    wasi_sockets_0_2_0_udp_borrow_udp_socket_t self);
// Equivalent to the IP_TTL & IPV6_UNICAST_HOPS socket options.
//
// If the provided value is 0, an `invalid-argument` error is returned.
//
// # Typical errors
// - `invalid-argument`:     (set) The TTL value must be 1 or higher.
extern bool wasi_sockets_0_2_0_udp_method_udp_socket_unicast_hop_limit(
    wasi_sockets_0_2_0_udp_borrow_udp_socket_t self, uint8_t *ret,
    wasi_sockets_0_2_0_udp_error_code_t *err);
extern bool wasi_sockets_0_2_0_udp_method_udp_socket_set_unicast_hop_limit(
    wasi_sockets_0_2_0_udp_borrow_udp_socket_t self, uint8_t value,
    wasi_sockets_0_2_0_udp_error_code_t *err);
// The kernel buffer space reserved for sends/receives on this socket.
//
// If the provided value is 0, an `invalid-argument` error is returned.
// Any other value will never cause an error, but it might be silently clamped and/or rounded.
// I.e. after setting a value, reading the same setting back may return a different value.
//
// Equivalent to the SO_RCVBUF and SO_SNDBUF socket options.
//
// # Typical errors
// - `invalid-argument`:     (set) The provided value was 0.
extern bool wasi_sockets_0_2_0_udp_method_udp_socket_receive_buffer_size(
    wasi_sockets_0_2_0_udp_borrow_udp_socket_t self, uint64_t *ret,
    wasi_sockets_0_2_0_udp_error_code_t *err);
extern bool wasi_sockets_0_2_0_udp_method_udp_socket_set_receive_buffer_size(
    wasi_sockets_0_2_0_udp_borrow_udp_socket_t self, uint64_t value,
    wasi_sockets_0_2_0_udp_error_code_t *err);
extern bool wasi_sockets_0_2_0_udp_method_udp_socket_send_buffer_size(
    wasi_sockets_0_2_0_udp_borrow_udp_socket_t self, uint64_t *ret,
    wasi_sockets_0_2_0_udp_error_code_t *err);
extern bool wasi_sockets_0_2_0_udp_method_udp_socket_set_send_buffer_size(
    wasi_sockets_0_2_0_udp_borrow_udp_socket_t self, uint64_t value,
    wasi_sockets_0_2_0_udp_error_code_t *err);
// Create a `pollable` which will resolve once the socket is ready for I/O.
//
// Note: this function is here for WASI Preview2 only.
// It's planned to be removed when `future` is natively supported in Preview3.
extern wasi_sockets_0_2_0_udp_own_pollable_t
wasi_sockets_0_2_0_udp_method_udp_socket_subscribe(wasi_sockets_0_2_0_udp_borrow_udp_socket_t self);
// Receive messages on the socket.
//
// This function attempts to receive up to `max-results` datagrams on the socket without blocking.
// The returned list may contain fewer elements than requested, but never more.
//
// This function returns successfully with an empty list when either:
// - `max-results` is 0, or:
// - `max-results` is greater than 0, but no results are immediately available.
// This function never returns `error(would-block)`.
//
// # Typical errors
// - `remote-unreachable`: The remote address is not reachable. (ECONNRESET, ENETRESET on Windows,
// EHOSTUNREACH, EHOSTDOWN, ENETUNREACH, ENETDOWN, ENONET)
// - `connection-refused`: The connection was refused. (ECONNREFUSED)
//
// # References
// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/recvfrom.html>
// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/recvmsg.html>
// - <https://man7.org/linux/man-pages/man2/recv.2.html>
// - <https://man7.org/linux/man-pages/man2/recvmmsg.2.html>
// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-recv>
// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-recvfrom>
// - <https://learn.microsoft.com/en-us/previous-versions/windows/desktop/legacy/ms741687(v=vs.85)>
// - <https://man.freebsd.org/cgi/man.cgi?query=recv&sektion=2>
extern bool wasi_sockets_0_2_0_udp_method_incoming_datagram_stream_receive(
    wasi_sockets_0_2_0_udp_borrow_incoming_datagram_stream_t self, uint64_t max_results,
    wasi_sockets_0_2_0_udp_list_incoming_datagram_t *ret, wasi_sockets_0_2_0_udp_error_code_t *err);
// Create a `pollable` which will resolve once the stream is ready to receive again.
//
// Note: this function is here for WASI Preview2 only.
// It's planned to be removed when `future` is natively supported in Preview3.
extern wasi_sockets_0_2_0_udp_own_pollable_t
wasi_sockets_0_2_0_udp_method_incoming_datagram_stream_subscribe(
    wasi_sockets_0_2_0_udp_borrow_incoming_datagram_stream_t self);
// Check readiness for sending. This function never blocks.
//
// Returns the number of datagrams permitted for the next call to `send`,
// or an error. Calling `send` with more datagrams than this function has
// permitted will trap.
//
// When this function returns ok(0), the `subscribe` pollable will
// become ready when this function will report at least ok(1), or an
// error.
//
// Never returns `would-block`.
extern bool wasi_sockets_0_2_0_udp_method_outgoing_datagram_stream_check_send(
    wasi_sockets_0_2_0_udp_borrow_outgoing_datagram_stream_t self, uint64_t *ret,
    wasi_sockets_0_2_0_udp_error_code_t *err);
// Send messages on the socket.
//
// This function attempts to send all provided `datagrams` on the socket without blocking and
// returns how many messages were actually sent (or queued for sending). This function never
// returns `error(would-block)`. If none of the datagrams were able to be sent, `ok(0)` is returned.
//
// This function semantically behaves the same as iterating the `datagrams` list and sequentially
// sending each individual datagram until either the end of the list has been reached or the first
// error occurred. If at least one datagram has been sent successfully, this function never returns
// an error.
//
// If the input list is empty, the function returns `ok(0)`.
//
// Each call to `send` must be permitted by a preceding `check-send`. Implementations must trap if
// either `check-send` was not called or `datagrams` contains more items than `check-send`
// permitted.
//
// # Typical errors
// - `invalid-argument`:        The `remote-address` has the wrong address family. (EAFNOSUPPORT)
// - `invalid-argument`:        `remote-address` is a non-IPv4-mapped IPv6 address, but the socket
// was bound to a specific IPv4-mapped IPv6 address. (or vice versa)
// - `invalid-argument`:        The IP address in `remote-address` is set to INADDR_ANY (`0.0.0.0` /
// `::`). (EDESTADDRREQ, EADDRNOTAVAIL)
// - `invalid-argument`:        The port in `remote-address` is set to 0. (EDESTADDRREQ,
// EADDRNOTAVAIL)
// - `invalid-argument`:        The socket is in "connected" mode and `remote-address` is `some`
// value that does not match the address passed to `stream`. (EISCONN)
// - `invalid-argument`:        The socket is not "connected" and no value for `remote-address` was
// provided. (EDESTADDRREQ)
// - `remote-unreachable`:      The remote address is not reachable. (ECONNRESET, ENETRESET on
// Windows, EHOSTUNREACH, EHOSTDOWN, ENETUNREACH, ENETDOWN, ENONET)
// - `connection-refused`:      The connection was refused. (ECONNREFUSED)
// - `datagram-too-large`:      The datagram is too large. (EMSGSIZE)
//
// # References
// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/sendto.html>
// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/sendmsg.html>
// - <https://man7.org/linux/man-pages/man2/send.2.html>
// - <https://man7.org/linux/man-pages/man2/sendmmsg.2.html>
// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-send>
// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-sendto>
// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsasendmsg>
// - <https://man.freebsd.org/cgi/man.cgi?query=send&sektion=2>
extern bool wasi_sockets_0_2_0_udp_method_outgoing_datagram_stream_send(
    wasi_sockets_0_2_0_udp_borrow_outgoing_datagram_stream_t self,
    wasi_sockets_0_2_0_udp_list_outgoing_datagram_t *datagrams, uint64_t *ret,
    wasi_sockets_0_2_0_udp_error_code_t *err);
// Create a `pollable` which will resolve once the stream is ready to send again.
//
// Note: this function is here for WASI Preview2 only.
// It's planned to be removed when `future` is natively supported in Preview3.
extern wasi_sockets_0_2_0_udp_own_pollable_t
wasi_sockets_0_2_0_udp_method_outgoing_datagram_stream_subscribe(
    wasi_sockets_0_2_0_udp_borrow_outgoing_datagram_stream_t self);

// Imported Functions from `wasi:sockets/udp-create-socket@0.2.0`
// Create a new UDP socket.
//
// Similar to `socket(AF_INET or AF_INET6, SOCK_DGRAM, IPPROTO_UDP)` in POSIX.
//
// This function does not require a network capability handle. This is considered to be safe because
// at time of creation, the socket is not bound to any `network` yet. Up to the moment `bind` is
// called, the socket is effectively an in-memory configuration object, unable to communicate with
// the outside world.
//
// All sockets are non-blocking. Use the wasi-poll interface to block on asynchronous operations.
//
// # Typical errors
// - `not-supported`:     The specified `address-family` is not supported. (EAFNOSUPPORT)
// - `new-socket-limit`:  The new socket resource could not be created because of a system limit.
// (EMFILE, ENFILE)
//
// # References:
// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/socket.html>
// - <https://man7.org/linux/man-pages/man2/socket.2.html>
// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsasocketw>
// - <https://man.freebsd.org/cgi/man.cgi?query=socket&sektion=2>
extern bool wasi_sockets_0_2_0_udp_create_socket_create_udp_socket(
    wasi_sockets_0_2_0_udp_create_socket_ip_address_family_t address_family,
    wasi_sockets_0_2_0_udp_create_socket_own_udp_socket_t *ret,
    wasi_sockets_0_2_0_udp_create_socket_error_code_t *err);

// Imported Functions from `wasi:sockets/tcp@0.2.0`
// Bind the socket to a specific network on the provided IP address and port.
//
// If the IP address is zero (`0.0.0.0` in IPv4, `::` in IPv6), it is left to the implementation to
// decide which network interface(s) to bind to. If the TCP/UDP port is zero, the socket will be
// bound to a random free port.
//
// When a socket is not explicitly bound, the first invocation to a listen or connect operation will
// implicitly bind the socket.
//
// Unlike in POSIX, this function is async. This enables interactive WASI hosts to inject permission
// prompts.
//
// # Typical `start` errors
// - `invalid-argument`:          The `local-address` has the wrong address family. (EAFNOSUPPORT,
// EFAULT on Windows)
// - `invalid-argument`:          `local-address` is not a unicast address. (EINVAL)
// - `invalid-argument`:          `local-address` is an IPv4-mapped IPv6 address, but the socket has
// `ipv6-only` enabled. (EINVAL)
// - `invalid-state`:             The socket is already bound. (EINVAL)
//
// # Typical `finish` errors
// - `address-in-use`:            No ephemeral ports available. (EADDRINUSE, ENOBUFS on Windows)
// - `address-in-use`:            Address is already in use. (EADDRINUSE)
// - `address-not-bindable`:      `local-address` is not an address that the `network` can bind to.
// (EADDRNOTAVAIL)
// - `not-in-progress`:           A `bind` operation is not in progress.
// - `would-block`:               Can't finish the operation, it is still in progress. (EWOULDBLOCK,
// EAGAIN)
//
// # Implementors note
// When binding to a non-zero port, this bind operation shouldn't be affected by the TIME_WAIT
// state of a recently closed socket on the same local address (i.e. the SO_REUSEADDR socket
// option should be set implicitly on platforms that require it).
//
// # References
// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/bind.html>
// - <https://man7.org/linux/man-pages/man2/bind.2.html>
// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-bind>
// - <https://man.freebsd.org/cgi/man.cgi?query=bind&sektion=2&format=html>
extern bool wasi_sockets_0_2_0_tcp_method_tcp_socket_start_bind(
    wasi_sockets_0_2_0_tcp_borrow_tcp_socket_t self,
    wasi_sockets_0_2_0_tcp_borrow_network_t network,
    wasi_sockets_0_2_0_tcp_ip_socket_address_t *local_address,
    wasi_sockets_0_2_0_tcp_error_code_t *err);
extern bool wasi_sockets_0_2_0_tcp_method_tcp_socket_finish_bind(
    wasi_sockets_0_2_0_tcp_borrow_tcp_socket_t self, wasi_sockets_0_2_0_tcp_error_code_t *err);
// Connect to a remote endpoint.
//
// On success:
// - the socket is transitioned into the Connection state
// - a pair of streams is returned that can be used to read & write to the connection
//
// POSIX mentions:
// > If connect() fails, the state of the socket is unspecified. Conforming applications should
// > close the file descriptor and create a new socket before attempting to reconnect.
//
// WASI prescribes the following behavior:
// - If `connect` fails because an input/state validation error, the socket should remain usable.
// - If a connection was actually attempted but failed, the socket should become unusable for
// further network communication. Besides `drop`, any method after such a failure may return an
// error.
//
// # Typical `start` errors
// - `invalid-argument`:          The `remote-address` has the wrong address family. (EAFNOSUPPORT)
// - `invalid-argument`:          `remote-address` is not a unicast address. (EINVAL, ENETUNREACH on
// Linux, EAFNOSUPPORT on MacOS)
// - `invalid-argument`:          `remote-address` is an IPv4-mapped IPv6 address, but the socket
// has `ipv6-only` enabled. (EINVAL, EADDRNOTAVAIL on Illumos)
// - `invalid-argument`:          `remote-address` is a non-IPv4-mapped IPv6 address, but the socket
// was bound to a specific IPv4-mapped IPv6 address. (or vice versa)
// - `invalid-argument`:          The IP address in `remote-address` is set to INADDR_ANY (`0.0.0.0`
// / `::`). (EADDRNOTAVAIL on Windows)
// - `invalid-argument`:          The port in `remote-address` is set to 0. (EADDRNOTAVAIL on
// Windows)
// - `invalid-argument`:          The socket is already attached to a different network. The
// `network` passed to `connect` must be identical to the one passed to `bind`.
// - `invalid-state`:             The socket is already in the Connection state. (EISCONN)
// - `invalid-state`:             The socket is already in the Listener state. (EOPNOTSUPP, EINVAL
// on Windows)
//
// # Typical `finish` errors
// - `timeout`:                   Connection timed out. (ETIMEDOUT)
// - `connection-refused`:        The connection was forcefully rejected. (ECONNREFUSED)
// - `connection-reset`:          The connection was reset. (ECONNRESET)
// - `connection-aborted`:        The connection was aborted. (ECONNABORTED)
// - `remote-unreachable`:        The remote address is not reachable. (EHOSTUNREACH, EHOSTDOWN,
// ENETUNREACH, ENETDOWN, ENONET)
// - `address-in-use`:            Tried to perform an implicit bind, but there were no ephemeral
// ports available. (EADDRINUSE, EADDRNOTAVAIL on Linux, EAGAIN on BSD)
// - `not-in-progress`:           A `connect` operation is not in progress.
// - `would-block`:               Can't finish the operation, it is still in progress. (EWOULDBLOCK,
// EAGAIN)
//
// # References
// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/connect.html>
// - <https://man7.org/linux/man-pages/man2/connect.2.html>
// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-connect>
// - <https://man.freebsd.org/cgi/man.cgi?connect>
extern bool wasi_sockets_0_2_0_tcp_method_tcp_socket_start_connect(
    wasi_sockets_0_2_0_tcp_borrow_tcp_socket_t self,
    wasi_sockets_0_2_0_tcp_borrow_network_t network,
    wasi_sockets_0_2_0_tcp_ip_socket_address_t *remote_address,
    wasi_sockets_0_2_0_tcp_error_code_t *err);
extern bool wasi_sockets_0_2_0_tcp_method_tcp_socket_finish_connect(
    wasi_sockets_0_2_0_tcp_borrow_tcp_socket_t self,
    wasi_sockets_0_2_0_tcp_tuple2_own_input_stream_own_output_stream_t *ret,
    wasi_sockets_0_2_0_tcp_error_code_t *err);
// Start listening for new connections.
//
// Transitions the socket into the Listener state.
//
// Unlike POSIX:
// - this function is async. This enables interactive WASI hosts to inject permission prompts.
// - the socket must already be explicitly bound.
//
// # Typical `start` errors
// - `invalid-state`:             The socket is not bound to any local address. (EDESTADDRREQ)
// - `invalid-state`:             The socket is already in the Connection state. (EISCONN, EINVAL on
// BSD)
// - `invalid-state`:             The socket is already in the Listener state.
//
// # Typical `finish` errors
// - `address-in-use`:            Tried to perform an implicit bind, but there were no ephemeral
// ports available. (EADDRINUSE)
// - `not-in-progress`:           A `listen` operation is not in progress.
// - `would-block`:               Can't finish the operation, it is still in progress. (EWOULDBLOCK,
// EAGAIN)
//
// # References
// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/listen.html>
// - <https://man7.org/linux/man-pages/man2/listen.2.html>
// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-listen>
// - <https://man.freebsd.org/cgi/man.cgi?query=listen&sektion=2>
extern bool wasi_sockets_0_2_0_tcp_method_tcp_socket_start_listen(
    wasi_sockets_0_2_0_tcp_borrow_tcp_socket_t self, wasi_sockets_0_2_0_tcp_error_code_t *err);
extern bool wasi_sockets_0_2_0_tcp_method_tcp_socket_finish_listen(
    wasi_sockets_0_2_0_tcp_borrow_tcp_socket_t self, wasi_sockets_0_2_0_tcp_error_code_t *err);
// Accept a new client socket.
//
// The returned socket is bound and in the Connection state. The following properties are inherited
// from the listener socket:
// - `address-family`
// - `ipv6-only`
// - `keep-alive-enabled`
// - `keep-alive-idle-time`
// - `keep-alive-interval`
// - `keep-alive-count`
// - `hop-limit`
// - `receive-buffer-size`
// - `send-buffer-size`
//
// On success, this function returns the newly accepted client socket along with
// a pair of streams that can be used to read & write to the connection.
//
// # Typical errors
// - `invalid-state`:      Socket is not in the Listener state. (EINVAL)
// - `would-block`:        No pending connections at the moment. (EWOULDBLOCK, EAGAIN)
// - `connection-aborted`: An incoming connection was pending, but was terminated by the client
// before this listener could accept it. (ECONNABORTED)
// - `new-socket-limit`:   The new socket resource could not be created because of a system limit.
// (EMFILE, ENFILE)
//
// # References
// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/accept.html>
// - <https://man7.org/linux/man-pages/man2/accept.2.html>
// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-accept>
// - <https://man.freebsd.org/cgi/man.cgi?query=accept&sektion=2>
extern bool wasi_sockets_0_2_0_tcp_method_tcp_socket_accept(
    wasi_sockets_0_2_0_tcp_borrow_tcp_socket_t self,
    wasi_sockets_0_2_0_tcp_tuple3_own_tcp_socket_own_input_stream_own_output_stream_t *ret,
    wasi_sockets_0_2_0_tcp_error_code_t *err);
// Get the bound local address.
//
// POSIX mentions:
// > If the socket has not been bound to a local name, the value
// > stored in the object pointed to by `address` is unspecified.
//
// WASI is stricter and requires `local-address` to return `invalid-state` when the socket hasn't
// been bound yet.
//
// # Typical errors
// - `invalid-state`: The socket is not bound to any local address.
//
// # References
// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/getsockname.html>
// - <https://man7.org/linux/man-pages/man2/getsockname.2.html>
// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-getsockname>
// - <https://man.freebsd.org/cgi/man.cgi?getsockname>
extern bool wasi_sockets_0_2_0_tcp_method_tcp_socket_local_address(
    wasi_sockets_0_2_0_tcp_borrow_tcp_socket_t self,
    wasi_sockets_0_2_0_tcp_ip_socket_address_t *ret, wasi_sockets_0_2_0_tcp_error_code_t *err);
// Get the remote address.
//
// # Typical errors
// - `invalid-state`: The socket is not connected to a remote address. (ENOTCONN)
//
// # References
// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/getpeername.html>
// - <https://man7.org/linux/man-pages/man2/getpeername.2.html>
// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-getpeername>
// - <https://man.freebsd.org/cgi/man.cgi?query=getpeername&sektion=2&n=1>
extern bool wasi_sockets_0_2_0_tcp_method_tcp_socket_remote_address(
    wasi_sockets_0_2_0_tcp_borrow_tcp_socket_t self,
    wasi_sockets_0_2_0_tcp_ip_socket_address_t *ret, wasi_sockets_0_2_0_tcp_error_code_t *err);
// Whether the socket is listening for new connections.
//
// Equivalent to the SO_ACCEPTCONN socket option.
extern bool wasi_sockets_0_2_0_tcp_method_tcp_socket_is_listening(
    wasi_sockets_0_2_0_tcp_borrow_tcp_socket_t self);
// Whether this is a IPv4 or IPv6 socket.
//
// Equivalent to the SO_DOMAIN socket option.
extern wasi_sockets_0_2_0_tcp_ip_address_family_t
wasi_sockets_0_2_0_tcp_method_tcp_socket_address_family(
    wasi_sockets_0_2_0_tcp_borrow_tcp_socket_t self);
// Whether IPv4 compatibility (dual-stack) mode is disabled or not.
//
// Equivalent to the IPV6_V6ONLY socket option.
//
// # Typical errors
// - `invalid-state`:        (set) The socket is already bound.
// - `not-supported`:        (get/set) `this` socket is an IPv4 socket.
// - `not-supported`:        (set) Host does not support dual-stack sockets. (Implementations are
// not required to.)
extern bool
wasi_sockets_0_2_0_tcp_method_tcp_socket_ipv6_only(wasi_sockets_0_2_0_tcp_borrow_tcp_socket_t self,
                                                   bool *ret,
                                                   wasi_sockets_0_2_0_tcp_error_code_t *err);
extern bool wasi_sockets_0_2_0_tcp_method_tcp_socket_set_ipv6_only(
    wasi_sockets_0_2_0_tcp_borrow_tcp_socket_t self, bool value,
    wasi_sockets_0_2_0_tcp_error_code_t *err);
// Hints the desired listen queue size. Implementations are free to ignore this.
//
// If the provided value is 0, an `invalid-argument` error is returned.
// Any other value will never cause an error, but it might be silently clamped and/or rounded.
//
// # Typical errors
// - `not-supported`:        (set) The platform does not support changing the backlog size after the
// initial listen.
// - `invalid-argument`:     (set) The provided value was 0.
// - `invalid-state`:        (set) The socket is already in the Connection state.
extern bool wasi_sockets_0_2_0_tcp_method_tcp_socket_set_listen_backlog_size(
    wasi_sockets_0_2_0_tcp_borrow_tcp_socket_t self, uint64_t value,
    wasi_sockets_0_2_0_tcp_error_code_t *err);
// Enables or disables keepalive.
//
// The keepalive behavior can be adjusted using:
// - `keep-alive-idle-time`
// - `keep-alive-interval`
// - `keep-alive-count`
// These properties can be configured while `keep-alive-enabled` is false, but only come into effect
// when `keep-alive-enabled` is true.
//
// Equivalent to the SO_KEEPALIVE socket option.
extern bool wasi_sockets_0_2_0_tcp_method_tcp_socket_keep_alive_enabled(
    wasi_sockets_0_2_0_tcp_borrow_tcp_socket_t self, bool *ret,
    wasi_sockets_0_2_0_tcp_error_code_t *err);
extern bool wasi_sockets_0_2_0_tcp_method_tcp_socket_set_keep_alive_enabled(
    wasi_sockets_0_2_0_tcp_borrow_tcp_socket_t self, bool value,
    wasi_sockets_0_2_0_tcp_error_code_t *err);
// Amount of time the connection has to be idle before TCP starts sending keepalive packets.
//
// If the provided value is 0, an `invalid-argument` error is returned.
// Any other value will never cause an error, but it might be silently clamped and/or rounded.
// I.e. after setting a value, reading the same setting back may return a different value.
//
// Equivalent to the TCP_KEEPIDLE socket option. (TCP_KEEPALIVE on MacOS)
//
// # Typical errors
// - `invalid-argument`:     (set) The provided value was 0.
extern bool wasi_sockets_0_2_0_tcp_method_tcp_socket_keep_alive_idle_time(
    wasi_sockets_0_2_0_tcp_borrow_tcp_socket_t self, wasi_sockets_0_2_0_tcp_duration_t *ret,
    wasi_sockets_0_2_0_tcp_error_code_t *err);
extern bool wasi_sockets_0_2_0_tcp_method_tcp_socket_set_keep_alive_idle_time(
    wasi_sockets_0_2_0_tcp_borrow_tcp_socket_t self, wasi_sockets_0_2_0_tcp_duration_t value,
    wasi_sockets_0_2_0_tcp_error_code_t *err);
// The time between keepalive packets.
//
// If the provided value is 0, an `invalid-argument` error is returned.
// Any other value will never cause an error, but it might be silently clamped and/or rounded.
// I.e. after setting a value, reading the same setting back may return a different value.
//
// Equivalent to the TCP_KEEPINTVL socket option.
//
// # Typical errors
// - `invalid-argument`:     (set) The provided value was 0.
extern bool wasi_sockets_0_2_0_tcp_method_tcp_socket_keep_alive_interval(
    wasi_sockets_0_2_0_tcp_borrow_tcp_socket_t self, wasi_sockets_0_2_0_tcp_duration_t *ret,
    wasi_sockets_0_2_0_tcp_error_code_t *err);
extern bool wasi_sockets_0_2_0_tcp_method_tcp_socket_set_keep_alive_interval(
    wasi_sockets_0_2_0_tcp_borrow_tcp_socket_t self, wasi_sockets_0_2_0_tcp_duration_t value,
    wasi_sockets_0_2_0_tcp_error_code_t *err);
// The maximum amount of keepalive packets TCP should send before aborting the connection.
//
// If the provided value is 0, an `invalid-argument` error is returned.
// Any other value will never cause an error, but it might be silently clamped and/or rounded.
// I.e. after setting a value, reading the same setting back may return a different value.
//
// Equivalent to the TCP_KEEPCNT socket option.
//
// # Typical errors
// - `invalid-argument`:     (set) The provided value was 0.
extern bool wasi_sockets_0_2_0_tcp_method_tcp_socket_keep_alive_count(
    wasi_sockets_0_2_0_tcp_borrow_tcp_socket_t self, uint32_t *ret,
    wasi_sockets_0_2_0_tcp_error_code_t *err);
extern bool wasi_sockets_0_2_0_tcp_method_tcp_socket_set_keep_alive_count(
    wasi_sockets_0_2_0_tcp_borrow_tcp_socket_t self, uint32_t value,
    wasi_sockets_0_2_0_tcp_error_code_t *err);
// Equivalent to the IP_TTL & IPV6_UNICAST_HOPS socket options.
//
// If the provided value is 0, an `invalid-argument` error is returned.
//
// # Typical errors
// - `invalid-argument`:     (set) The TTL value must be 1 or higher.
// - `invalid-state`:        (set) The socket is already in the Connection state.
// - `invalid-state`:        (set) The socket is already in the Listener state.
extern bool
wasi_sockets_0_2_0_tcp_method_tcp_socket_hop_limit(wasi_sockets_0_2_0_tcp_borrow_tcp_socket_t self,
                                                   uint8_t *ret,
                                                   wasi_sockets_0_2_0_tcp_error_code_t *err);
extern bool wasi_sockets_0_2_0_tcp_method_tcp_socket_set_hop_limit(
    wasi_sockets_0_2_0_tcp_borrow_tcp_socket_t self, uint8_t value,
    wasi_sockets_0_2_0_tcp_error_code_t *err);
// The kernel buffer space reserved for sends/receives on this socket.
//
// If the provided value is 0, an `invalid-argument` error is returned.
// Any other value will never cause an error, but it might be silently clamped and/or rounded.
// I.e. after setting a value, reading the same setting back may return a different value.
//
// Equivalent to the SO_RCVBUF and SO_SNDBUF socket options.
//
// # Typical errors
// - `invalid-argument`:     (set) The provided value was 0.
// - `invalid-state`:        (set) The socket is already in the Connection state.
// - `invalid-state`:        (set) The socket is already in the Listener state.
extern bool wasi_sockets_0_2_0_tcp_method_tcp_socket_receive_buffer_size(
    wasi_sockets_0_2_0_tcp_borrow_tcp_socket_t self, uint64_t *ret,
    wasi_sockets_0_2_0_tcp_error_code_t *err);
extern bool wasi_sockets_0_2_0_tcp_method_tcp_socket_set_receive_buffer_size(
    wasi_sockets_0_2_0_tcp_borrow_tcp_socket_t self, uint64_t value,
    wasi_sockets_0_2_0_tcp_error_code_t *err);
extern bool wasi_sockets_0_2_0_tcp_method_tcp_socket_send_buffer_size(
    wasi_sockets_0_2_0_tcp_borrow_tcp_socket_t self, uint64_t *ret,
    wasi_sockets_0_2_0_tcp_error_code_t *err);
extern bool wasi_sockets_0_2_0_tcp_method_tcp_socket_set_send_buffer_size(
    wasi_sockets_0_2_0_tcp_borrow_tcp_socket_t self, uint64_t value,
    wasi_sockets_0_2_0_tcp_error_code_t *err);
// Create a `pollable` which will resolve once the socket is ready for I/O.
//
// Note: this function is here for WASI Preview2 only.
// It's planned to be removed when `future` is natively supported in Preview3.
extern wasi_sockets_0_2_0_tcp_own_pollable_t
wasi_sockets_0_2_0_tcp_method_tcp_socket_subscribe(wasi_sockets_0_2_0_tcp_borrow_tcp_socket_t self);
// Initiate a graceful shutdown.
//
// - receive: the socket is not expecting to receive any more data from the peer. All subsequent
// read operations on the `input-stream` associated with this socket will return an End Of Stream
// indication. Any data still in the receive queue at time of calling `shutdown` will be discarded.
// - send: the socket is not expecting to send any more data to the peer. All subsequent write
// operations on the `output-stream` associated with this socket will return an error.
// - both: same effect as receive & send combined.
//
// The shutdown function does not close (drop) the socket.
//
// # Typical errors
// - `invalid-state`: The socket is not in the Connection state. (ENOTCONN)
//
// # References
// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/shutdown.html>
// - <https://man7.org/linux/man-pages/man2/shutdown.2.html>
// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-shutdown>
// - <https://man.freebsd.org/cgi/man.cgi?query=shutdown&sektion=2>
extern bool wasi_sockets_0_2_0_tcp_method_tcp_socket_shutdown(
    wasi_sockets_0_2_0_tcp_borrow_tcp_socket_t self,
    wasi_sockets_0_2_0_tcp_shutdown_type_t shutdown_type, wasi_sockets_0_2_0_tcp_error_code_t *err);

// Imported Functions from `wasi:sockets/tcp-create-socket@0.2.0`
// Create a new TCP socket.
//
// Similar to `socket(AF_INET or AF_INET6, SOCK_STREAM, IPPROTO_TCP)` in POSIX.
//
// This function does not require a network capability handle. This is considered to be safe because
// at time of creation, the socket is not bound to any `network` yet. Up to the moment
// `bind`/`listen`/`connect` is called, the socket is effectively an in-memory configuration object,
// unable to communicate with the outside world.
//
// All sockets are non-blocking. Use the wasi-poll interface to block on asynchronous operations.
//
// # Typical errors
// - `not-supported`:     The specified `address-family` is not supported. (EAFNOSUPPORT)
// - `new-socket-limit`:  The new socket resource could not be created because of a system limit.
// (EMFILE, ENFILE)
//
// # References
// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/socket.html>
// - <https://man7.org/linux/man-pages/man2/socket.2.html>
// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsasocketw>
// - <https://man.freebsd.org/cgi/man.cgi?query=socket&sektion=2>
extern bool wasi_sockets_0_2_0_tcp_create_socket_create_tcp_socket(
    wasi_sockets_0_2_0_tcp_create_socket_ip_address_family_t address_family,
    wasi_sockets_0_2_0_tcp_create_socket_own_tcp_socket_t *ret,
    wasi_sockets_0_2_0_tcp_create_socket_error_code_t *err);

// Imported Functions from `wasi:sockets/ip-name-lookup@0.2.0`
// Resolve an internet host name to a list of IP addresses.
//
// Unicode domain names are automatically converted to ASCII using IDNA encoding.
// If the input is an IP address string, the address is parsed and returned
// as-is without making any external requests.
//
// See the wasi-socket proposal README.md for a comparison with getaddrinfo.
//
// This function never blocks. It either immediately fails or immediately
// returns successfully with a `resolve-address-stream` that can be used
// to (asynchronously) fetch the results.
//
// # Typical errors
// - `invalid-argument`: `name` is a syntactically invalid domain name or IP address.
//
// # References:
// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/getaddrinfo.html>
// - <https://man7.org/linux/man-pages/man3/getaddrinfo.3.html>
// - <https://learn.microsoft.com/en-us/windows/win32/api/ws2tcpip/nf-ws2tcpip-getaddrinfo>
// - <https://man.freebsd.org/cgi/man.cgi?query=getaddrinfo&sektion=3>
extern bool wasi_sockets_0_2_0_ip_name_lookup_resolve_addresses(
    wasi_sockets_0_2_0_ip_name_lookup_borrow_network_t network, bindings_string_t *name,
    wasi_sockets_0_2_0_ip_name_lookup_own_resolve_address_stream_t *ret,
    wasi_sockets_0_2_0_ip_name_lookup_error_code_t *err);
// Returns the next address from the resolver.
//
// This function should be called multiple times. On each call, it will
// return the next address in connection order preference. If all
// addresses have been exhausted, this function returns `none`.
//
// This function never returns IPv4-mapped IPv6 addresses.
//
// # Typical errors
// - `name-unresolvable`:          Name does not exist or has no suitable associated IP addresses.
// (EAI_NONAME, EAI_NODATA, EAI_ADDRFAMILY)
// - `temporary-resolver-failure`: A temporary failure in name resolution occurred. (EAI_AGAIN)
// - `permanent-resolver-failure`: A permanent failure in name resolution occurred. (EAI_FAIL)
// - `would-block`:                A result is not available yet. (EWOULDBLOCK, EAGAIN)
extern bool wasi_sockets_0_2_0_ip_name_lookup_method_resolve_address_stream_resolve_next_address(
    wasi_sockets_0_2_0_ip_name_lookup_borrow_resolve_address_stream_t self,
    wasi_sockets_0_2_0_ip_name_lookup_option_ip_address_t *ret,
    wasi_sockets_0_2_0_ip_name_lookup_error_code_t *err);
// Create a `pollable` which will resolve once the stream is ready for I/O.
//
// Note: this function is here for WASI Preview2 only.
// It's planned to be removed when `future` is natively supported in Preview3.
extern wasi_sockets_0_2_0_ip_name_lookup_own_pollable_t
wasi_sockets_0_2_0_ip_name_lookup_method_resolve_address_stream_subscribe(
    wasi_sockets_0_2_0_ip_name_lookup_borrow_resolve_address_stream_t self);

// Imported Functions from `wasi:random/random@0.2.0`
// Return `len` cryptographically-secure random or pseudo-random bytes.
//
// This function must produce data at least as cryptographically secure and
// fast as an adequately seeded cryptographically-secure pseudo-random
// number generator (CSPRNG). It must not block, from the perspective of
// the calling program, under any circumstances, including on the first
// request and on requests for numbers of bytes. The returned data must
// always be unpredictable.
//
// This function must always return fresh data. Deterministic environments
// must omit this function, rather than implementing it with deterministic
// data.
extern void wasi_random_0_2_0_random_get_random_bytes(uint64_t len,
                                                      wasi_random_0_2_0_random_list_u8_t *ret);
// Return a cryptographically-secure random or pseudo-random `u64` value.
//
// This function returns the same type of data as `get-random-bytes`,
// represented as a `u64`.
extern uint64_t wasi_random_0_2_0_random_get_random_u64(void);

// Imported Functions from `wasi:random/insecure@0.2.0`
// Return `len` insecure pseudo-random bytes.
//
// This function is not cryptographically secure. Do not use it for
// anything related to security.
//
// There are no requirements on the values of the returned bytes, however
// implementations are encouraged to return evenly distributed values with
// a long period.
extern void
wasi_random_0_2_0_insecure_get_insecure_random_bytes(uint64_t len,
                                                     wasi_random_0_2_0_random_list_u8_t *ret);
// Return an insecure pseudo-random `u64` value.
//
// This function returns the same type of pseudo-random data as
// `get-insecure-random-bytes`, represented as a `u64`.
extern uint64_t wasi_random_0_2_0_insecure_get_insecure_random_u64(void);

// Imported Functions from `wasi:random/insecure-seed@0.2.0`
// Return a 128-bit value that may contain a pseudo-random value.
//
// The returned value is not required to be computed from a CSPRNG, and may
// even be entirely deterministic. Host implementations are encouraged to
// provide pseudo-random values to any program exposed to
// attacker-controlled content, to enable DoS protection built into many
// languages' hash-map implementations.
//
// This function is intended to only be called once, by a source language
// to initialize Denial Of Service (DoS) protection in its hash-map
// implementation.
//
// # Expected future evolution
//
// This will likely be changed to a value import, to prevent it from being
// called multiple times and potentially used for purposes other than DoS
// protection.
extern void wasi_random_0_2_0_insecure_seed_insecure_seed(
    wasi_random_0_2_0_insecure_seed_tuple2_u64_u64_t *ret);

// Imported Functions from `wasi:http/types@0.2.0`
// Attempts to extract a http-related `error` from the wasi:io `error`
// provided.
//
// Stream operations which return
// `wasi:io/stream/stream-error::last-operation-failed` have a payload of
// type `wasi:io/error/error` with more information about the operation
// that failed. This payload can be passed through to this function to see
// if there's http-related information about the error to return.
//
// Note that this function is fallible because not all io-errors are
// http-related errors.
extern bool wasi_http_0_2_0_types_http_error_code(wasi_http_0_2_0_types_borrow_io_error_t err_,
                                                  wasi_http_0_2_0_types_error_code_t *ret);
// Construct an empty HTTP Fields.
//
// The resulting `fields` is mutable.
extern wasi_http_0_2_0_types_own_fields_t wasi_http_0_2_0_types_constructor_fields(void);
// Construct an HTTP Fields.
//
// The resulting `fields` is mutable.
//
// The list represents each key-value pair in the Fields. Keys
// which have multiple values are represented by multiple entries in this
// list with the same key.
//
// The tuple is a pair of the field key, represented as a string, and
// Value, represented as a list of bytes. In a valid Fields, all keys
// and values are valid UTF-8 strings. However, values are not always
// well-formed, so they are represented as a raw list of bytes.
//
// An error result will be returned if any header or value was
// syntactically invalid, or if a header was forbidden.
extern bool wasi_http_0_2_0_types_static_fields_from_list(
    wasi_http_0_2_0_types_list_tuple2_field_key_field_value_t *entries,
    wasi_http_0_2_0_types_own_fields_t *ret, wasi_http_0_2_0_types_header_error_t *err);
// Get all of the values corresponding to a key. If the key is not present
// in this `fields`, an empty list is returned. However, if the key is
// present but empty, this is represented by a list with one or more
// empty field-values present.
extern void wasi_http_0_2_0_types_method_fields_get(wasi_http_0_2_0_types_borrow_fields_t self,
                                                    wasi_http_0_2_0_types_field_key_t *name,
                                                    wasi_http_0_2_0_types_list_field_value_t *ret);
// Returns `true` when the key is present in this `fields`. If the key is
// syntactically invalid, `false` is returned.
extern bool wasi_http_0_2_0_types_method_fields_has(wasi_http_0_2_0_types_borrow_fields_t self,
                                                    wasi_http_0_2_0_types_field_key_t *name);
// Set all of the values for a key. Clears any existing values for that
// key, if they have been set.
//
// Fails with `header-error.immutable` if the `fields` are immutable.
extern bool wasi_http_0_2_0_types_method_fields_set(wasi_http_0_2_0_types_borrow_fields_t self,
                                                    wasi_http_0_2_0_types_field_key_t *name,
                                                    wasi_http_0_2_0_types_list_field_value_t *value,
                                                    wasi_http_0_2_0_types_header_error_t *err);
// Delete all values for a key. Does nothing if no values for the key
// exist.
//
// Fails with `header-error.immutable` if the `fields` are immutable.
extern bool wasi_http_0_2_0_types_method_fields_delete(wasi_http_0_2_0_types_borrow_fields_t self,
                                                       wasi_http_0_2_0_types_field_key_t *name,
                                                       wasi_http_0_2_0_types_header_error_t *err);
// Append a value for a key. Does not change or delete any existing
// values for that key.
//
// Fails with `header-error.immutable` if the `fields` are immutable.
extern bool wasi_http_0_2_0_types_method_fields_append(wasi_http_0_2_0_types_borrow_fields_t self,
                                                       wasi_http_0_2_0_types_field_key_t *name,
                                                       wasi_http_0_2_0_types_field_value_t *value,
                                                       wasi_http_0_2_0_types_header_error_t *err);
// Retrieve the full set of keys and values in the Fields. Like the
// constructor, the list represents each key-value pair.
//
// The outer list represents each key-value pair in the Fields. Keys
// which have multiple values are represented by multiple entries in this
// list with the same key.
extern void wasi_http_0_2_0_types_method_fields_entries(
    wasi_http_0_2_0_types_borrow_fields_t self,
    wasi_http_0_2_0_types_list_tuple2_field_key_field_value_t *ret);
// Make a deep copy of the Fields. Equivelant in behavior to calling the
// `fields` constructor on the return value of `entries`. The resulting
// `fields` is mutable.
extern wasi_http_0_2_0_types_own_fields_t
wasi_http_0_2_0_types_method_fields_clone(wasi_http_0_2_0_types_borrow_fields_t self);
// Returns the method of the incoming request.
extern void wasi_http_0_2_0_types_method_incoming_request_method(
    wasi_http_0_2_0_types_borrow_incoming_request_t self, wasi_http_0_2_0_types_method_t *ret);
// Returns the path with query parameters from the request, as a string.
extern bool wasi_http_0_2_0_types_method_incoming_request_path_with_query(
    wasi_http_0_2_0_types_borrow_incoming_request_t self, bindings_string_t *ret);
// Returns the protocol scheme from the request.
extern bool wasi_http_0_2_0_types_method_incoming_request_scheme(
    wasi_http_0_2_0_types_borrow_incoming_request_t self, wasi_http_0_2_0_types_scheme_t *ret);
// Returns the authority from the request, if it was present.
extern bool wasi_http_0_2_0_types_method_incoming_request_authority(
    wasi_http_0_2_0_types_borrow_incoming_request_t self, bindings_string_t *ret);
// Get the `headers` associated with the request.
//
// The returned `headers` resource is immutable: `set`, `append`, and
// `delete` operations will fail with `header-error.immutable`.
//
// The `headers` returned are a child resource: it must be dropped before
// the parent `incoming-request` is dropped. Dropping this
// `incoming-request` before all children are dropped will trap.
extern wasi_http_0_2_0_types_own_headers_t wasi_http_0_2_0_types_method_incoming_request_headers(
    wasi_http_0_2_0_types_borrow_incoming_request_t self);
// Gives the `incoming-body` associated with this request. Will only
// return success at most once, and subsequent calls will return error.
extern bool wasi_http_0_2_0_types_method_incoming_request_consume(
    wasi_http_0_2_0_types_borrow_incoming_request_t self,
    wasi_http_0_2_0_types_own_incoming_body_t *ret);
// Construct a new `outgoing-request` with a default `method` of `GET`, and
// `none` values for `path-with-query`, `scheme`, and `authority`.
//
// * `headers` is the HTTP Headers for the Request.
//
// It is possible to construct, or manipulate with the accessor functions
// below, an `outgoing-request` with an invalid combination of `scheme`
// and `authority`, or `headers` which are not permitted to be sent.
// It is the obligation of the `outgoing-handler.handle` implementation
// to reject invalid constructions of `outgoing-request`.
extern wasi_http_0_2_0_types_own_outgoing_request_t
wasi_http_0_2_0_types_constructor_outgoing_request(wasi_http_0_2_0_types_own_headers_t headers);
// Returns the resource corresponding to the outgoing Body for this
// Request.
//
// Returns success on the first call: the `outgoing-body` resource for
// this `outgoing-request` can be retrieved at most once. Subsequent
// calls will return error.
extern bool wasi_http_0_2_0_types_method_outgoing_request_body(
    wasi_http_0_2_0_types_borrow_outgoing_request_t self,
    wasi_http_0_2_0_types_own_outgoing_body_t *ret);
// Get the Method for the Request.
extern void wasi_http_0_2_0_types_method_outgoing_request_method(
    wasi_http_0_2_0_types_borrow_outgoing_request_t self, wasi_http_0_2_0_types_method_t *ret);
// Set the Method for the Request. Fails if the string present in a
// `method.other` argument is not a syntactically valid method.
extern bool wasi_http_0_2_0_types_method_outgoing_request_set_method(
    wasi_http_0_2_0_types_borrow_outgoing_request_t self, wasi_http_0_2_0_types_method_t *method);
// Get the combination of the HTTP Path and Query for the Request.
// When `none`, this represents an empty Path and empty Query.
extern bool wasi_http_0_2_0_types_method_outgoing_request_path_with_query(
    wasi_http_0_2_0_types_borrow_outgoing_request_t self, bindings_string_t *ret);
// Set the combination of the HTTP Path and Query for the Request.
// When `none`, this represents an empty Path and empty Query. Fails is the
// string given is not a syntactically valid path and query uri component.
extern bool wasi_http_0_2_0_types_method_outgoing_request_set_path_with_query(
    wasi_http_0_2_0_types_borrow_outgoing_request_t self, bindings_string_t *maybe_path_with_query);
// Get the HTTP Related Scheme for the Request. When `none`, the
// implementation may choose an appropriate default scheme.
extern bool wasi_http_0_2_0_types_method_outgoing_request_scheme(
    wasi_http_0_2_0_types_borrow_outgoing_request_t self, wasi_http_0_2_0_types_scheme_t *ret);
// Set the HTTP Related Scheme for the Request. When `none`, the
// implementation may choose an appropriate default scheme. Fails if the
// string given is not a syntactically valid uri scheme.
extern bool wasi_http_0_2_0_types_method_outgoing_request_set_scheme(
    wasi_http_0_2_0_types_borrow_outgoing_request_t self,
    wasi_http_0_2_0_types_scheme_t *maybe_scheme);
// Get the HTTP Authority for the Request. A value of `none` may be used
// with Related Schemes which do not require an Authority. The HTTP and
// HTTPS schemes always require an authority.
extern bool wasi_http_0_2_0_types_method_outgoing_request_authority(
    wasi_http_0_2_0_types_borrow_outgoing_request_t self, bindings_string_t *ret);
// Set the HTTP Authority for the Request. A value of `none` may be used
// with Related Schemes which do not require an Authority. The HTTP and
// HTTPS schemes always require an authority. Fails if the string given is
// not a syntactically valid uri authority.
extern bool wasi_http_0_2_0_types_method_outgoing_request_set_authority(
    wasi_http_0_2_0_types_borrow_outgoing_request_t self, bindings_string_t *maybe_authority);
// Get the headers associated with the Request.
//
// The returned `headers` resource is immutable: `set`, `append`, and
// `delete` operations will fail with `header-error.immutable`.
//
// This headers resource is a child: it must be dropped before the parent
// `outgoing-request` is dropped, or its ownership is transfered to
// another component by e.g. `outgoing-handler.handle`.
extern wasi_http_0_2_0_types_own_headers_t wasi_http_0_2_0_types_method_outgoing_request_headers(
    wasi_http_0_2_0_types_borrow_outgoing_request_t self);
// Construct a default `request-options` value.
extern wasi_http_0_2_0_types_own_request_options_t
wasi_http_0_2_0_types_constructor_request_options(void);
// The timeout for the initial connect to the HTTP Server.
extern bool wasi_http_0_2_0_types_method_request_options_connect_timeout(
    wasi_http_0_2_0_types_borrow_request_options_t self, wasi_http_0_2_0_types_duration_t *ret);
// Set the timeout for the initial connect to the HTTP Server. An error
// return value indicates that this timeout is not supported.
extern bool wasi_http_0_2_0_types_method_request_options_set_connect_timeout(
    wasi_http_0_2_0_types_borrow_request_options_t self,
    wasi_http_0_2_0_types_duration_t *maybe_duration);
// The timeout for receiving the first byte of the Response body.
extern bool wasi_http_0_2_0_types_method_request_options_first_byte_timeout(
    wasi_http_0_2_0_types_borrow_request_options_t self, wasi_http_0_2_0_types_duration_t *ret);
// Set the timeout for receiving the first byte of the Response body. An
// error return value indicates that this timeout is not supported.
extern bool wasi_http_0_2_0_types_method_request_options_set_first_byte_timeout(
    wasi_http_0_2_0_types_borrow_request_options_t self,
    wasi_http_0_2_0_types_duration_t *maybe_duration);
// The timeout for receiving subsequent chunks of bytes in the Response
// body stream.
extern bool wasi_http_0_2_0_types_method_request_options_between_bytes_timeout(
    wasi_http_0_2_0_types_borrow_request_options_t self, wasi_http_0_2_0_types_duration_t *ret);
// Set the timeout for receiving subsequent chunks of bytes in the Response
// body stream. An error return value indicates that this timeout is not
// supported.
extern bool wasi_http_0_2_0_types_method_request_options_set_between_bytes_timeout(
    wasi_http_0_2_0_types_borrow_request_options_t self,
    wasi_http_0_2_0_types_duration_t *maybe_duration);
// Set the value of the `response-outparam` to either send a response,
// or indicate an error.
//
// This method consumes the `response-outparam` to ensure that it is
// called at most once. If it is never called, the implementation
// will respond with an error.
//
// The user may provide an `error` to `response` to allow the
// implementation determine how to respond with an HTTP error response.
extern void wasi_http_0_2_0_types_static_response_outparam_set(
    wasi_http_0_2_0_types_own_response_outparam_t param,
    wasi_http_0_2_0_types_result_own_outgoing_response_error_code_t *response);
// Returns the status code from the incoming response.
extern wasi_http_0_2_0_types_status_code_t wasi_http_0_2_0_types_method_incoming_response_status(
    wasi_http_0_2_0_types_borrow_incoming_response_t self);
// Returns the headers from the incoming response.
//
// The returned `headers` resource is immutable: `set`, `append`, and
// `delete` operations will fail with `header-error.immutable`.
//
// This headers resource is a child: it must be dropped before the parent
// `incoming-response` is dropped.
extern wasi_http_0_2_0_types_own_headers_t wasi_http_0_2_0_types_method_incoming_response_headers(
    wasi_http_0_2_0_types_borrow_incoming_response_t self);
// Returns the incoming body. May be called at most once. Returns error
// if called additional times.
extern bool wasi_http_0_2_0_types_method_incoming_response_consume(
    wasi_http_0_2_0_types_borrow_incoming_response_t self,
    wasi_http_0_2_0_types_own_incoming_body_t *ret);
// Returns the contents of the body, as a stream of bytes.
//
// Returns success on first call: the stream representing the contents
// can be retrieved at most once. Subsequent calls will return error.
//
// The returned `input-stream` resource is a child: it must be dropped
// before the parent `incoming-body` is dropped, or consumed by
// `incoming-body.finish`.
//
// This invariant ensures that the implementation can determine whether
// the user is consuming the contents of the body, waiting on the
// `future-trailers` to be ready, or neither. This allows for network
// backpressure is to be applied when the user is consuming the body,
// and for that backpressure to not inhibit delivery of the trailers if
// the user does not read the entire body.
extern bool
wasi_http_0_2_0_types_method_incoming_body_stream(wasi_http_0_2_0_types_borrow_incoming_body_t self,
                                                  wasi_http_0_2_0_types_own_input_stream_t *ret);
// Takes ownership of `incoming-body`, and returns a `future-trailers`.
// This function will trap if the `input-stream` child is still alive.
extern wasi_http_0_2_0_types_own_future_trailers_t
wasi_http_0_2_0_types_static_incoming_body_finish(wasi_http_0_2_0_types_own_incoming_body_t this_);
// Returns a pollable which becomes ready when either the trailers have
// been received, or an error has occured. When this pollable is ready,
// the `get` method will return `some`.
extern wasi_http_0_2_0_types_own_pollable_t wasi_http_0_2_0_types_method_future_trailers_subscribe(
    wasi_http_0_2_0_types_borrow_future_trailers_t self);
// Returns the contents of the trailers, or an error which occured,
// once the future is ready.
//
// The outer `option` represents future readiness. Users can wait on this
// `option` to become `some` using the `subscribe` method.
//
// The outer `result` is used to retrieve the trailers or error at most
// once. It will be success on the first call in which the outer option
// is `some`, and error on subsequent calls.
//
// The inner `result` represents that either the HTTP Request or Response
// body, as well as any trailers, were received successfully, or that an
// error occured receiving them. The optional `trailers` indicates whether
// or not trailers were present in the body.
//
// When some `trailers` are returned by this method, the `trailers`
// resource is immutable, and a child. Use of the `set`, `append`, or
// `delete` methods will return an error, and the resource must be
// dropped before the parent `future-trailers` is dropped.
extern bool wasi_http_0_2_0_types_method_future_trailers_get(
    wasi_http_0_2_0_types_borrow_future_trailers_t self,
    wasi_http_0_2_0_types_result_result_option_own_trailers_error_code_void_t *ret);
// Construct an `outgoing-response`, with a default `status-code` of `200`.
// If a different `status-code` is needed, it must be set via the
// `set-status-code` method.
//
// * `headers` is the HTTP Headers for the Response.
extern wasi_http_0_2_0_types_own_outgoing_response_t
wasi_http_0_2_0_types_constructor_outgoing_response(wasi_http_0_2_0_types_own_headers_t headers);
// Get the HTTP Status Code for the Response.
extern wasi_http_0_2_0_types_status_code_t
wasi_http_0_2_0_types_method_outgoing_response_status_code(
    wasi_http_0_2_0_types_borrow_outgoing_response_t self);
// Set the HTTP Status Code for the Response. Fails if the status-code
// given is not a valid http status code.
extern bool wasi_http_0_2_0_types_method_outgoing_response_set_status_code(
    wasi_http_0_2_0_types_borrow_outgoing_response_t self,
    wasi_http_0_2_0_types_status_code_t status_code);
// Get the headers associated with the Request.
//
// The returned `headers` resource is immutable: `set`, `append`, and
// `delete` operations will fail with `header-error.immutable`.
//
// This headers resource is a child: it must be dropped before the parent
// `outgoing-request` is dropped, or its ownership is transfered to
// another component by e.g. `outgoing-handler.handle`.
extern wasi_http_0_2_0_types_own_headers_t wasi_http_0_2_0_types_method_outgoing_response_headers(
    wasi_http_0_2_0_types_borrow_outgoing_response_t self);
// Returns the resource corresponding to the outgoing Body for this Response.
//
// Returns success on the first call: the `outgoing-body` resource for
// this `outgoing-response` can be retrieved at most once. Subsequent
// calls will return error.
extern bool wasi_http_0_2_0_types_method_outgoing_response_body(
    wasi_http_0_2_0_types_borrow_outgoing_response_t self,
    wasi_http_0_2_0_types_own_outgoing_body_t *ret);
// Returns a stream for writing the body contents.
//
// The returned `output-stream` is a child resource: it must be dropped
// before the parent `outgoing-body` resource is dropped (or finished),
// otherwise the `outgoing-body` drop or `finish` will trap.
//
// Returns success on the first call: the `output-stream` resource for
// this `outgoing-body` may be retrieved at most once. Subsequent calls
// will return error.
extern bool
wasi_http_0_2_0_types_method_outgoing_body_write(wasi_http_0_2_0_types_borrow_outgoing_body_t self,
                                                 wasi_http_0_2_0_types_own_output_stream_t *ret);
// Finalize an outgoing body, optionally providing trailers. This must be
// called to signal that the response is complete. If the `outgoing-body`
// is dropped without calling `outgoing-body.finalize`, the implementation
// should treat the body as corrupted.
//
// Fails if the body's `outgoing-request` or `outgoing-response` was
// constructed with a Content-Length header, and the contents written
// to the body (via `write`) does not match the value given in the
// Content-Length.
extern bool wasi_http_0_2_0_types_static_outgoing_body_finish(
    wasi_http_0_2_0_types_own_outgoing_body_t this_,
    wasi_http_0_2_0_types_own_trailers_t *maybe_trailers, wasi_http_0_2_0_types_error_code_t *err);
// Returns a pollable which becomes ready when either the Response has
// been received, or an error has occured. When this pollable is ready,
// the `get` method will return `some`.
extern wasi_http_0_2_0_types_own_pollable_t
wasi_http_0_2_0_types_method_future_incoming_response_subscribe(
    wasi_http_0_2_0_types_borrow_future_incoming_response_t self);
// Returns the incoming HTTP Response, or an error, once one is ready.
//
// The outer `option` represents future readiness. Users can wait on this
// `option` to become `some` using the `subscribe` method.
//
// The outer `result` is used to retrieve the response or error at most
// once. It will be success on the first call in which the outer option
// is `some`, and error on subsequent calls.
//
// The inner `result` represents that either the incoming HTTP Response
// status and headers have recieved successfully, or that an error
// occured. Errors may also occur while consuming the response body,
// but those will be reported by the `incoming-body` and its
// `output-stream` child.
extern bool wasi_http_0_2_0_types_method_future_incoming_response_get(
    wasi_http_0_2_0_types_borrow_future_incoming_response_t self,
    wasi_http_0_2_0_types_result_result_own_incoming_response_error_code_void_t *ret);

// Imported Functions from `wasi:http/outgoing-handler@0.2.0`
// This function is invoked with an outgoing HTTP Request, and it returns
// a resource `future-incoming-response` which represents an HTTP Response
// which may arrive in the future.
//
// The `options` argument accepts optional parameters for the HTTP
// protocol's transport layer.
//
// This function may return an error if the `outgoing-request` is invalid
// or not allowed to be made. Otherwise, protocol errors are reported
// through the `future-incoming-response`.
extern bool wasi_http_0_2_0_outgoing_handler_handle(
    wasi_http_0_2_0_outgoing_handler_own_outgoing_request_t request,
    wasi_http_0_2_0_outgoing_handler_own_request_options_t *maybe_options,
    wasi_http_0_2_0_outgoing_handler_own_future_incoming_response_t *ret,
    wasi_http_0_2_0_outgoing_handler_error_code_t *err);

// Exported Functions from `wasi:cli/run@0.2.0`
bool exports_wasi_cli_0_2_0_run_run(void);

// Exported Functions from `wasi:http/incoming-handler@0.2.0`
void exports_wasi_http_0_2_0_incoming_handler_handle(
    exports_wasi_http_0_2_0_incoming_handler_own_incoming_request_t request,
    exports_wasi_http_0_2_0_incoming_handler_own_response_outparam_t response_out);

// Helper Functions

void wasi_cli_0_2_0_environment_tuple2_string_string_free(
    wasi_cli_0_2_0_environment_tuple2_string_string_t *ptr);

void wasi_cli_0_2_0_environment_list_tuple2_string_string_free(
    wasi_cli_0_2_0_environment_list_tuple2_string_string_t *ptr);

void wasi_cli_0_2_0_environment_list_string_free(wasi_cli_0_2_0_environment_list_string_t *ptr);

void wasi_cli_0_2_0_environment_option_string_free(wasi_cli_0_2_0_environment_option_string_t *ptr);

void wasi_cli_0_2_0_exit_result_void_void_free(wasi_cli_0_2_0_exit_result_void_void_t *ptr);

extern void wasi_io_0_2_0_error_error_drop_own(wasi_io_0_2_0_error_own_error_t handle);
extern void wasi_io_0_2_0_error_error_drop_borrow(wasi_io_0_2_0_error_own_error_t handle);

extern wasi_io_0_2_0_error_borrow_error_t
wasi_io_0_2_0_error_borrow_error(wasi_io_0_2_0_error_own_error_t handle);

extern void wasi_io_0_2_0_poll_pollable_drop_own(wasi_io_0_2_0_poll_own_pollable_t handle);
extern void wasi_io_0_2_0_poll_pollable_drop_borrow(wasi_io_0_2_0_poll_own_pollable_t handle);

extern wasi_io_0_2_0_poll_borrow_pollable_t
wasi_io_0_2_0_poll_borrow_pollable(wasi_io_0_2_0_poll_own_pollable_t handle);

void wasi_io_0_2_0_poll_list_borrow_pollable_free(wasi_io_0_2_0_poll_list_borrow_pollable_t *ptr);

void wasi_io_0_2_0_poll_list_u32_free(wasi_io_0_2_0_poll_list_u32_t *ptr);

void wasi_io_0_2_0_streams_stream_error_free(wasi_io_0_2_0_streams_stream_error_t *ptr);

extern void
wasi_io_0_2_0_streams_input_stream_drop_own(wasi_io_0_2_0_streams_own_input_stream_t handle);
extern void
wasi_io_0_2_0_streams_input_stream_drop_borrow(wasi_io_0_2_0_streams_own_input_stream_t handle);

extern wasi_io_0_2_0_streams_borrow_input_stream_t
wasi_io_0_2_0_streams_borrow_input_stream(wasi_io_0_2_0_streams_own_input_stream_t handle);

extern void
wasi_io_0_2_0_streams_output_stream_drop_own(wasi_io_0_2_0_streams_own_output_stream_t handle);
extern void
wasi_io_0_2_0_streams_output_stream_drop_borrow(wasi_io_0_2_0_streams_own_output_stream_t handle);

extern wasi_io_0_2_0_streams_borrow_output_stream_t
wasi_io_0_2_0_streams_borrow_output_stream(wasi_io_0_2_0_streams_own_output_stream_t handle);

void wasi_io_0_2_0_streams_list_u8_free(wasi_io_0_2_0_streams_list_u8_t *ptr);

void wasi_io_0_2_0_streams_result_list_u8_stream_error_free(
    wasi_io_0_2_0_streams_result_list_u8_stream_error_t *ptr);

void wasi_io_0_2_0_streams_result_u64_stream_error_free(
    wasi_io_0_2_0_streams_result_u64_stream_error_t *ptr);

void wasi_io_0_2_0_streams_result_void_stream_error_free(
    wasi_io_0_2_0_streams_result_void_stream_error_t *ptr);

extern void wasi_cli_0_2_0_terminal_input_terminal_input_drop_own(
    wasi_cli_0_2_0_terminal_input_own_terminal_input_t handle);
extern void wasi_cli_0_2_0_terminal_input_terminal_input_drop_borrow(
    wasi_cli_0_2_0_terminal_input_own_terminal_input_t handle);

extern wasi_cli_0_2_0_terminal_input_borrow_terminal_input_t
wasi_cli_0_2_0_terminal_input_borrow_terminal_input(
    wasi_cli_0_2_0_terminal_input_own_terminal_input_t handle);

extern void wasi_cli_0_2_0_terminal_output_terminal_output_drop_own(
    wasi_cli_0_2_0_terminal_output_own_terminal_output_t handle);
extern void wasi_cli_0_2_0_terminal_output_terminal_output_drop_borrow(
    wasi_cli_0_2_0_terminal_output_own_terminal_output_t handle);

extern wasi_cli_0_2_0_terminal_output_borrow_terminal_output_t
wasi_cli_0_2_0_terminal_output_borrow_terminal_output(
    wasi_cli_0_2_0_terminal_output_own_terminal_output_t handle);

void wasi_cli_0_2_0_terminal_stdin_option_own_terminal_input_free(
    wasi_cli_0_2_0_terminal_stdin_option_own_terminal_input_t *ptr);

void wasi_cli_0_2_0_terminal_stdout_option_own_terminal_output_free(
    wasi_cli_0_2_0_terminal_stdout_option_own_terminal_output_t *ptr);

void wasi_cli_0_2_0_terminal_stderr_option_own_terminal_output_free(
    wasi_cli_0_2_0_terminal_stderr_option_own_terminal_output_t *ptr);

void wasi_filesystem_0_2_0_types_option_datetime_free(
    wasi_filesystem_0_2_0_types_option_datetime_t *ptr);

void wasi_filesystem_0_2_0_types_descriptor_stat_free(
    wasi_filesystem_0_2_0_types_descriptor_stat_t *ptr);

void wasi_filesystem_0_2_0_types_new_timestamp_free(
    wasi_filesystem_0_2_0_types_new_timestamp_t *ptr);

void wasi_filesystem_0_2_0_types_directory_entry_free(
    wasi_filesystem_0_2_0_types_directory_entry_t *ptr);

extern void wasi_filesystem_0_2_0_types_descriptor_drop_own(
    wasi_filesystem_0_2_0_types_own_descriptor_t handle);
extern void wasi_filesystem_0_2_0_types_descriptor_drop_borrow(
    wasi_filesystem_0_2_0_types_own_descriptor_t handle);

extern wasi_filesystem_0_2_0_types_borrow_descriptor_t
wasi_filesystem_0_2_0_types_borrow_descriptor(wasi_filesystem_0_2_0_types_own_descriptor_t handle);

extern void wasi_filesystem_0_2_0_types_directory_entry_stream_drop_own(
    wasi_filesystem_0_2_0_types_own_directory_entry_stream_t handle);
extern void wasi_filesystem_0_2_0_types_directory_entry_stream_drop_borrow(
    wasi_filesystem_0_2_0_types_own_directory_entry_stream_t handle);

extern wasi_filesystem_0_2_0_types_borrow_directory_entry_stream_t
wasi_filesystem_0_2_0_types_borrow_directory_entry_stream(
    wasi_filesystem_0_2_0_types_own_directory_entry_stream_t handle);

void wasi_filesystem_0_2_0_types_result_own_input_stream_error_code_free(
    wasi_filesystem_0_2_0_types_result_own_input_stream_error_code_t *ptr);

void wasi_filesystem_0_2_0_types_result_own_output_stream_error_code_free(
    wasi_filesystem_0_2_0_types_result_own_output_stream_error_code_t *ptr);

void wasi_filesystem_0_2_0_types_result_void_error_code_free(
    wasi_filesystem_0_2_0_types_result_void_error_code_t *ptr);

void wasi_filesystem_0_2_0_types_result_descriptor_flags_error_code_free(
    wasi_filesystem_0_2_0_types_result_descriptor_flags_error_code_t *ptr);

void wasi_filesystem_0_2_0_types_result_descriptor_type_error_code_free(
    wasi_filesystem_0_2_0_types_result_descriptor_type_error_code_t *ptr);

void wasi_filesystem_0_2_0_types_list_u8_free(wasi_filesystem_0_2_0_types_list_u8_t *ptr);

void wasi_filesystem_0_2_0_types_tuple2_list_u8_bool_free(
    wasi_filesystem_0_2_0_types_tuple2_list_u8_bool_t *ptr);

void wasi_filesystem_0_2_0_types_result_tuple2_list_u8_bool_error_code_free(
    wasi_filesystem_0_2_0_types_result_tuple2_list_u8_bool_error_code_t *ptr);

void wasi_filesystem_0_2_0_types_result_filesize_error_code_free(
    wasi_filesystem_0_2_0_types_result_filesize_error_code_t *ptr);

void wasi_filesystem_0_2_0_types_result_own_directory_entry_stream_error_code_free(
    wasi_filesystem_0_2_0_types_result_own_directory_entry_stream_error_code_t *ptr);

void wasi_filesystem_0_2_0_types_result_descriptor_stat_error_code_free(
    wasi_filesystem_0_2_0_types_result_descriptor_stat_error_code_t *ptr);

void wasi_filesystem_0_2_0_types_result_own_descriptor_error_code_free(
    wasi_filesystem_0_2_0_types_result_own_descriptor_error_code_t *ptr);

void wasi_filesystem_0_2_0_types_result_string_error_code_free(
    wasi_filesystem_0_2_0_types_result_string_error_code_t *ptr);

void wasi_filesystem_0_2_0_types_result_metadata_hash_value_error_code_free(
    wasi_filesystem_0_2_0_types_result_metadata_hash_value_error_code_t *ptr);

void wasi_filesystem_0_2_0_types_option_directory_entry_free(
    wasi_filesystem_0_2_0_types_option_directory_entry_t *ptr);

void wasi_filesystem_0_2_0_types_result_option_directory_entry_error_code_free(
    wasi_filesystem_0_2_0_types_result_option_directory_entry_error_code_t *ptr);

void wasi_filesystem_0_2_0_types_option_error_code_free(
    wasi_filesystem_0_2_0_types_option_error_code_t *ptr);

void wasi_filesystem_0_2_0_preopens_tuple2_own_descriptor_string_free(
    wasi_filesystem_0_2_0_preopens_tuple2_own_descriptor_string_t *ptr);

void wasi_filesystem_0_2_0_preopens_list_tuple2_own_descriptor_string_free(
    wasi_filesystem_0_2_0_preopens_list_tuple2_own_descriptor_string_t *ptr);

extern void
wasi_sockets_0_2_0_network_network_drop_own(wasi_sockets_0_2_0_network_own_network_t handle);
extern void
wasi_sockets_0_2_0_network_network_drop_borrow(wasi_sockets_0_2_0_network_own_network_t handle);

extern wasi_sockets_0_2_0_network_borrow_network_t
wasi_sockets_0_2_0_network_borrow_network(wasi_sockets_0_2_0_network_own_network_t handle);

void wasi_sockets_0_2_0_network_ip_address_free(wasi_sockets_0_2_0_network_ip_address_t *ptr);

void wasi_sockets_0_2_0_network_ip_socket_address_free(
    wasi_sockets_0_2_0_network_ip_socket_address_t *ptr);

void wasi_sockets_0_2_0_udp_ip_socket_address_free(wasi_sockets_0_2_0_udp_ip_socket_address_t *ptr);

void wasi_sockets_0_2_0_udp_list_u8_free(wasi_sockets_0_2_0_udp_list_u8_t *ptr);

void wasi_sockets_0_2_0_udp_incoming_datagram_free(wasi_sockets_0_2_0_udp_incoming_datagram_t *ptr);

void wasi_sockets_0_2_0_udp_option_ip_socket_address_free(
    wasi_sockets_0_2_0_udp_option_ip_socket_address_t *ptr);

void wasi_sockets_0_2_0_udp_outgoing_datagram_free(wasi_sockets_0_2_0_udp_outgoing_datagram_t *ptr);

extern void
wasi_sockets_0_2_0_udp_udp_socket_drop_own(wasi_sockets_0_2_0_udp_own_udp_socket_t handle);
extern void
wasi_sockets_0_2_0_udp_udp_socket_drop_borrow(wasi_sockets_0_2_0_udp_own_udp_socket_t handle);

extern wasi_sockets_0_2_0_udp_borrow_udp_socket_t
wasi_sockets_0_2_0_udp_borrow_udp_socket(wasi_sockets_0_2_0_udp_own_udp_socket_t handle);

extern void wasi_sockets_0_2_0_udp_incoming_datagram_stream_drop_own(
    wasi_sockets_0_2_0_udp_own_incoming_datagram_stream_t handle);
extern void wasi_sockets_0_2_0_udp_incoming_datagram_stream_drop_borrow(
    wasi_sockets_0_2_0_udp_own_incoming_datagram_stream_t handle);

extern wasi_sockets_0_2_0_udp_borrow_incoming_datagram_stream_t
wasi_sockets_0_2_0_udp_borrow_incoming_datagram_stream(
    wasi_sockets_0_2_0_udp_own_incoming_datagram_stream_t handle);

extern void wasi_sockets_0_2_0_udp_outgoing_datagram_stream_drop_own(
    wasi_sockets_0_2_0_udp_own_outgoing_datagram_stream_t handle);
extern void wasi_sockets_0_2_0_udp_outgoing_datagram_stream_drop_borrow(
    wasi_sockets_0_2_0_udp_own_outgoing_datagram_stream_t handle);

extern wasi_sockets_0_2_0_udp_borrow_outgoing_datagram_stream_t
wasi_sockets_0_2_0_udp_borrow_outgoing_datagram_stream(
    wasi_sockets_0_2_0_udp_own_outgoing_datagram_stream_t handle);

void wasi_sockets_0_2_0_udp_result_void_error_code_free(
    wasi_sockets_0_2_0_udp_result_void_error_code_t *ptr);

void wasi_sockets_0_2_0_udp_result_tuple2_own_incoming_datagram_stream_own_outgoing_datagram_stream_error_code_free(
    wasi_sockets_0_2_0_udp_result_tuple2_own_incoming_datagram_stream_own_outgoing_datagram_stream_error_code_t
        *ptr);

void wasi_sockets_0_2_0_udp_result_ip_socket_address_error_code_free(
    wasi_sockets_0_2_0_udp_result_ip_socket_address_error_code_t *ptr);

void wasi_sockets_0_2_0_udp_result_bool_error_code_free(
    wasi_sockets_0_2_0_udp_result_bool_error_code_t *ptr);

void wasi_sockets_0_2_0_udp_result_u8_error_code_free(
    wasi_sockets_0_2_0_udp_result_u8_error_code_t *ptr);

void wasi_sockets_0_2_0_udp_result_u64_error_code_free(
    wasi_sockets_0_2_0_udp_result_u64_error_code_t *ptr);

void wasi_sockets_0_2_0_udp_list_incoming_datagram_free(
    wasi_sockets_0_2_0_udp_list_incoming_datagram_t *ptr);

void wasi_sockets_0_2_0_udp_result_list_incoming_datagram_error_code_free(
    wasi_sockets_0_2_0_udp_result_list_incoming_datagram_error_code_t *ptr);

void wasi_sockets_0_2_0_udp_list_outgoing_datagram_free(
    wasi_sockets_0_2_0_udp_list_outgoing_datagram_t *ptr);

void wasi_sockets_0_2_0_udp_create_socket_result_own_udp_socket_error_code_free(
    wasi_sockets_0_2_0_udp_create_socket_result_own_udp_socket_error_code_t *ptr);

void wasi_sockets_0_2_0_tcp_ip_socket_address_free(wasi_sockets_0_2_0_tcp_ip_socket_address_t *ptr);

extern void
wasi_sockets_0_2_0_tcp_tcp_socket_drop_own(wasi_sockets_0_2_0_tcp_own_tcp_socket_t handle);
extern void
wasi_sockets_0_2_0_tcp_tcp_socket_drop_borrow(wasi_sockets_0_2_0_tcp_own_tcp_socket_t handle);

extern wasi_sockets_0_2_0_tcp_borrow_tcp_socket_t
wasi_sockets_0_2_0_tcp_borrow_tcp_socket(wasi_sockets_0_2_0_tcp_own_tcp_socket_t handle);

void wasi_sockets_0_2_0_tcp_result_void_error_code_free(
    wasi_sockets_0_2_0_tcp_result_void_error_code_t *ptr);

void wasi_sockets_0_2_0_tcp_result_tuple2_own_input_stream_own_output_stream_error_code_free(
    wasi_sockets_0_2_0_tcp_result_tuple2_own_input_stream_own_output_stream_error_code_t *ptr);

void wasi_sockets_0_2_0_tcp_result_tuple3_own_tcp_socket_own_input_stream_own_output_stream_error_code_free(
    wasi_sockets_0_2_0_tcp_result_tuple3_own_tcp_socket_own_input_stream_own_output_stream_error_code_t
        *ptr);

void wasi_sockets_0_2_0_tcp_result_ip_socket_address_error_code_free(
    wasi_sockets_0_2_0_tcp_result_ip_socket_address_error_code_t *ptr);

void wasi_sockets_0_2_0_tcp_result_bool_error_code_free(
    wasi_sockets_0_2_0_tcp_result_bool_error_code_t *ptr);

void wasi_sockets_0_2_0_tcp_result_duration_error_code_free(
    wasi_sockets_0_2_0_tcp_result_duration_error_code_t *ptr);

void wasi_sockets_0_2_0_tcp_result_u32_error_code_free(
    wasi_sockets_0_2_0_tcp_result_u32_error_code_t *ptr);

void wasi_sockets_0_2_0_tcp_result_u8_error_code_free(
    wasi_sockets_0_2_0_tcp_result_u8_error_code_t *ptr);

void wasi_sockets_0_2_0_tcp_result_u64_error_code_free(
    wasi_sockets_0_2_0_tcp_result_u64_error_code_t *ptr);

void wasi_sockets_0_2_0_tcp_create_socket_result_own_tcp_socket_error_code_free(
    wasi_sockets_0_2_0_tcp_create_socket_result_own_tcp_socket_error_code_t *ptr);

void wasi_sockets_0_2_0_ip_name_lookup_ip_address_free(
    wasi_sockets_0_2_0_ip_name_lookup_ip_address_t *ptr);

extern void wasi_sockets_0_2_0_ip_name_lookup_resolve_address_stream_drop_own(
    wasi_sockets_0_2_0_ip_name_lookup_own_resolve_address_stream_t handle);
extern void wasi_sockets_0_2_0_ip_name_lookup_resolve_address_stream_drop_borrow(
    wasi_sockets_0_2_0_ip_name_lookup_own_resolve_address_stream_t handle);

extern wasi_sockets_0_2_0_ip_name_lookup_borrow_resolve_address_stream_t
wasi_sockets_0_2_0_ip_name_lookup_borrow_resolve_address_stream(
    wasi_sockets_0_2_0_ip_name_lookup_own_resolve_address_stream_t handle);

void wasi_sockets_0_2_0_ip_name_lookup_result_own_resolve_address_stream_error_code_free(
    wasi_sockets_0_2_0_ip_name_lookup_result_own_resolve_address_stream_error_code_t *ptr);

void wasi_sockets_0_2_0_ip_name_lookup_option_ip_address_free(
    wasi_sockets_0_2_0_ip_name_lookup_option_ip_address_t *ptr);

void wasi_sockets_0_2_0_ip_name_lookup_result_option_ip_address_error_code_free(
    wasi_sockets_0_2_0_ip_name_lookup_result_option_ip_address_error_code_t *ptr);

void wasi_random_0_2_0_random_list_u8_free(wasi_random_0_2_0_random_list_u8_t *ptr);

void wasi_http_0_2_0_types_method_free(wasi_http_0_2_0_types_method_t *ptr);

void wasi_http_0_2_0_types_scheme_free(wasi_http_0_2_0_types_scheme_t *ptr);

void wasi_http_0_2_0_types_option_string_free(wasi_http_0_2_0_types_option_string_t *ptr);

void wasi_http_0_2_0_types_option_u16_free(wasi_http_0_2_0_types_option_u16_t *ptr);

void wasi_http_0_2_0_types_dns_error_payload_free(wasi_http_0_2_0_types_dns_error_payload_t *ptr);

void wasi_http_0_2_0_types_option_u8_free(wasi_http_0_2_0_types_option_u8_t *ptr);

void wasi_http_0_2_0_types_tls_alert_received_payload_free(
    wasi_http_0_2_0_types_tls_alert_received_payload_t *ptr);

void wasi_http_0_2_0_types_option_u32_free(wasi_http_0_2_0_types_option_u32_t *ptr);

void wasi_http_0_2_0_types_field_size_payload_free(wasi_http_0_2_0_types_field_size_payload_t *ptr);

void wasi_http_0_2_0_types_option_u64_free(wasi_http_0_2_0_types_option_u64_t *ptr);

void wasi_http_0_2_0_types_option_field_size_payload_free(
    wasi_http_0_2_0_types_option_field_size_payload_t *ptr);

void wasi_http_0_2_0_types_error_code_free(wasi_http_0_2_0_types_error_code_t *ptr);

void wasi_http_0_2_0_types_header_error_free(wasi_http_0_2_0_types_header_error_t *ptr);

void wasi_http_0_2_0_types_field_key_free(wasi_http_0_2_0_types_field_key_t *ptr);

void wasi_http_0_2_0_types_field_value_free(wasi_http_0_2_0_types_field_value_t *ptr);

extern void wasi_http_0_2_0_types_fields_drop_own(wasi_http_0_2_0_types_own_fields_t handle);
extern void wasi_http_0_2_0_types_fields_drop_borrow(wasi_http_0_2_0_types_own_fields_t handle);

extern wasi_http_0_2_0_types_borrow_fields_t
wasi_http_0_2_0_types_borrow_fields(wasi_http_0_2_0_types_own_fields_t handle);

extern void wasi_http_0_2_0_types_incoming_request_drop_own(
    wasi_http_0_2_0_types_own_incoming_request_t handle);
extern void wasi_http_0_2_0_types_incoming_request_drop_borrow(
    wasi_http_0_2_0_types_own_incoming_request_t handle);

extern wasi_http_0_2_0_types_borrow_incoming_request_t
wasi_http_0_2_0_types_borrow_incoming_request(wasi_http_0_2_0_types_own_incoming_request_t handle);

extern void wasi_http_0_2_0_types_outgoing_request_drop_own(
    wasi_http_0_2_0_types_own_outgoing_request_t handle);
extern void wasi_http_0_2_0_types_outgoing_request_drop_borrow(
    wasi_http_0_2_0_types_own_outgoing_request_t handle);

extern wasi_http_0_2_0_types_borrow_outgoing_request_t
wasi_http_0_2_0_types_borrow_outgoing_request(wasi_http_0_2_0_types_own_outgoing_request_t handle);

extern void
wasi_http_0_2_0_types_request_options_drop_own(wasi_http_0_2_0_types_own_request_options_t handle);
extern void wasi_http_0_2_0_types_request_options_drop_borrow(
    wasi_http_0_2_0_types_own_request_options_t handle);

extern wasi_http_0_2_0_types_borrow_request_options_t
wasi_http_0_2_0_types_borrow_request_options(wasi_http_0_2_0_types_own_request_options_t handle);

extern void wasi_http_0_2_0_types_response_outparam_drop_own(
    wasi_http_0_2_0_types_own_response_outparam_t handle);
extern void wasi_http_0_2_0_types_response_outparam_drop_borrow(
    wasi_http_0_2_0_types_own_response_outparam_t handle);

extern wasi_http_0_2_0_types_borrow_response_outparam_t
wasi_http_0_2_0_types_borrow_response_outparam(
    wasi_http_0_2_0_types_own_response_outparam_t handle);

extern void wasi_http_0_2_0_types_incoming_response_drop_own(
    wasi_http_0_2_0_types_own_incoming_response_t handle);
extern void wasi_http_0_2_0_types_incoming_response_drop_borrow(
    wasi_http_0_2_0_types_own_incoming_response_t handle);

extern wasi_http_0_2_0_types_borrow_incoming_response_t
wasi_http_0_2_0_types_borrow_incoming_response(
    wasi_http_0_2_0_types_own_incoming_response_t handle);

extern void
wasi_http_0_2_0_types_incoming_body_drop_own(wasi_http_0_2_0_types_own_incoming_body_t handle);
extern void
wasi_http_0_2_0_types_incoming_body_drop_borrow(wasi_http_0_2_0_types_own_incoming_body_t handle);

extern wasi_http_0_2_0_types_borrow_incoming_body_t
wasi_http_0_2_0_types_borrow_incoming_body(wasi_http_0_2_0_types_own_incoming_body_t handle);

extern void
wasi_http_0_2_0_types_future_trailers_drop_own(wasi_http_0_2_0_types_own_future_trailers_t handle);
extern void wasi_http_0_2_0_types_future_trailers_drop_borrow(
    wasi_http_0_2_0_types_own_future_trailers_t handle);

extern wasi_http_0_2_0_types_borrow_future_trailers_t
wasi_http_0_2_0_types_borrow_future_trailers(wasi_http_0_2_0_types_own_future_trailers_t handle);

extern void wasi_http_0_2_0_types_outgoing_response_drop_own(
    wasi_http_0_2_0_types_own_outgoing_response_t handle);
extern void wasi_http_0_2_0_types_outgoing_response_drop_borrow(
    wasi_http_0_2_0_types_own_outgoing_response_t handle);

extern wasi_http_0_2_0_types_borrow_outgoing_response_t
wasi_http_0_2_0_types_borrow_outgoing_response(
    wasi_http_0_2_0_types_own_outgoing_response_t handle);

extern void
wasi_http_0_2_0_types_outgoing_body_drop_own(wasi_http_0_2_0_types_own_outgoing_body_t handle);
extern void
wasi_http_0_2_0_types_outgoing_body_drop_borrow(wasi_http_0_2_0_types_own_outgoing_body_t handle);

extern wasi_http_0_2_0_types_borrow_outgoing_body_t
wasi_http_0_2_0_types_borrow_outgoing_body(wasi_http_0_2_0_types_own_outgoing_body_t handle);

extern void wasi_http_0_2_0_types_future_incoming_response_drop_own(
    wasi_http_0_2_0_types_own_future_incoming_response_t handle);
extern void wasi_http_0_2_0_types_future_incoming_response_drop_borrow(
    wasi_http_0_2_0_types_own_future_incoming_response_t handle);

extern wasi_http_0_2_0_types_borrow_future_incoming_response_t
wasi_http_0_2_0_types_borrow_future_incoming_response(
    wasi_http_0_2_0_types_own_future_incoming_response_t handle);

void wasi_http_0_2_0_types_option_error_code_free(wasi_http_0_2_0_types_option_error_code_t *ptr);

void wasi_http_0_2_0_types_tuple2_field_key_field_value_free(
    wasi_http_0_2_0_types_tuple2_field_key_field_value_t *ptr);

void wasi_http_0_2_0_types_list_tuple2_field_key_field_value_free(
    wasi_http_0_2_0_types_list_tuple2_field_key_field_value_t *ptr);

void wasi_http_0_2_0_types_result_own_fields_header_error_free(
    wasi_http_0_2_0_types_result_own_fields_header_error_t *ptr);

void wasi_http_0_2_0_types_list_field_value_free(wasi_http_0_2_0_types_list_field_value_t *ptr);

void wasi_http_0_2_0_types_result_void_header_error_free(
    wasi_http_0_2_0_types_result_void_header_error_t *ptr);

void wasi_http_0_2_0_types_option_scheme_free(wasi_http_0_2_0_types_option_scheme_t *ptr);

void wasi_http_0_2_0_types_result_own_incoming_body_void_free(
    wasi_http_0_2_0_types_result_own_incoming_body_void_t *ptr);

void wasi_http_0_2_0_types_result_own_outgoing_body_void_free(
    wasi_http_0_2_0_types_result_own_outgoing_body_void_t *ptr);

void wasi_http_0_2_0_types_result_void_void_free(wasi_http_0_2_0_types_result_void_void_t *ptr);

void wasi_http_0_2_0_types_option_duration_free(wasi_http_0_2_0_types_option_duration_t *ptr);

void wasi_http_0_2_0_types_result_own_outgoing_response_error_code_free(
    wasi_http_0_2_0_types_result_own_outgoing_response_error_code_t *ptr);

void wasi_http_0_2_0_types_result_own_input_stream_void_free(
    wasi_http_0_2_0_types_result_own_input_stream_void_t *ptr);

void wasi_http_0_2_0_types_option_own_trailers_free(
    wasi_http_0_2_0_types_option_own_trailers_t *ptr);

void wasi_http_0_2_0_types_result_option_own_trailers_error_code_free(
    wasi_http_0_2_0_types_result_option_own_trailers_error_code_t *ptr);

void wasi_http_0_2_0_types_result_result_option_own_trailers_error_code_void_free(
    wasi_http_0_2_0_types_result_result_option_own_trailers_error_code_void_t *ptr);

void wasi_http_0_2_0_types_option_result_result_option_own_trailers_error_code_void_free(
    wasi_http_0_2_0_types_option_result_result_option_own_trailers_error_code_void_t *ptr);

void wasi_http_0_2_0_types_result_own_output_stream_void_free(
    wasi_http_0_2_0_types_result_own_output_stream_void_t *ptr);

void wasi_http_0_2_0_types_result_void_error_code_free(
    wasi_http_0_2_0_types_result_void_error_code_t *ptr);

void wasi_http_0_2_0_types_result_own_incoming_response_error_code_free(
    wasi_http_0_2_0_types_result_own_incoming_response_error_code_t *ptr);

void wasi_http_0_2_0_types_result_result_own_incoming_response_error_code_void_free(
    wasi_http_0_2_0_types_result_result_own_incoming_response_error_code_void_t *ptr);

void wasi_http_0_2_0_types_option_result_result_own_incoming_response_error_code_void_free(
    wasi_http_0_2_0_types_option_result_result_own_incoming_response_error_code_void_t *ptr);

void wasi_http_0_2_0_outgoing_handler_error_code_free(
    wasi_http_0_2_0_outgoing_handler_error_code_t *ptr);

void wasi_http_0_2_0_outgoing_handler_option_own_request_options_free(
    wasi_http_0_2_0_outgoing_handler_option_own_request_options_t *ptr);

void wasi_http_0_2_0_outgoing_handler_result_own_future_incoming_response_error_code_free(
    wasi_http_0_2_0_outgoing_handler_result_own_future_incoming_response_error_code_t *ptr);

void exports_wasi_cli_0_2_0_run_result_void_void_free(
    exports_wasi_cli_0_2_0_run_result_void_void_t *ptr);

// Transfers ownership of `s` into the string `ret`
void bindings_string_set(bindings_string_t *ret, char *s);

// Creates a copy of the input nul-terminate string `s` and
// stores it into the component model string `ret`.
void bindings_string_dup(bindings_string_t *ret, const char *s);

// Deallocates the string pointed to by `ret`, deallocating
// the memory behind the string.
void bindings_string_free(bindings_string_t *ret);

#ifdef __cplusplus
}
#endif
#endif
