package fastly:compute-at-edge

interface types {
  // TODO: split this up into function-specific error enums
  enum error {
    /// Unknown error value.
    /// It should be an internal error if this is returned.
    unknown-error,
    /// Generic error value.
    /// This means that some unexpected error occurred during a hostcall.
    generic-error,
    /// Invalid argument.
    invalid-argument,
    /// Invalid handle.
    /// Thrown when a handle is not valid. E.G. No dictionary exists with the given name.
    bad-handle,
    /// Buffer length error.
    /// Thrown when a buffer is too long.
    buffer-len,
    /// Unsupported operation error.
    /// This error is thrown when some operation cannot be performed, because it is not supported.
    unsupported,
    /// Alignment error.
    /// This is thrown when a pointer does not point to a properly aligned slice of memory.
    bad-align,
    /// Invalid HTTP error.
    /// This can be thrown when a method, URI, header, or status is not valid. This can also
    /// be thrown if a message head is too large.
    http-invalid,
    /// HTTP user error.
    /// This is thrown in cases where user code caused an HTTP error. For example, attempt to send
    /// a 1xx response code, or a request with a non-absolute URI. This can also be caused by
    /// an unexpected header: both `content-length` and `transfer-encoding`, for example.
    http-user,
    /// HTTP incomplete message error.
    /// This can be thrown when a stream ended unexpectedly.
    http-incomplete,
    /// A `None` error.
    /// This status code is used to indicate when an optional value did not exist, as opposed to
    /// an empty value.
    /// Note, this value should no longer be used, as we have explicit optional types now.
    optional-none,
    /// Message head too large.
    http-head-too-large,
    /// Invalid HTTP status.
    http-invalid-status,
    /// Limit exceeded
    ///
    /// This is returned when an attempt to allocate a resource has exceeded the maximum number of
    /// resources permitted. For example, creating too many response handles.
    limit-exceeded
  }

  type body-handle = u32

  enum body-write-end {
    back,
    front
  }

  type secret-store-handle = u32

  type secret-handle = u32

  type fd = u32

  type object-store-handle = u32

  type dictionary-handle = u32

  type log-endpoint-handle = u32
}

interface fastly {
  use types.{error, body-handle}

  /*
   * Fastly ABI
   */
  abi-init: func(abi-version: u64) -> result<_, error>


  /*
   * Fastly UAP
   */
  record user-agent {
    family: string,
    major: string,
    minor: string,
    patch: string
  }

  uap-parse: func(user-agent: string) -> result<user-agent, error>


  /*
   * Fastly HTTP Req
   */
  type request-handle = u32
  type pending-request-handle = u32
  type response-handle = u32
  type request = tuple<request-handle, body-handle>
  type response = tuple<response-handle, body-handle>

  flags http-cache-override-tag {
      /// Do not cache the response to this request, regardless of the origin response's headers.
      pass,
      ttl,
      stale-while-revalidate,
      pci,
  }

  http-req-cache-override-set: func(h: request-handle, tag: http-cache-override-tag, ttl: option<u32>, stale-while-revalidate: option<u32>, sk: option<string>) -> result<_, error>

  http-req-downstream-client-ip-addr: func() -> result<list<u8>, error>

  http-req-downstream-client-h2-fingerprint: func() -> result<list<u8>, error>

  http-req-downstream-tls-cipher-openssl-name: func() -> result<string, error>

  http-req-downstream-tls-protocol: func() -> result<string, error>

  http-req-downstream-tls-client-hello: func() -> result<list<u8>, error>

  http-req-downstream-tls-raw-client-certificate: func() -> result<list<u8>, error>

  http-req-downstream-tls-client-cert-verify-result: func() -> result<_, error>

  http-req-downstream-tls-ja3-md5: func() -> result<list<u8>, error>

  http-req-new: func() -> result<request-handle, error>

  http-req-header-names-get: func(h: request-handle) -> result<list<string>, error>

  http-req-header-value-get: func(h: request-handle, name: string) -> result<option<string>, error>

  http-req-header-values-get: func(h: request-handle, name: string) -> result<option<list<string>>, error>

  http-req-header-values-set: func(h: request-handle, name: string, values: list<string>) -> result<_, error>

  http-req-header-insert: func(h: request-handle, name: string, value: string) -> result<_, error>

  http-req-header-append: func(h: request-handle, name: string, value: string) -> result<_, error>

  http-req-header-remove: func(h: request-handle, name: string) -> result<_, error>

  http-req-method-get: func(h: request-handle) -> result<string, error>

  http-req-method-set: func(h: request-handle, method: string) -> result<_, error>

  http-req-uri-get: func(h: request-handle) -> result<string, error>

  http-req-uri-set: func(h: request-handle, uri: string) -> result<_, error>

  enum http-version {
    http09,
    http10,
    http11,
    h2,
    h3
  }

  http-req-version-get: func(h: request-handle) -> result<http-version, error>

  http-req-version-set: func(h: request-handle, version: http-version) -> result<_, error>

  http-req-send: func(h: request-handle, b: body-handle, backend: string) -> result<response, error>

  http-req-send-async: func(h: request-handle, b: body-handle, backend: string) -> result<pending-request-handle, error>

  http-req-send-async-streaming: func(h: request-handle, b: body-handle, backend: string) -> result<pending-request-handle, error>

  http-req-pending-req-poll: func(h: pending-request-handle) -> result<option<response>, error>

  http-req-pending-req-wait: func(h: pending-request-handle) -> result<response, error>

  http-req-pending-req-select: func(h: list<pending-request-handle>) -> result<tuple<
    u32,
    response
  >, error>

  /// Returns whether or not the original client request arrived with a
  /// Fastly-Key belonging to a user with the rights to purge content on this
  /// service.
  http-req-key-is-valid: func() -> result<bool, error>

  http-req-close: func(h: request-handle) -> result<_, error>

  flags content-encodings {
    gzip
  }
  http-req-auto-decompress-response-set: func(h: request-handle, encodings: content-encodings) -> result<_, error>

  http-req-upgrade-websocket: func(backend: string) -> result<_, error>

  http-req-redirect-to-websocket-proxy: func(backend: string) -> result<_, error>

  http-req-redirect-to-grip-proxy: func(backend: string) -> result<_, error>

  /// Adjust how this requests's framing headers are determined.
  enum framing-headers-mode {
    automatic,
    manually-from-headers
  }
  http-req-framing-headers-mode-set: func(h: request-handle, mode: framing-headers-mode) -> result<_, error>

  enum tls-version {
    tls1,
    tls11,
    tls12,
    tls13
  }

  /// Create a backend for later use
  record dynamic-backend-config {
    host-override: option<string>,
    connect-timeout: option<u32>,
    first-byte-timeout: option<u32>,
    between-bytes-timeout: option<u32>,
    use-ssl: option<bool>,
    dont-pool: option<bool>,
    ssl-min-version: option<tls-version>,
    ssl-max-version: option<tls-version>,
    cert-hostname: option<string>,
    ca-cert: option<string>,
    ciphers: option<string>,
    sni-hostname: option<string>,
  }
  http-req-register-dynamic-backend: func(prefix: string, target: string, config: dynamic-backend-config) -> result<_, error>


  /*
   * Fastly HTTP Resp
   */
  type http-status = u16

  http-resp-new: func() -> result<response-handle, error>

  http-resp-header-names-get: func(h: response-handle) -> result<list<string>, error>

  http-resp-header-value-get: func(h: response-handle, name: string) -> result<option<string>, error>

  http-resp-header-values-get: func(h: response-handle, name: string) -> result<option<list<string>>, error>

  http-resp-header-values-set: func(h: response-handle, name: string, values: list<string>) -> result<_, error>

  http-resp-header-insert: func(h: response-handle, name: string, value: string) -> result<_, error>

  http-resp-header-append: func(h: response-handle, name: string, value: string) -> result<_, error>

  http-resp-header-remove: func(h: response-handle, name: string) -> result<_, error>

  http-resp-version-get: func(h: response-handle) -> result<http-version, error>

  http-resp-version-set: func(h: response-handle, version: http-version) -> result<_, error>

  http-resp-send-downstream: func(h: response-handle, b: body-handle, streaming: bool) -> result<_, error>

  http-resp-status-get: func(h: response-handle) -> result<http-status, error>

  http-resp-status-set: func(h: response-handle, status: http-status) -> result<_, error>

  http-resp-close: func(h: response-handle) -> result<_, error>

  /// Adjust how this response's framing headers are determined.
  http-resp-framing-headers-mode-set: func(h: response-handle, mode: framing-headers-mode) -> result<_, error>


  /*
   * Fastly Geo
   */
  record geo-data {
    /**
    * The name of the organization associated with as_number.
    *
    * For example, fastly is the value given for IP addresses under AS-54113.
    */
    as-name: option<string>,

    /**
    * [Autonomous system](https://en.wikipedia.org/wiki/Autonomous_system_(Internet)) (AS) number.
    */
    as-number: option<u32>,

    /**
    * The telephone area code associated with an IP address.
    *
    * These are only available for IP addresses in the United States, its territories, and Canada.
    */
    area-code: option<u32>,

    /**
    * City or town name.
    */
    city: option<string>,

    /**
    * Connection speed.
    */
    conn-speed: option<string>,

    /**
    * Connection type.
    */
    conn-type: option<string>,

    /**
    * Continent.
    */
    continent: option<string>,

    /**
    * A two-character [ISO 3166-1](https://en.wikipedia.org/wiki/ISO_3166-1) country code for the country associated with an IP address.
    *
    * The US country code is returned for IP addresses associated with overseas United States military bases.
    *
    * These values include subdivisions that are assigned their own country codes in ISO 3166-1. For example, subdivisions NO-21 and NO-22 are presented with the country code SJ for Svalbard and the Jan Mayen Islands.
    */
    country-code: option<string>,

    /**
    * A three-character [ISO 3166-1 alpha-3](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3) country code for the country associated with the IP address.
    *
    * The USA country code is returned for IP addresses associated with overseas United States military bases.
    */
    country-code3: option<string>,

    /**
    * Country name.
    *
    * This field is the [ISO 3166-1](https://en.wikipedia.org/wiki/ISO_3166-1) English short name for a country.
    */
    country-name: option<string>,

    /**
    * Time zone offset from Greenwich Mean Time (GMT) for `city`.
    */
    gmt-offset: option<string>,

    /**
    * Latitude, in units of degrees from the equator.
    *
    * Values range from -90.0 to +90.0 inclusive, and are based on the [WGS 84](https://en.wikipedia.org/wiki/World_Geodetic_System) coordinate reference system.
    */
    latitude: option<float32>,

    /**
    * Longitude, in units of degrees from the [IERS Reference Meridian](https://en.wikipedia.org/wiki/IERS_Reference_Meridian).
    *
    * Values range from -180.0 to +180.0 inclusive, and are based on the [WGS 84](https://en.wikipedia.org/wiki/World_Geodetic_System) coordinate reference system.
    */
    longitude: option<float32>,

    /**
    * Metro code, representing designated market areas (DMAs) in the United States.
    */
    metro-code: option<u32>,

    /**
    * The postal code associated with the IP address.
    *
    * These are available for some IP addresses in Australia, Canada, France, Germany, Italy, Spain, Switzerland, the United Kingdom, and the United States.
    *
    * For Canadian postal codes, this is the first 3 characters. For the United Kingdom, this is the first 2-4 characters (outward code). For countries with alphanumeric postal codes, this field is a lowercase transliteration.
    */
    postal-code: option<string>,

    /**
    * Client proxy description.
    */
    proxy-description: option<string>,

    /**
    * Client proxy type.
    */
    proxy-type: option<string>,

    /**
    * [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2) country subdivision code.
    *
    * For countries with multiple levels of subdivision (for example, nations within the United Kingdom), this variable gives the more specific subdivision.
    *
    * This field can be None for countries that do not have ISO country subdivision codes. For example, None is given for IP addresses assigned to the Ã…land Islands (country code AX, illustrated below).
    */
    region: option<string>,

    /**
    * Time zone offset from coordinated universal time (UTC) for `city`.
    */
    utc-offset: option<u32>,
  }

  /// JSON string for now
  geo-lookup: func(addr-octets: list<u8>) -> result<string, error>


  /*
   * Fastly Async IO
   */
  /// A handle to an object supporting generic async operations.
  /// Can be either a `BodyHandle` or a `PendingRequestHandle`.
  ///
  /// Each async item has an associated I/O action:
  ///
  /// * Pending requests: awaiting the response headers / `Response` object
  /// * Normal bodies: reading bytes from the body
  /// * Streaming bodies: writing bytes to the body
  ///
  /// For writing bytes, note that there is a large host-side buffer that bytes can eagerly be written
  /// into, even before the origin itself consumes that data.
  type async-handle = u32

  /// Blocks until one of the given objects is ready for I/O, or the optional timeout expires.
  ///
  /// Valid object handles includes bodies and pending requests. See the `async_item_handle`
  /// definition for more details, including what I/O actions are associated with each handle
  /// type.
  ///
  /// The timeout is specified in milliseconds, or 0 if no timeout is desired.
  ///
  /// Returns the _index_ (not handle!) of the first object that is ready, or
  /// none if the timeout expires before any objects are ready for I/O.
  async-io-select: func(hs: list<async-handle>, timeout-ms: u32) -> result<option<u32>, error>

  /// Returns 1 if the given async item is "ready" for its associated I/O action, 0 otherwise.
  ///
  /// If an object is ready, the I/O action is guaranteed to complete without blocking.
  ///
  /// Valid object handles includes bodies and pending requests. See the `async_item_handle`
  /// definition for more details, including what I/O actions are associated with each handle
  /// type.
  async-io-is-ready: func(handle: async-handle) -> result<bool, error>


  /*
   * Fastly Purge
   */

  flags purge-options-mask {
    soft-purge,
    ret-buf
  }

  /*
   * A surrogate key can be a max of 1024 characters.
   * A surrogate key must contain only printable ASCII characters (those between `0x21` and `0x7E`, inclusive).
   */
  purge-surrogate-key: func(surrogate-keys: string, purge-options: purge-options-mask) -> result<option<string>, error>

  /*
   * Fastly Cache
   */
  /// The outcome of a cache lookup (either bare or as part of a cache transaction)
  type cache-handle = u32
  type cache-object-length = u64
  type cache-duration-ns = u64
  type cache-hit-count = u64

  /// Extensible options for cache lookup operations; currently used for both `lookup` and `transaction_lookup`.
  record cache-lookup-options {
    /**
     * A full request handle, but used only for its headers
     */
    request-headers: option<request-handle>,
  }

  /// Configuration for several hostcalls that write to the cache:
  /// - `insert`
  /// - `transaction-insert`
  /// - `transaction-insert-and-stream-back`
  /// - `transaction-update`
  ///
  /// Some options are only allowed for certain of these hostcalls; see `cache-write-options-mask`.
  record cache-write-options {
    /// this is a required field; there's no flag for it
    max-age-ns: cache-duration-ns,
    /// a full request handle, but used only for its headers
    request-headers: request-handle,
    /// a list of header names separated by spaces
    vary-rule: string,
    /// The initial age of the object in nanoseconds (default: 0).
    ///
    /// This age is used to determine the freshness lifetime of the object as well as to
    /// prioritize which variant to return if a subsequent lookup matches more than one vary rule
    initial-age-ns: cache-duration-ns,
    stale-while-revalidate-ns: cache-duration-ns,
    /// a list of surrogate keys separated by spaces
    surrogate-keys: string,
    length: cache-object-length,
    user-metadata: list<u8>,
    sensitive-data: bool,
  }

  record cache-get-body-options {
    start: u64,
    end: u64,
  }

  /// The status of this lookup (and potential transaction)
  flags cache-lookup-state {
    /// a cached object was found
    found,
    /// the cached object is valid to use (implies found)
    usable,
    /// the cached object is stale (but may or may not be valid to use)
    stale,
    /// this client is requested to insert or revalidate an object
    must-insert-or-update,
  }

  /// Performs a non-request-collapsing cache lookup.
  ///
  /// Returns a result without waiting for any request collapsing that may be ongoing.
  cache-lookup: func(cache-key: string, options: cache-lookup-options) -> result<cache-handle, error>

  /// Performs a non-request-collapsing cache insertion (or update).
  ///
  /// The returned handle is to a streaming body that is used for writing the object into
  /// the cache.
  cache-insert: func(cache-key: string, options: cache-write-options) -> result<body-handle, error>

  /// The entrypoint to the request-collapsing cache transaction API.
  ///
  /// This operation always participates in request collapsing and may return stale objects. To bypass
  /// request collapsing, use `lookup` and `insert` instead.
  transaction-lookup: func(cache-key: string, options: cache-lookup-options) -> result<cache-handle, error>

  /// Insert an object into the cache with the given metadata, and return a readable stream of the
  /// bytes as they are stored.
  ///
  /// This helps avoid the "slow reader" problem on a teed stream, for example when a program wishes
  /// to store a backend request in the cache while simultaneously streaming to a client in an HTTP
  /// response.
  ///
  /// The returned body handle is to a streaming body that is used for writing the object _into_
  /// the cache. The returned cache handle provides a separate transaction for reading out the
  /// newly cached object to send elsewhere.
  transaction-insert-and-stream-back: func(handle: cache-handle, options: cache-write-options) -> result<tuple<body-handle, cache-handle>, error>

  /// Cancel an obligation to provide an object to the cache.
  ///
  /// Useful if there is an error before streaming is possible, e.g. if a backend is unreachable.
  transaction-cancel: func(handle: cache-handle) -> result<_, error>

  cache-get-state: func(handle: cache-handle) -> result<cache-lookup-state, error>

  /// Gets a range of the found object body, returning the `$none` error if there
  /// was no found object.
  ///
  /// The returned `body_handle` must be closed before calling this function again on the same
  /// `cache_handle`.
  ///
  /// Note: until the CacheD protocol is adjusted to fully support this functionality,
  /// the body of objects that are past the stale-while-revalidate period will not
  /// be available, even when other metadata is.
  cache-get-body: func(handle: cache-handle, options: cache-get-body-options) -> result<body-handle, error>

}

/*
 * Fastly Log
 */
interface log {

  use types.{error, log-endpoint-handle}

  endpoint-get: func(name: string) -> result<log-endpoint-handle, error>

  write: func(h: log-endpoint-handle, msg: string) -> result<_, error>
}

/*
 * Fastly Dictionary
 */
interface dictionary {

  use types.{error, dictionary-handle}

  open: func(name: string) -> result<dictionary-handle, error>

  get: func(h: dictionary-handle, key: string) -> result<option<string>, error>
}

/*
 * Fastly Secret Store
 */
interface secret-store {

  use types.{error, secret-store-handle, secret-handle}

  open: func(name: string) -> result<secret-store-handle, error>

  get: func(store: secret-store-handle, key: string) -> result<option<secret-handle>, error>

  plaintext: func(secret: secret-handle) -> result<option<string>, error>

}

/*
 * Fastly KV Store
 */
interface object-store {

  use types.{object-store-handle, fd, body-handle, error}

  open: func(name: string) -> result<object-store-handle, error>

  lookup: func(store: object-store-handle, key: string) -> result<option<body-handle>, error>

  lookup-as-fd: func(store: object-store-handle, key: string) -> result<option<fd>, error>

  // Should object store insert return "inserted" bool?
  insert: func(store: object-store-handle, key: string, body-handle: body-handle) -> result<_, error>

}

/*
 * Fastly HTTP Body
 */
interface http-body {
  use types.{error, body-handle, body-write-end}

  new: func() -> result<body-handle, error>

  append: func(dest: body-handle, src: body-handle) -> result<_, error>

  read: func(h: body-handle, chunk-size: u32) -> result<list<u8>, error>

  write: func(h: body-handle, buf: list<u8>, end: body-write-end) -> result<u32, error>

  close: func(h: body-handle) -> result<_, error>
}

world fastly-world {

  import fastly
  import dictionary
  import log
  import secret-store
  import object-store
  import http-body

  export compute-at-edge: interface {
    type request-handle = u32
    type body-handle = u32
    type request = tuple<request-handle, body-handle>

    /// Serve the given request
    ///
    /// response handle not currently returned, because in the case of a streamed response
    /// send downstream must be fully streamed due to the run to completion semantics.
    serve: func(req: request) -> result
  }
}
