// The constructor created by cbindgen's `derive_constructor` causes this warning.
// Gecko's various uses of cbindgen silence it, so we do, too.
#ifdef __clang__
#  pragma GCC diagnostic ignored "-Wreturn-type-c-linkage"
#endif


#ifndef rust_url_bindings_h
#define rust_url_bindings_h

#pragma once

/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#include <cstdarg>
#include <cstddef>
#include <cstdint>
#include <cstdlib>
#include <ostream>
#include <new>


namespace jsurl {

struct JSUrl;

struct JSUrlSearchParams;

/// This type exists to transfer String-likes over FFI.
struct SpecString {
  uint8_t *data;
  size_t len;
  size_t cap;

  SpecString(uint8_t *const& data,
             size_t const& len,
             size_t const& cap)
    : data(data),
      len(len),
      cap(cap)
  {}


  /// Conversion to a `jsurl::SpecString`.
  operator const std::string_view() const {
    return std::string_view(reinterpret_cast<char *>(this->data), this->len);
  }
};

/// This type exists to transfer &str-likes over FFI.
struct SpecSlice {
  const uint8_t *data;
  size_t len;

  SpecSlice()
    : data(nullptr),
      len(0)
  {}

  SpecSlice(const uint8_t *const& data,
            size_t const& len)
    : data(data),
      len(len)
  {}

};

struct JSSearchParam {
  SpecSlice name;
  SpecSlice value;
  bool done;

  JSSearchParam()
    : name(SpecSlice()),
      value(SpecSlice()),
      done(false)
  {}

  JSSearchParam(SpecSlice const& name,
                SpecSlice const& value,
                bool const& done)
    : name(name),
      value(value),
      done(done)
  {}

};

template<typename T>
struct CVec {
  T *ptr;
  size_t len;
  size_t cap;

  CVec(T *const& ptr,
       size_t const& len,
       size_t const& cap)
    : ptr(ptr),
      len(len),
      cap(cap)
  {}

};


extern "C" {

JSUrl *new_jsurl(const SpecString *spec);

JSUrl *new_jsurl_with_base(const SpecString *spec, const JSUrl *base);

SpecSlice authority(const JSUrl *url);

SpecSlice path_with_query(const JSUrl *url);

SpecSlice hash(const JSUrl *url);

void set_hash(JSUrl *url, const SpecString *hash);

SpecSlice host(const JSUrl *url);

void set_host(JSUrl *url, const SpecString *host);

SpecSlice hostname(const JSUrl *url);

void set_hostname(JSUrl *url, const SpecString *hostname);

SpecSlice href(const JSUrl *url);

void set_href(JSUrl *url, const SpecString *href);

SpecString origin(const JSUrl *url);

SpecSlice password(const JSUrl *url);

void set_password(JSUrl *url, const SpecString *password);

SpecSlice pathname(const JSUrl *url);

void set_pathname(JSUrl *url, const SpecString *pathname);

SpecSlice port(const JSUrl *url);

void set_port(JSUrl *url, const SpecString *port);

SpecSlice protocol(const JSUrl *url);

void set_protocol(JSUrl *url, const SpecString *protocol);

SpecSlice search(const JSUrl *url);

void set_search(JSUrl *url, const SpecString *search);

SpecSlice username(const JSUrl *url);

void set_username(JSUrl *url, const SpecString *username);

JSUrlSearchParams *url_search_params(JSUrl *url);

JSUrlSearchParams *new_params();

void params_init(JSUrlSearchParams *params, const SpecString *init);

void params_append(JSUrlSearchParams *params, SpecString name, SpecString value);

void params_delete(JSUrlSearchParams *params, const SpecString *name);

bool params_has(const JSUrlSearchParams *params, const SpecString *name);

SpecSlice params_get(const JSUrlSearchParams *params, const SpecString *name);

void params_at(const JSUrlSearchParams *params, size_t index, JSSearchParam *param_out);

CVec<SpecSlice> params_get_all(const JSUrlSearchParams *params, const SpecString *name);

void params_set(JSUrlSearchParams *params, SpecString name, SpecString value);

void params_sort(JSUrlSearchParams *params);

SpecSlice params_to_string(const JSUrlSearchParams *params);

} // extern "C"

} // namespace jsurl

#endif // rust_url_bindings_h
